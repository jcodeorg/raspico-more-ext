var img$2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAlgAAAF0CAYAAAD/4EcMAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAFUmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSfvu78nIGlkPSdXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQnPz4KPHg6eG1wbWV0YSB4bWxuczp4PSdhZG9iZTpuczptZXRhLyc+CjxyZGY6UkRGIHhtbG5zOnJkZj0naHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyc+CgogPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9JycKICB4bWxuczpBdHRyaWI9J2h0dHA6Ly9ucy5hdHRyaWJ1dGlvbi5jb20vYWRzLzEuMC8nPgogIDxBdHRyaWI6QWRzPgogICA8cmRmOlNlcT4KICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0nUmVzb3VyY2UnPgogICAgIDxBdHRyaWI6Q3JlYXRlZD4yMDI0LTExLTAzPC9BdHRyaWI6Q3JlYXRlZD4KICAgICA8QXR0cmliOkV4dElkPjE8L0F0dHJpYjpFeHRJZD4KICAgICA8QXR0cmliOkZiSWQ+NTI1MjY1OTE0MTc5NTgwPC9BdHRyaWI6RmJJZD4KICAgICA8QXR0cmliOlRvdWNoVHlwZT4yPC9BdHRyaWI6VG91Y2hUeXBlPgogICAgPC9yZGY6bGk+CiAgIDwvcmRmOlNlcT4KICA8L0F0dHJpYjpBZHM+CiA8L3JkZjpEZXNjcmlwdGlvbj4KCiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0nJwogIHhtbG5zOkNvbnRhaW5zQWlHZW5lcmF0ZWRDb250ZW50PSdodHRwczovL2NhbnZhLmNvbS9leHBvcnQnPgogIDxDb250YWluc0FpR2VuZXJhdGVkQ29udGVudDpDb250YWluc0FpR2VuZXJhdGVkQ29udGVudD5ZZXM8L0NvbnRhaW5zQWlHZW5lcmF0ZWRDb250ZW50OkNvbnRhaW5zQWlHZW5lcmF0ZWRDb250ZW50PgogPC9yZGY6RGVzY3JpcHRpb24+CgogPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9JycKICB4bWxuczpkYz0naHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8nPgogIDxkYzp0aXRsZT4KICAgPHJkZjpBbHQ+CiAgICA8cmRmOmxpIHhtbDpsYW5nPSd4LWRlZmF1bHQnPuWQjeensOacquioreWumuOBruODh+OCtuOCpOODsyAtIDE8L3JkZjpsaT4KICAgPC9yZGY6QWx0PgogIDwvZGM6dGl0bGU+CiA8L3JkZjpEZXNjcmlwdGlvbj4KCiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0nJwogIHhtbG5zOnBkZj0naHR0cDovL25zLmFkb2JlLmNvbS9wZGYvMS4zLyc+CiAgPHBkZjpBdXRob3I+5LyK6Jek5Yqf5LiAPC9wZGY6QXV0aG9yPgogPC9yZGY6RGVzY3JpcHRpb24+CgogPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9JycKICB4bWxuczp4bXA9J2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8nPgogIDx4bXA6Q3JlYXRvclRvb2w+Q2FudmEgKFJlbmRlcmVyKTwveG1wOkNyZWF0b3JUb29sPgogPC9yZGY6RGVzY3JpcHRpb24+CjwvcmRmOlJERj4KPC94OnhtcG1ldGE+Cjw/eHBhY2tldCBlbmQ9J3InPz7QGPGqAAFsKElEQVR4nOzd6ZNk2Xnf9+9zzrk3t1q6qrt6ncbsKwYrSQAiRFK2KAZtK0S98RIO6YXk0F9iR/iVX1oMr6LDIVM2adoOiza4wRRAERhgCICDAWafnt632iuzMm/ee87jF+ferOyegeyQKkI28HwQM9Nr1s2l4v7wnOc8R1RVMcYYY4wxp8b9674AY4wxxpifNhawjDHGGGNOmQUsY4wxxphTZgHLGGOMMeaUWcAyxhhjjDllFrCMMcYYY06ZBSxjjDHGmFNmAcsYY4wx5pRZwDLGGGOMOWUWsIwxxhhjTpkFLGOMMcaYU2YByxhjjDHmlFnAMsYYY4w5ZRawjDHGGGNOmQUsY4wxxphTZgHLGGOMMeaUWcAyxhhjjDllFrCMMcYYY06ZBSxjjDHGmFNmAcsYY4wx5pRZwDLGGGOMOWUWsIwxxhhjTpkFLGOMMcaYU2YByxhjjDHmlFnAMsYYY4w5ZRawjDHGGGNOmQUsY4wxxphTZgHLGGOMMeaUWcAyxhhjjDllFrCMMcYYY06ZBSxjjDHGmFNmAcsYY4wx5pRZwDLGGGOMOWUWsIwxxhhjTpkFLGOMMcaYU2YByxhjjDHmlFnAMsYYY4w5ZRawjDHGGGNOmQUsY4wxxphTZgHLGGOMMeaUWcAyxhhjjDllFrCMMcYYY06ZBSxjjDHGmFNmAcsYY4wx5pRZwDLGGGOMOWUWsIwxxhhjTpkFLGOMMcaYU2YByxhjjDHmlFnAMsYYY4w5ZRawjDHGGGNOmQUsY4wxxphTZgHLGGOMMeaUWcAyxhhjjDllFrCMMcYYY06ZBSxjjDHGmFNmAcsYY4wx5pRZwDLGGGOMOWUWsIwxxhhjTpkFLGOMMcaYU2YByxhjjDHmlFnAMsYYY4w5ZRawjDHGGGNOmQUsY4wxxphTZgHLGGOMMeaUWcAyxhhjjDllFrCMMcYYY06ZBSxjjDHGmFNmAcsYY4wx5pRZwDLGGGOMOWUWsIwxxhhjTpkFLGOMMcaYU2YByxhjjDHmlFnAMsYYY4w5ZRawjDHGGGNOmQUsY4wxxphTZgHLGGOMMeaUWcAyxhhjjDllFrCMMcYYY06ZBSxjjDHGmFNmAcsYY4wx5pSFf90XYMz/Vxy98QFH33sb5xxNE3HeIUBKmv+AgHzsb3W/oie/pKAoNFCslzR7M5IXokv44YA0noL3AMznNWUIOO9wCEkTThyKor2Szb/6OeZHEwZXz7P/9e9R7R7gABFZfHUFRMCP+tRHM0BRVVJMqMA8JvprA+p5jbr2SYhDu+sUSADegVs8IiRtn0v+Ss4JqYqIeJI2BBwJRRBEQDWSqoqQBO8cXhyh8PieJ04bFPBrPeppjVb14rFFwItDRPKrKUJK2j5HXbzG+Wvkr8dLm7zx+jW2RgNKCWy+dJWP3v6AejJnq7/O7elDLhRrRITBesmd+9sc9TwqynpRcmnuiBoJ3uPEEcThfPtfcSdvrebr0PyqIp/wfucrFBClSTWrX3mF7T9/Gx8jcXOARKGezRmcXaO6tkP/6XMcfniPYm2V+mhM0vYZtk/XqeJ7HhUhzhODnmMYCkBQOfkELq5EBSFfo2i+Gm1/pfuULF+ta6/55LG0/ZPda730ee/eo/YVQNv3AehvraN9z+z6dv7sAGuff4HVzz//se8SY34Wiarq//MfM+an353f+n1u/sPfI4RAVVWEEBARmqYBlkKNSL7Ry8fjlqqCKi4qTZ1Y+/ITHL67TVoLNDsVg60+R9cOKZ9aJd4/4vhozmhQUhZFDlgp4b1HVWk0QQjEpiF5D/MGrymHApdvk93t0ImQSg+zGtrHaTSRUmI6b1hb67O/e4gUnmk1A3XtXVYXN19VRT3EuqHwBaoJ0ByiUqJflhzPKoaDVab1FAGKfklVzSmco/CBWoV+CATvKL1nMOhTrAbm+3NUwRWOqq6RCCqgKS0Clnc54CjQpNQ+Rx55rVUVpw7920/y3/7mn1KeKyinNVUhyFQYRMdn1q7w2t7bfGn0JDva8GO3zaRORC/UknhhtMnPHUKtNb2yJDjP0AVCWdJzAe8cbvEen3x9/fjbnV8zwCGoKDxzDp1OmTw8gnFNfGINPRZiVRHOrnH41h36V8+w/f49/JOb6If7JK2JDiQm5EvPUX//AzZCSSg8TYqsv3ie1YMaPxWSdHFX2gAkOWCpEFXbJYn8c+EksKJ6cv2iOMnvqxNHg+SgrSexUTTlwLsIWHERNqV93itffYreSsmdP/gxZShQ4Il/8Bs88Q/+1r/Mt58xP3WsgmVMSxRc+//QT241Hw9SnxyutP29hKiQnJCINLd3mN/fxadV2K+oZjNCSuj+DFKiaKtjj9RDRFFNOCA1DT4lqGtEBV+EXIDiJBgJkFSRWU0dG1xbDfIIIkIpnmG/zzhMaGKiV/ZyhYx840Vz2EGV6MB7R+ELUkr5pkq++Rf9gsI7RmWPtDWEvTG9skRiIvhA8B6aGkfCiyc431bHUr5Rq5LqRFAHvr1656G9kUMOr0lzBa7TBa2U8k0/amSQCp76xWdYf7LPm9/+gGFZcP/mLqX2iUSSQqORJkSmFTSqTJqKng/01/owmeKinLzfXQjR7n1s/5sSKooLBXHe5GuVNmznt2pR2axfeQLXL+HcKhtPX6SOCY0Jr56kcyQpvZWr+OBZf/Ic5daQw41bbLz6HMfv3uLo/g5bwx7u55+nVI8GocAhXnm4e4+DScVw0M8Bu/28ouCSo24/L1G7uCc4ckAWzZUv0fZz4hIuBbwTmhQRVbzLQe0kVLaffXLEziXOHCIjieAd9aRm57UPoYmoD903jjGmZQHLmNbilq5dlaBdHOl+vlTBevRvnfwZBzkgIThVau9QX1BvDvA7FdW5IcXNCcQcceYSKdobew45CZGAkpB2Ec77QFKFpB9bHuwqUPm+6nAuV7/aRINzHie56hWKgiBCjDFXj9DFc803UIiaEJ8DmnoB7ZaXhGJQEqoaFzzh4ZiiX+LFk1wOUz4EmtjgnSd4j7h8o1eNaFcRal8fcW5REemeyycV08W5RZWre9mDFNSl59abt7lzzUF07E7n1CI0JOZpRgyJaRlxT11g8OYuZel49vMvcOPH12n2DxEKvPM5irSlHScfXwNWhcELZ4m396mHgbjbVjZpF9aUxY/T+7cZrxaMx/vIoVJVFTqpmROpveBKz/F0Rj2r2U/K3DU86Ut2Xv8RhXgG5za4/hcPmU8mlBoYSCAIDPoFly9v0cQ5xzNlUPYofMCLQ1UoPnOR9Yvr7ZKuW7z/ycviM5lUgZqmUUQjjS/pbW7A1gqprvE4iAmvSlLFaSSiBASNTQ6TjZImUyByfG+fnij1UY0LjrC0eGqMySxgGdNarlzlpRBBdTlYwaN34K7isVRtSbmPKaVEwCPJI7WnXxY08xyQKs3LbcXTZym/cxehQDQgKjSxIcRIODckVjVuT0ghEoJH40lfkmpeJlIRHAKawLU3QRE0RUQdURNeQEpHgRDJAQonIA6X8mMhOeDFGE8KEeoW/VkiCSkDwTl6zjFzQi94GgehV+CTUPpAIx7fhivXXpu21+Pa6o8uepz+xbfkXERJH/tjyQvu23f4e7/+ZaRRXMzPM8ZIdIo0kVfkaRClv7LK33j1GZwPubft01+h0Zr3/vGfULTXEUTa17X7Z+lz4KCeTNEm0QhU2tBvyAFSHu3I8scNqy9/inoncHz7I5wq6oXVJ8/jtoYcPRiTDsZc/PST3Pv697nwxFV0tWTy/h1WCQyeOcfB4R5r1zz9S6vMe5HyxhjvAqjSCIT2PQrSfs6kYfXMKg/+6C9hDknj4nXtri5pAoX+1oh4tiC8ecDuC+v0fnnE9u/9Cev3ZtAkmiRoBOc8PtdFaTYDxXZFUZS4lChVmRdC6QLlL1xd+nZok6Z8PCQb87PKApYxCydhybEcpdoQstQA3N30cz9WanteIDpl8JXnGFxYy9WFVWX1F+YkP4eXz6Mukb48x/d6yACqi57S5eARY6SpV3DBU31/m8GnL7D3rdsUKeCcoN260CL05QqKnuuhZwS5EdF1T/qUIj+EGCL9S2tM3z/EiUcEVp8/w+zBhDTOy4LOt506mm/Ej4cZ6Z6/81BFChcQ53LFqihITV66dN7hfVvJaoOVa/uWtFuCW94I8EnbBR774suN3yevNbkCc+eAdHOXWdMwnh2TyrZ1Oznmszllv89sOqeQgNKgbcO/aKIIjuAd4lyuYom0YRBcuyy2uBYV9N6UJiWq4xnHTU2vfGw5TMGLgHgOb9xnunNA0pPG8oOdA+a7B8Q5yLxmcnOHmkQ8OqI5djSaaAYw3jmmN2lQIrpfsfLEiHl9SNNr0JQWPVLe52XVpPn9d02Dcw4NgnceweXPZBt2AoEkiqwMKNY9xWBA4QIbzz2JfnCP3uEdogrHbdXLeY93jjhrKJ8/S3kx4YOH+4dUe0cUocCpAxIqsd0EUnzSN5QxP9MsYBmz0HY3nWzPWvSudH02Jx1T8ujfy6UunEIjDfe//kPmhTB7dpOd9x8S5zNC0Yf1AXrvkPKJNarvvksZSvpFQYj5hhXwuKCcObdGKBx1Uop269Zya9jycpqMKxwBVxQ0dcVwPGDuItp3uEsN6X1yHxECtya42C3+5GWxLsiIts3dAO2SnjtpyAGEVOYqWigCqYm4RLs06RC0DSv5cTp56fPjy2/d83h86fXk1xKiS5NklpbjnBNQT79wBO+ZSoUOAmm3QoLQLwQXHerASUFTNwTnWRSqNC9TOufwkjcNuC5TaULaZntBiQoaHGHuCCqkbml1+Tmq0lvvcby7y+xgSvTtH3FC5YWmKEizGawN0CaB9/j+iFqgljGf+utfYeOJTR78oz/i6miTUjzywFNsXcZ78OHkM0gXCNuQldq9nPkldjmEy9LmhXZPYbxzgN6G5Bx+1Gd35wB/fT+Hby9srvRQSYgT/MqAyWevcPCj99FXn8GXUH5QMFi5ApMp9eu3UM1fP0hbUbXilTGPsIBlTEu7fpxQUPb7pKCI89T7R/h5bhjGLe20+oTHKJ69hN4doxfPMjvcQ77wJHcme7jeOit+wNkvvsS13/waTz/1FM035wTvYHOIuzqkvDajXweceNJ+XvJzMZF83n5/skSpS19bYAY6rvDnSprDivp6QjRR787p/6jEpxwVnDhS44lR2+W6pWb9tiqWSO3vnfSVdU3o4oTYNpzn8QaSm781tX9MENf+95ERAO1r99grJouq4KO/1YU8XTzn9pHarKW62NqGEyidx2uPFIWZ1MTgKAtPUzVtFS2HD//YtTnXVrHaQCiSR1EsFv5UUUkkgbpJOdhxUudc9GEhRJTesM/RfsWH8z1IMCdxoHP8xnmef/IC1//5m2yeu8r98YSKxP5sSmpqIpEffPM15i6xlRIPZlNWigHxeM7llTUGZ1dJNw/z1+7eknb5+uRTIKgkkLT4fwKPVwRTXvElpoQEwNVIAK8CRHQ8aStvAkc1ceihgelv/zklikigcQIeNPZoVpTgfP667V7KT9xqaczPKAtYxrSc5ijgP/ciqVGKMyV14dDXf0y8u4+K0rZFt3v4pK15db1FILf3UK0JVcXWYMCt29u493bQqiFeOMP2yg229qYc/eN/TnCeRpR4ZsD8L7ZxZY9YCOIdSRwOhybNTVDtnX35/tXd4BXFtQmi8UKh7QwELyARgKi52lRIAaXQNDE/Qtc6I7J4RosN/ouSXY4UIm3fUbvkJ+LyMqPkco2mdFIRg3YHopw8jGieb+U/Pt94uSC0HK4e2bG5lNFUT65WAY+HOuGCp2wioQgEn3dUqgNNbW8YXTN7DpziJI+I6HrZFheUX5N4eYPJ3/8qB7d3CIXQv7ZN/P03UfGL60basEZgfXWVcLBHLVD0+uhE+ejWXaqHB2zLnP17N3l+cIZJKSgNDYlzW+e4MOxx4+iIzSdX2Vhb440fvcdLgzNUmyOe/9s/x93/+p9Rjz/+mZX2g5HHReiictiN8eieiwJJ2pCcmjyjLPm8cxBAhcpFPIGSXL3rH854OJ+y9uQlRk9vonf36Q9L1Dn8Sknz4UEbqrtX7tF+RGN+1lnAMqalQKHC7M59puue+ECJP7hDJTOYTBAnrA9XKCT3uZwUCJbmNEneFh/wNM2c+OE9nnniPPW8oej10FnD9NmzzN+9y/HTA4qbM4p37tHDEes5lSraU7z0ILl2d7wulu269uXlr5XyQhbS71GsrSL709zMjuCkQJm2PTuR+ZojHOZKVNvbviCwCBldcOyCZK4CKV5yP30hjpjAe3lkJ2PwoW3+ViTlLf7OORpqXHdwRBtKVE6qUY52l6FzkNrxAvJoEFvu4pIu0eary0EPYVCU1AIaY+5H6ipzTvJyYNsb1j2G68LVYtDpoussvwLjOfOv/QA3GjGeTZg/2GdVE4WmxZIq7XPvSUnlhY3PvYCOp8j6iPk7H3Hj/pgra5scbN/P4ys2VphNDhiVBZUk9va2eTh27FcNSRK7+2OO60Qx9ExubPO93/q/WJ/MKaVcLHHmalq7fK0R2jqh/3ihcPH5dMEzjXN6ox4qSiOKxppCIIpwOJmyUg4oQolTiAL95y9RuYLdgefMm/s0BwFJkTBJeO9wXtoeLG2vxQKWMR0LWMZ0VGiS0n/uCjeuVszeu8dWo9ATEhCc+6SVrja8tBvzBFQdNQ29zz/NuWbC9Ljh6OY+yQfmr9+gilOiCj5GQgz4AKOtEdXuHEkJlyIiEVntceYLT1MUHly7I8+3Szj+pFcK9aCJctRD5jWkdq6ROLwm3KSitzFEL23iPYx/eBOdazdTIj/1T+iFWuZUkUbQCyPSwxp5dRP30RHaV9xaQfxwRtfLvvj7IviBJ7mGpmno9Xq5f6krqSyV47QNAV0l5pG3ZXlMhnZ1w7bPaGnJTAB1Qln2aOqaMuQlKxXa5vsciHy7HLhcffnYkIEuzFaRkTrivT36QNw+ZhagIBLa6k/3fAsvHO1NqSZH+CJQz2tW1jZZ3dnmKM754vmrvHt0j1ILmhRxhcfNYW1ljSfWzvGtG2/y8rnP8p3bHxJJROc4+6Vn6b8ypP6tH+J8HqFw0lvVVlC7mV3Lr9nSx1SQbgoH1JHj4yOGukURAmljBT0+JAicH620IytyOPfqmHzwgPNPPMHqODE5qpA+xLomEIgxLd5vRemvr7bjIIwxYAHLmCWC4HE40qxhf7Xg8N96kvN/+h7F0opL55GsdZIp8lgDHDt7O8iH2zDqM23GzI+UJ//OX+H+H/+Qo5s7BAJTnbEhQ9YvDdgPgm7HPJBTIvW8pr63n3/eVn+6OBAFkIZxaLh3Zw/vfJ4XlXKjvYs5jGhw1NoQkiMUgTNeqOcVw/4AryeB8SeFKxFBU76VNxpZffYMh/fu4HwAbaDyzO8e5TETbimodK9VFJr4aHhbHHez9ApqiuDcI83Zj1sErcW/9ZEK3KIzTbveoDzbKbYBKze0y2JwqUhbwVvuu+qet7aP5x23vnieg8NDktZcuhDo/x/vIaVH/fKfb5v/8fj1wOhYORjPefrFl/ng+geseE/oleg0cH7rAnLjGlfOneM+u0yayKg3ZFj2+PDGR1RxSk8DDrjzrbdZf2udjaKfl4uXXgsnbU5Ni7Gx3arv8keyrRQmmpg4nBwTHazimFZzepMmbxiQ2IZ72hllCaHB18rB135IEGVQlsQmEXzeMRhwqOSRHKMzq0x3Dx/Z3GDMzzoLWMZ02qrK+PiY0dfe4vBzV7nWHPKrZwb0dse5UISc9AtJ2zuUdDGOoGtGF3H03zpgemmTYjhEdqf4+SH13gQfXT7y5GZF2VaaJtuO+d0ZRZG3iymCmyv1g0Pwvu2TUaKQl+sAmsTUzZjuVzSpyT02ADE3qyd1pFQDgTo1nBmO2FhZ4WFTsVE71op+HtOw6GVfamxvOT25YTsHsx/s4VXwHx1S1wFSws3zES6q7ZTzlHdf5sYfz8bnL3P3n34EHlJMXZkLjxC1AXWUV88x7df4awc4FZp2+OonHke09G+ER65ZusqYc7gkxPb5BecJQBLJ/WqcJOaTSs/S12gHv8q84WB3is4dhw547z4vdEf4tGVLbZvkUuEQD2XtmM1m1NWct157jRcuP8XdvV2O3AEym3Pn2gfUwM7th+xUR3jn2N15yIFErm5scTBRYpWXddfPn+XC2XU2L53l1jfepPAFy3FQll6NReHwkz7bknuw0rk10lefZ35nTM95pq9scfTBA3jmPMfvfEC5tkJV56nzV567wNlZhb90gfVLJbf+6ZsMvafw5FENPo/rSFGZ7hy0w2uNMR0LWMa0VBzHruEvPu3ofeWrbABbrmR8/Rv02kCgy0tgSyJQrhTQaB4NoIqg+M9/iul8Tn9yhv0evPX1v2BQwblf/wzujbs094/yzbHdgJUWy2EsNQ8L0h3SvLyzLgguOQZPnuHwxkMCAQmOlZfOsffeNqFwVHsw+uIlak00P3qYb7IRYh1JIbXLdCe36cdXQLulJUXzlPeU0HY8gEsRnKduG+VPluxy8hSF/r//S7w7mxP/3sskldxeJY6mrvMRQDi8KP31AWs/eAffV8aTvTxZ/Ce+UR8PEZqUsBKoJ/PcH0dCXEBqpXBCIxARvArJR1x7kHXSrjOsPbb6kfdXUe+4cJwo54n5HJppIpIoVDlpEcvVNCcwGPTY2d/Dl33WyiHTGFkfrQKJsxcv8sZkxjPPPMcPd++xtTYi+R5HDydsXtjiyjv3kfVVJO6h7hiCsPvgIdPbd+HhJUrx+Zo0oRJyhVK7XZonDfddGF/+mOYRGo7wYEz9u68zX19l44vPU0lJePYydTVj9dknaRIM6zkhePYeHlIczpFK2b1VM9xcY3Y4YXrUMChKCh8WYzkWPWE/+V0z5meOBSxjWoIyjHDuew+Yhm2ayYxBGFJ89zoyHLbLV+0huZwsh6lzFElJr5yneu8BfkKuUEVFVNGHu4RpjewcM7i0SjluqL7+HsU8EVyAGlJ7fI2TdqaUU5z4fFSgO6lOPHIHc466ifhfvIReu4MPjpkm7vQr9vWAq1evUu/eZeurL3Jr+x7uxj6Taor0HHWd8o0a11aTTsLUsjZ/taGmgK0R6foePnW9UkpUJSxFs+6A4DAa8T+lMf/NW++gXmna3Wl04VHbm76DcEd54kzkPx069u+N2VxdhXZXp8hS31W3e7DdUekQokJqKsqnzzB/8yHaCP6z6/gPJtR1pJDAub/1Mjt/9D46Vfq/dJHpt+/T3+zT9KZU7yXKl9dJH44fiQgCNLHhwrVDqrphbX1EQ5+UJngvH/uzKXjGRxN0fQhNg+8N6IXI9z54A2mEd+5cR3F88O47VMC1vXscxYadOiLXj/koVTzx4YccybidL+ZJDmiXraNA2fZHdWG7246QutEVj+y0hNzgnq/QJc3nE4riGxg+POS93/4TaskN+yJK4UuSh5CURoQyJtRBD0cQoe8DZVHQ1nJzGJV2F6tq22NnjAELWMYsOM0H3qaXr6KrQ/xsTn+wwvyPXls0Eudu9nZnXTeGoF1Oqr99FyeKXFqDfWX91auQhHPPPIE+Ca9sbDCbVzipUA/H+4eU/ZKQEtVkRvV7RzjnkW5H22IqZnYyByuLJEYhcPefvEkhBcXZkt5mycGb21x+6SrVtQPKFPjOf//H9Ff7PDtcp7iywqVPr7L7v77NLDYUochhSXIVLakiS9UjgdwonhvL8KWnxhHLAp0lpPRwLMyBsnuJ2kpcUsUf13z+xWe4cn6TnusxjscUzvP1t95lrT/g/OoAbWqurqzw2o/epy4im2fP0pc8PiFpAnHEed0Osmp7tFICJzTtIcd+MCS9P8PFQKTBvTeGlCeb+3MrbH/9OvVRRSGe9MYhOok0x8ekgcep4nbnJAVxbVhpK1mujjRvfESISoPigTIUOQQvLU+qyyMfUnCMrz1kdWuNg/kuB7vb/NUv/zw3P7xPEyv2mhm/8NWv8vrv/y88d+kZbk12WImJLz39Irvf/AZnf/FlDm9c597+Ia/v3uGFcohWx20f3GPaHZJCdyTRyXu2vNtSyO9FRJgPff6cV8LxU1usfflpvvXtN/jMr3yW0f2a1Rev0hwfsfPNdzn/q69y/LW/pPZ5CKtXwbtcyfWc9LJpG3bplwz/yiv/8t+AxvyUsYBlzIIiTpn/7p8xO5rhRgXjYZ/1osQtnT13Miyhu6MlVH0e3EmuXHkRjt+5x/g7h0ybea7EqORBjgIOT+oLWiUE6A084vOROF2wEnE59dBOlH+sfdlpXooc4ZiiHD2Y0g+BM5fXSAc1fpLQIFw8dKTDKfdCxZnjhv0P7yESSFFJ7TgDyCMXUnq0jtWNUYiX1olzJT3zBNU8MN8qGIwT9apD7u4hSYmTOX6vQl1eMlJV1vp9vvDkVd6//hGTeJ//4HOf4xs/fIe1lTWeG3leWV3l3rzi1Zee4Vt/+WNSBXcf3KfvS4ZljyIE+i7Qv3wGDQlSRBIkEpFIOSqI+1PcxJFSzFPYI7jgSJWS6kjan9Iv+zQpH2U09I55u4RZ9Eri0RipTprNdFEgygG68IEkiaLrfVNtj0Zq/6DkUQV1Sjz1b36G8NEt9t+5TQ9PT3p8/zvfI/R7HB1MmPcCf/SNPyUgXL9zg8O64igqr+1/l2MfeO/NHzKNkemswquj+GvP4771TntUTiIfg9P2p5Gb0RfVrEemsuafnwxllXwczqVVyr7g3p7i3tthfPMByUeOesLs9l0G9/cZH84ZiqDffJ8zW2do5sAImt3JyUYCyZ8Vt7yMvTbkvb3rnOPF0/l2NOb/5yxgGdNKkucBnXv1Ak4KJsWccHaF4uY+vqsSJM3zp9qt6W3UWZz7piq4ozlaFFR7RwQVyssj9Cii44bZpqO/V+Ak4n++z/ifjfEBhkWfWTUjLIZe5mWhn9yGnRvqU2rnGTlFouf4zlF7A3aLI2tSiuh6j6PDMZUmnPPE1CyqTND17XhUm5MxCQpIHjB67+8/zcG5QEMi/c0LqIuoS/l1kCE9GuKPpzz1n33EkNyUrzHRLwfcHR9x7spZNuIGrz14wL1zKzx3dgOtKt6cz6hq5Qf/6H9EfQ8X8zJTlLz0WLSN7vO7++0r3b4O7QywyJyahrA+QmcpV9pUSL0+xaxiqpIPyaat3CiolkT1JJcYpFx+6Wa5Ioo6QevYLn+xdHA1hIFjniI6PWnCV22XjPuB/Wt3aB4cMX04AWD9zIj9SeTFV17irdd/gAuBLzz/KW58f5+N5y6Tth+iE3jyuSe499qPePLKRa7v7iPVnL4vuPf2dVb3J8jZlbbPbam6KSDpZKL78gphd1YldJsvoFwruXxQE3cj5dYa5e17hFGf9TObFOubDJ9vkO0KT8m5smSSalzK4T/GGUnyGY4uOAiCOCX6RKjbBfOq5nx/41/5+9CYnxYWsIxp5QZ2z/quYxKn9JsGvTkjaV6dco/vsvtJ5+uhSFJ8CFQpwlxglvBe8Ks9/F4DQDzI3TW+7SXyLjezC7kXq+3saedcPVqhyM3NQv+lqww+vMHx5IhiMIKHR4h4YnudFVCs9KjWPXLomDcNfedQyQFMZfk56MkdeiHvkrt19CF7Q4+2y0NJIBLbfisFn1i5q5yf14QgeOdydawoODvqsT4qaeY1lUAvJka+4I0Hd5j8n1/n+b/5b/Pv/kd/l3/4m/8drgmPzFJKKYdA56XdCZfHUHTX1mhi61dfIQ0dSKCRCMMBvoKmaRjOKgYbK0hMrMwinoigbNYXwTnUB/pRqaZTRsMR1cEYUdj55tsUIZxE27aqGCsl1XOEsKgQCeR+uJi4ePkKfQounz9PaiLFyoAnt/dp5vClVz6NJKGaNPz6i58mTeH8ykV0RXBHkV975XmqVPPC6gYvn9lioEKQRP/FDVbFs3dj+9EzHmnPkuyWKhdDT3VxvbnalsNq6YX+uT4RBwkeHu7zUljlxctr8M42Ugju4gi9JDQpMZACGsENPC6sMnt4TLo3I4jHazfvP/fSeZFcwXzjDnzp/+U3nDE/5SxgGbOg4CKDd3cIUal0zryu8m405/Bt3w2i3crdo0Mw28dQwKVcCXE4fDtHCh/o32vwTiAUpJsJF9rBl92IAye4dsnOSdvbwlLP19IN1okwKYVChNXVM3A05aiXj9lhHFn5zBb9pFTbh7jjiCYhpgTtocfSXn9S8PKxZNUuPeWbqPdFvraT6QiI8/iUKyXqI6H0jFNNiEI/BQofSR7e2jngR3/2HpfOrqBHYy5+8TP41R7paM7LLzzNdHrM3uEEYkSlaEcftM9b2rlibX5wunyB+ScP/+w97t3epkp5ybIcDkkPDkmSB7DW7Q5Bj4eoqNasfek59t68Rgol9eExeNgsR1w9d5YH+7v0vGfkh5RtiFABT16RA98OPU3dK0FC2f/RNfyFM5xp2gOMGkWLhrMTUKeQfA7GcXlvZvsj1XYMWJGXOTUtMrWTxNHBPt55Ch/wbRULbQN/t3Ow7b5anLXY9b2XSvjcWWZ//pCYFL/RIx4cU8dEEmUuQmoiURNOIQ0DIXlCjDTzRH/QJ0mTA6O21SvvERVcBMSRBJwmlkaDGfMzzwKWMR1pN7x7R6AhlgGdJki6WCaSR6oE7d9bClrtTyEmaAdbel+SvOAF5qKIz3+x7AnJKS7kxnbni0dHQHSzpB6rXC1+LEr93Q+QVABThEhd16x/5hJHrz/Ah0D9cIdwkCg2ClxKpHafl9D1SeWckJyi1J+4ByzlUsniUpYP7FkcwCyCbyDGSCU5ROZlR8GR2NvbZ90lytkho2Gf0ueRErMwpOgPmKcGUpOXX9v/5QNzFCWC5OpZagsz3U5FRfAOjleEwcvnOPzBNml+jPzis7ibe8xu7RFf3KLRRHHjkOlaYuNwSHOmx3S9R/VwTLESCFurNLdmANT1HKQgxBofSgJds3/udxLaDRE43AjiNOIISErE27vUdU1KHqkiMZTM7h5SJ0GkoXEgycPigGQWryUsHePT/uOdp7fah7Uh/cOGIG5pC0I72oPH+q+WPod5E4Yn7XQ7HyPqIoXknaox9nBlJLml9zQJ1DXrL62z+9YRK0+tcPTRQ4L4boQZzp00uXcX2309Y0z2Lxg2Y8zPljxCoB0U6j0ljp4vCCEQfJ4EnnePyclf6HZQ0S3b5d6jWYrovMYhhFWPuEQxcPT6uV/LOyjKAice7/yiuT33+nS3qZTnX+mjE8s7onkpcfTZq3nLfExsfPYyuzf2iH6O9JR6N9JcLkmT2K44Sj7Spz3BUFJCtUFc7ufSbraStk9O2iVP1x4FtLj1d03e+R+h7fVq5zQ1qaGJSiOR5JQvv/Ap9o4b/vrLL7A6n9HrOfRgzJv/5HfYfvs9xBdIU0Nq8nl67TiBT5zr3s56yLWlvA/gOEZG5xLzIqJJmWzvcrB/QCMJmdb05qAR1toay+E336Xcq/JruNLnud/4RWahZvXCWdaunEVDXvrqAunyVagqyeUG++TyGIOkKR9kLRDKQFEKUjpWpUdQT/COYrNHb61gEDxDVzIMJaOix6joMShKBkVBEQKFDxQhj0MoywKd1bjDGX5RRe2OyDm5npPXZenz0f0ggr9WIZLw4inwKEq4AlpUOBEK5+mJpxDPwHl6RYFu1wQn6HZDT3qURUFRFISl74FPmglnjMmsgmXMgnalCgQYFgVH84bC+0f7zNtSTiIv66H5Juzb5axYzdGUKFw+Q7A+rAniASF4RxTFieIKofSedhQVDsWTqwQp5XPy8rW4rhtraf44RBRZGbL1d7/Cjf/4PVamPapbY870elRaMT2YoH0hFQWxmYE6Igop4tunQoqEYUkoAseTqu3/WtrqryAp5qZ7F9vnWgDtclJeZ8xLjJLyUl47IympUhM53jlk1Hc8fXmDb+1N8fE+g4eHJCm49B/+HVLf8cP336PwgmuHabYDAFhM21I9OVi5HZcQ6wYNngbYrAMf/vEOKxTgIHywg+KoHejtXTY+exm3usX45j4xNiRNrL/0KfzOAYf3d/jL/+L3WcdTx5qRCxxroiFSEhZVNW13djoXcTjqukai4JLkcRLdu5ObsnCi+F7A+YJSEqHyNDGhxdJQzqWsDhBEkNQG6kXF1CHe5eOJHuvBWuzgo3vdP+H3FdyVdTY/d57Za7chCMdHc1zqE4pjUuwOwm6/Jjm4D3sDpkWDVA2FC6Q++GZp1+BidHwuX4mzsGXMMgtYxizJ29rzsl2aJjTmIZop5AYgqR24NljUEXwez+DUnazmieD9STdKr0o0bV9V3oGY5zmRXD6qhtzb5J1re7sSTiD0B4Seg7kunYssj+xc60vB3dfeY7ZzhIQeKZQMty5y3CiXv/Aq9/70++y/fRfEc/lT57nUG1AfjKFuUEmUgyHHs4pmfJx7fEIeItndtPMhzFBuQ2/oONbIrJ4SQoH4REqOKA3J1YQ6IJpAQru7MFEn5ebuHrPxGI0JKUrStuJViXXuAUpN5FbpOR+VKHnu1dI78kiFEAAHsefh37mM/Nkdil99lZ3/8g8Yk5jQzYNKqCpeCoLC3rUdjo7GDHtDSlGcJuqtPmdf2GDy9TGjz1wmvn6DnY9uESEf99PtslwELDgZ7qmUF9apHxwyfPki+2/cxEXye0v++gj4IlC0PXfeOQKJ7mBrIR8x9Amfwhwm24qoOEGTnPResdgfmF8fXVqKWApgSyvYNPvHVH95j8nNfVJQfCiJ20pJn7lPXbv6yV/3jqZuA5tqrtxqfn5d/XKxMrlUSfvJJ0ka87PHApYxnyA4jzy3gvvgHnEWGT11icbNaPamhFVPfWPO6JeuMH39LjIaUK+C3JrR7TvrGtJFBJzPIS0lZA7eJwSP7s9xHuSxlXoRITnh9h++wYWvvMzhB7epbh/kXW9d8xHkbfMC7sf3cVfO4m4d0QwLbl57n34quPGHr0NVkzTR84H+w4eMiz6+yWfJlWWf47qiQQnetTsYlTx2QhZLhQqsfaPmmV//Krd+51u8e2bA8RNrTHqOXxkNuH0wYb+asrXhGXhHKS5X7CTxc4MV6ksX+J8nPZ4IMFrfoJaIVsok1lSzOcE7numNuDockL51Kx++vOhFyjf05c0EoopOG+L/9iGKZ/bb38WpsqVAoxwXcGZjncm04nhW45xjdlhR0EPaUQ21E+T2AdO9GfXRDLm5z1nfY/3f+DTlesG13/k26hMxxlwvc5wcVC0OCY5iVJIKIR0do30Px7pINd2RO1K0HWVe8OJzmZPlx/qktd/uYZb7+j65x4rHQs3j47Ck3XXZTBpmkwl+2MvHBUmueDkcxVJo7wKTiNAcR3qhlzdlQB5R0n4BefQi2rElxphlFrCMWVCiNDSbPYojSEcztAxIVZNu71GFBhpFqjyGYfr6NnFcM7pylvm795Ay5BuX5OW9bodX+9A4dfmYHenauAUkfws6OWlwRnILejObc/+bb3H2554hrAwZv3MX9W7xkC7lHqHR7UOeWz+Hbg3wvsdRKUAe1RDLkgtbA3qrA5rzIzZX+8zeuodME1VT4Zyj8B5PDkW+nUiu3RIVuVp3tTegeO0tXn1hkyc/vEv1/QcMxBFVecoH1DtiU7PvSgp1+ODxCjvTyKovuLRT8e/9yqf58//kf2C4PePXXv0MHzy8ye7BmMkvP8fKc58m/MUNdh7sU4gDya9Jku6m31bVtB2wCkTXy0uceHoJUE9RFgxWS8IUKAoOJw0linMeR0LnDakXGKyscPT+LZJCIY6VW1PEJW794Q+4eOEswRUIfhHITgJfG/5UuffWDTwBPW6gqnFFAal7fx3qFRekfS7kJdS2Q18199f5x4KTpu7jkvc9dqMzxLW9X22DP5rPPlTy0nGC9riabmeh5koc7bWLOxl/Ibr0scwjFh4PV93vOd+99u3vLS9BLjZc5L+YRzbYMqExHQtYxrREhSJ5wvYcRgN6oWDaNn57oAiB2SQfhIvWOC+kqMhKCU7RqBCWlmjk0R8vzyeSx369+/EjYxja5a69737Ima88hW6OkP3JyRKaCMMrW5Qbq/Tv78JGQV0IoYr4UUk6rnEqpGFg/avPsH9zh9BEZDRExke44Ag+N9kHhOD94sq6qlGugAjxrVs0KaGFg/URt2/eZ9j17qjiVXCuQJ3H+xzUnHOsOXgwTfyNOxPKH9/nM888wcWrBWWvYf245Exvk6YIyH/+uwTNR9uk9hzGRSv98jpUu2QoZ9dwa0L/qGGyfYhHGP3aF6j2j5EmMT+a4ao5bn+Cxlx56ZYfL186z7nNVe5MlIbIfDYnoJxbWcU58FVFvx9ouiW/xxq5c8BylNInkQgIYwe9lHeOsjSEVtpq3KIxffGvx3TZh/x33chBhFh1RS955Jy//LnJnw/t+r4W4aZdvusWEpeqnp/kkdFui3/LY7+2eORFVXMRetvHf2RGnDHGApYxy5w4UqM4Iu64xuFRzeMLJORp4F0FI5HHG7jdmkLzhG8XusZ0cjVBQKS93cpJX9PyXesnbW3vpjT44JjePqAYBGa7icKfBKzZrYdsx2PSe/egKHFn+kzu7LFydYPJnX1UldUvPc9Hv/c6vongE94HCu/bqfEe307oPtkdeLLE1VXhHII6RzizivrA5uoaaTzLBwiXnpgSQXJACuJw3uGcUPxX/zufPXeOw4NdyovnWd0e4+cC5zcpDyt6/QGzj7ZBA4QcnoKExW5KT65WpZSPMYL8msQYGcwDglC6wPOXrnL4YMqt773JcDCgVqV/dpVEQzEYsnb1AvV4zPTOLh++f53rMTGXRBGViyubpPk8j9Ro31dfCDHpI1mo3bwIQBwVlM9vwnyOjnoMDybwwYQ0q9u3JuWNEI+P3ZBHg4h2OybVtzOvcmUzDgMuOZhXdFFJ2sO/F5tYpZ115cB51w7/7D5a3RJvIgUoUnstywcW8mijfP5JIjZ5QGz3x7T9/C7im7bHN2k+kkhSypU++eTdrsb8rLKAZUxHhJCEioR4T5wlWC3hoMrLewlSExFV6iZSJHDJ0aiSYh7PID7hnUedoh5O1mke3fMlbedMV535pIjV/X5UoXRAVCS5fCxO21uDCH73GHWOJInVZ7eorx+hdUNagXLsCQGkikghBF8sqlZ527/gFoMrF1916SXJYVKAKFAWJfOqol8l8AXqEqnw0EQKF/LjArRDSV0VkbsPGDU184OH8P49tkPkyv6M+WSfWo4I9z2udO3uNU7GEbTTwiN5h6VbXCOkvTHHO4mUElETTQ92VhzF5TWCW8NrROpZPiNwcszk7n1G6+uUoxHHR0eoE8QHap+Yxjm94Li+t0chQj+UrK71T8ZBtMuE+Sid/P65OuImSjEc0UxqpArMqhpRxbV9Ud1ZhcJJKuo2UXSNVkoOLL2Xr+DWhnkUSPD44HJ4khw6VRxoPuDbxfwYKoLzjvLSGlqukTSiKRGS4lOiaRK7b1+nHKyQDiZtv1f3yesO9qYNgkCC0Ahh6ww4JT2c5FAm+fVXVdS5/KFWiLEmXVwhPGgAoRj1cLaT0JgFC1jGtHwDzdMDwsWz9FaHpBpWV4X5fo33BcOBY9gIvnD054li0INZpCmEwdURw1CgqWby5x/RG/WJxxGlRrWb2KSLQKW0FQg46Zt5LNx0cguNtPc1RZcav0UhlCW1Kto0rFxdY997Qq341QI3y8MqXbuzMc9ZyjO9vOTlnZPt9iz+u9w+thyyjh/uMXruMr3do3wAMe3NPvh8hmJbJemKJX4TmBTEUqiKhrIIDNZX8LVQUBBKR29lwHzvGO9laTirb3utHHjy8uvixVBSAj8aQKphXlMfz+CDPRhX7Eyvs7GywfF4TCOJtZUVpkdjfKP4eUMi5aOIlpbeVFO7A7AbjyHthFVZektk0VSuTaR5Z4e6STSaSCm2UxryINluR6lzLu/O08W73g6uzY8ngHvqLK+HfT78g++gDlTyGY+1pvz8RRBNJCEv07a7G127fBnUoa7hTFlwuRhwdmUdL4nRpVWe+Y0vUd+d5KVPl3uxcJKPSFpamk5JKRpHUs9h2Wf/7Ap+Z4fhwR6j+Tz3b6UaTQ0aEzqPSJ1ompqmLElVYvTLV/Bb/X/1b0RjfkpYwDKmVW86ZqOGm197M/dWaSICXFiluraLT0q6OKLaPs7zrQroz5VCPIXzFApXXrjM7HhMeH5Iuj5DmxwYlnXhpVtOycuJnNzIH9sK1k05ipoWN2ntGovbx/LOI5qQmI/fcXhc7XBOCWU+7zCIo3AhT+EmV660HWcg3dk/J18033+7A42hPfYHvAsMVoY04yndGIeu+KUo3rkcEpzgNgvS/pyiiayEHs3LT1C++wA+fYaVKrByeZO9H9/IuyHLAl94ikQ7NTwPRfVlwaxq2t4mcHjmJf83e2cWG0mWnefv3HsjcmVyZ5G1di093VW9jrpn03h6hIHQI8MvA0hvAuwXPfhFgA0YNgz7wYAeDBiwDdiAAcsGbAsGBHiRDWNao7GmG5KmZ+2Z7qm9l2qyimQVdzLJZC4RcRc/3MhkVbUgA3705E/wgUVmZkQkC/HznP98h8Zfu0j94S6iDXsbR/RerpI+6sCtHXb3DnDiUUFo1JrM1FvUqgm9XpeNnV1SJ5z6jdfZ+uFNTE/w3mMnFCHRNHpy8j6Ep9+f+L04iediZ9MLXjQhuFGQXBGxBrQaMFUlzDcIex30hIHNHsMWHgHqp+Y4uPkBO4MBMwstVL3C+qcPeP65Z1ldfYhHsJkjV55G3fDihQv89MOPuHR6ifZ+B9GayfkZ1lbWOVUztI/bNCpVGjXP+h+/x+Bhh8Sk5SYCjeAjWJZIgXcEcoS/aKW8MwOPTk3i+g2c9jTMgGsDz1/fznllZ4AqoNx3gA6xQKvLnNnut+9TO/vK//P/v7HG+v9NY4M11lilkkrKzs93SeoNiryHLhIMQmVumsOHx4BQmZ4iP8wpXlqk9oWLuH//LklSJfUBow0EQ6E0vbsHpKKRJOVx93RSqSp9lBKCH4aUYwPHq7ig94RuFL8/2lfIk15Mhbi6JA2Gg/fWSoOl0MagVSBI5GopKJldghrt+xtW14b78f6SsPIwnB/iTx3fW6d6eo6i24+TY4qRaxzykZSomCFa9hAEbxTyg/vUnz2NU2CWWjRWM/r3DzAdjxdBcovPLYVSeLEjcr61jiQ5WSPkCVSdkH/3DkV5DY9sH9docXhnk8HREbVGDdfLQAV2Nrcw1QpFYZFEoVDkONbe+lHkOyUNQgCPZ6rVQB0P8MHFKxI8wccqmvf+ZD0Mw4A3aC0oFSgKF49ZSuSnArufU3SPIDuOjeFcMEEPG8TxUylS4vTm2YtnOPv8ZZaXl7lYnWCrovmVL73I9sY+N+7e51S1RcvHFurZiRa97oDJSpPLz51heeU+ayYndPrUsi6vLDVIEAZYlEnKSiaAQlQk+RunedQ0/KtnGxzPzTFx8RwXlKIoMqwHL7Dc6/PPqxtcuNDgdx9knNno4AlYpVHhhHQvWv7yAP9YY/2SamywxhqrlAoaWxSo01XUseD2Y6al9+FDbAq5cQzWNzCAerTPxM0Kx4nBYjHPz2L64AYZIXgCBgukwccWoTrJVEU9UbIaBeBdM41tqF5RdpxCiSSItzF53PyMKjoBQwSg0vUoFatSqpkiR3kJqIw3fv3YpGIIHiYSdC9EcvxwIu1xlcZvOFHoQwDrESPgQhxxe6wSd5I7Enz5ATJiL7mPN6gmKUfvfFKaGhBRVI0iRJYB5vGVMKMJvMfT5vFaKK0JwaPQFF6xf2ePol+gQkr1179EZX0f9/OPyW3OwhsvsbWyzuGtVeq1Gq5wOAXKBbzyGA+qXdA+2MWIsDQ7yyC3o8D/yRnG92uIbhhdF++fmhqNVcb+R9uYSgVvPSjBODVa4C0h4CWMviZ4bnxwi9vX7zJVbfLuwxUGheMHP7xBTVKMhvX2LlIxGK24tf6IvnP08oKtdw8RZWg26mQ+Qw/i6wXvohnyloo2I7RDCNE83ZtN+ZfXppi7dJXZ6SYNnbDW76JMhSQbUEkqvHTtPD9tNLi3vs7fO2/5x7Uprq600TiehsL+leOKY431S6axwRprrKGCIDrFH+SETOGCxYpDnTuFX9/E5NBQMZBt2xmHP19BIVgfSJYmyJb3cXnA4vHBY0QTrIcEJGhGkW1fAkOlDE+HUAahFfrzF3CTgnvrQ0IYtgYdCaW5ebwSpmK7xkmCTgxCwAWPSIpSGhm4eCe1Pgacy3xTMAolcTlxrgzGF3gUzrtyeXCZHzq5LDFDFE6cVHCRwj5ECDxOUjgxGoKEuBQmCGgVQ9upisbEDY3S4yiDpz6feD5/0q48mcQUiopw+pufYyoboG1AefAhh7MtzKnXCKJIgQvPPoO/cA4xRFK7g5B7lFN4W6AsgEdrGOwfkgdLEBmtKCqvxug6qJJ1Nqxsaa2fQG4QAsEViI5MsODLfJb30VSJL4P85WokFK+/9DzHRxmfbqzzxutf5sbt2yxOTqOd5+cPV7BZ4Nc+/0X+6O3/zTe/+qv84t7HTNfreAM//uBDvvpbb7K8tsLW/7yBKIULRcz6DQns5XE5CezXNP/6tUUmJhdQFcVic55u3uU3zp3muFegU8ccipeW5jmjE26cmuYv7izze2aHf7ZjON21IwTEaPXP2F+NNdZIY4M11lilrA+c+9VXefjRR+RHO3GyygW8tUy0WhweHKALULUaKitwiYrtuIVJen9+j5qp4JsTZXanzElNxa1/vucRD6GRMvGNq2TLO0izzvHP7qGThIoo7HwNVU3o33pIMjRdKEDhlYtraJQqzYWCRpOJ3/4G9cvn6N1eo2oMldyTDSKdfXKmht/eJ5lp0vzyq3ibYxpVggfbGaAShU4Nebcfg8sCndufYm+ukpgEH/xnjE4oTV4IIYbc9QkMc6jHKfYhhNHC6lBWtkQpTJKgS1J8iQY7qX4NX/OpIt/ouePRxK8lkOSB4ruriHV0+32ccxiTcNg5plmvkzuHyzImzy6w93CHWq2CtQUSommdXpzjYGMrTj5qjRji8uOkOir3DCuJwZc5M61xzsWcWNk2fBK/EMPw+soC9ekWtsjwSmMSQ3d1E7uyH9u2yhC8gA5YW9DoZPyvT2+SSsJ/fftPQeCjnfVoYgIYlfDvvvsWQYQ/fPsdAgqNQ4hojP/wb/8LeRAWqykviMa6k6D+8FIqJSQOvvfKWUxImJuawddq1EzO+YUzzFYUfX3Ax3tHuNk56nvH3Hz4gPVWlRcuLHCjsPyni5a/e32bRJsRLHXsrcYa60mNDdZYYw3VL9h+/xadvb24725YYSo8Ugi1mUnccU5hHTJZpRVSMjfA5C7yswpLUeSIpwyfO/xRySgqMzkUgf57yySnZnE+MPOVa3RWtylyi/n8edRmG3m4h8IwbEUphPSZKQbvr8bqkQjKQe9rF7n9P77DxsYmlVqdnd0DHAqCxzrLdKPJbreHcgFFoFYzHHYHKGVwLiBBKJRDo/AiTE7U+Jt/6zdZ+cld0sRQTypxGXXwiMRdiiICFUN+0Dkhg5c6yYWFkbkamY8y5jVs92mlIqMJD35Y3QvISWHqsxWRYQbLx7yYCsTJxSBogYrR+ETjp6rxfH1KmhrECgNnSRoJlUaKahmM9cgRWDyVSgWdGmqLE2T7fRSQqARTMr3iMYfR8RitKUpzNTzfk0Mcmo2ADYGZVy7S325TWZrCf7KPTDcZHB5hBzlKKypG8NZyfnGKIsvxxz1qOtLwnYp5sZoWvri0gFeaCalQn2rwnZu3eePsZW5urPH8s5eoSuA7H9zk659/hdWVNV594SL1uQaDnTbDy+glVks9wnGzyvdn63z9zDn+9je+yO/fWadZq5D6jB9vZYjRLM7OsjsYcPPRIw5u3ubN+UUuv/0hly8t8r3FWVbDGudyT9VUIkZjjGgYa6wnpP7vPzLWWL8cCgGUh14zsL2kaGtLL4V8c49ev0dxkBGCkDQr+IMuEKgFhd86wgHp2Ra15ydHo/yUYedY9Ik5KAqP3+rRv/MIf/MRsjsgvX+In27g72xSZB7SFNtQyHQVQsCqgvY7y/i2OwFRSkClgd2NNpu7h2y29znVqJHWDL4aqDebLL56luPBMV//5hfpK8+Lr32OerPCc89d4NRii6VrpzhzZYaBgjfevEohjqwYkDtLvyg4zgf0bVEW5B4zEc4ThnDJxychT34itv+CL9uJjlBPo4kqkRRCNI5m0qASGC5HLruiJ3sQnzJxw8fqIHhvwTusOLT3iPGkSUol9yReSI0mqSQoJRgRssNDEvEoK0g3IBpMrYSaBkV6DBJCnAg1Bl3m1uSxCo1SKp77Y8fz9PENpwN1EAY3N6lv5uiP2pi0TjjuY3OLLac3Y5s0Z3djh4+X15i+cAYVhCy42FLEkjn44eYjfvLwEd/bWOFPbt0mC54/e/gpm0Wfd5c/4U/u3MUpxdF+mwdHh+ys73G0sktelG288gQCkDjF+mKT3e6A7U7GP3n3Ll2nmK3W+bTreXlpir/zymW29/bZ6PS4fO4M9flTNGs1phz8+oM9Kqrg5plJDvs9Bi7HEvDBM9r1M9ZYY40rWGONNZRYjxdPUUB3r8Mgc7z5D3+b1X/xHUg11STFJoI7OsZ5Bx5sKG+2PjDY6jIYeGqVlFpaxVQ0umpwuSPksVVT+9IVjtptGotz6KrBZgUuOYU5P4sLgjEBf75Bo9WkmKoS/vN7+IMsGpKSEzXMEjsJrG7vcVzTzNdS7rT3mJ5ocm5ungebu+ze38Nq4f69VZwIn95b47DIWN/a4aA7oNUf0EfRF8vWhxv0nUU7FdtgCpz35M6RiCI16qQy5UsUQ7SPJwak5HKlMwn5XgbD6cQgJEcFVkKEkFLmkUQIh5HpJOEkXv9UpH2kJ/NNoM+2YJAhA4eohHQG3GqGCQk+QLNaB6URLSRKkagE6wtU3xKqVZLcxWteQleHuAqjTuj2qgxxx4xZPGbnfblc8K8emlOi+OTGXZy3WOdLTAboPGDksWnEENBiSJWhbgw6wMLSJFkR2NvrcXlxmguNFne3NlloTaHTwO72ERcXTnN9bYWrM/MUWcGNrS2Mj3iRNDWxnezdiIov5fkFsXy80EAnKV/9yqtcp47e22atvY9tzfBRp+Dcww2+9ewFfrp3yKPDNtpaimcW+W/n6rzS0chOm/V6ShYcx/0ept5ApYaQjv9mH2usocYGa6yxSnkf0NqgckdFNME51t/6Eby6hL6xSUf6JBiaMxP0fI53FqyPN68yr9Vt96koA0GRWIXq52hl0FrjBYIOpKmw9sknzLzxGtndFVovXsbMthisbnC0uQ9rmyRrfe5dneC5M1PkextopRiuOYm5ckE0OAJ7dsAZW+OZxdPc2dxgd3CIkSrN9i65VriDfYJ2FL0MSVKqDUWeWeq1CkqlPOq0WTp9gT2/hpMhQsLHbJD32BAwxHYcEs/VMxowHCEHVDkz2D+MS6RjyDuAEqwuJ/ZGxZThWpUIOw1Bla1BT4n7/Mz7M2y/qQBowWSa/kGODgqHg46g0SARPCFKE4wmEY01CmUiXwviSh8xoBGMUWgtmDQhsQVGytZgmTUbLeEuU3G+DPbrIDgi7mCYLxtqVKWzgaIBrpujswQRFUGmEtuuIhH6abQiFJZ7W2uk3uAt2Dxe88NuhwOlcK6g2+sTCkW3n7F3tI/g2B9k2DwneM8gyyjEE7SKuwpDGAXph/sQlYfjxBOUYiupsTg5x/bhHo3UUJuscPv6Xf7Nbpt6kjBRrbN89yNePDfP5n6Xjecusoah8+g+XeIvgsXTz3JSZZBinMQaa6yhxn9ujDVWKZG4V007T80qnrl4loUvXMHnjvTyGSpzk+TdjGRpngQTe4paEWpVEpWgBRKTIkqXeKO4kiZmU8pKhRdkosHSs5c4vLVCaGd0ry+jjcFUDdWGUCymuKpCOn16wY6m+4YacYeCRzswCKFeoyeeK1NzfOXsNUyScHnxAhJg4pkL1H3CrGkiopnLUqaspqIqDDpdbPAMttu0948IwT1xTYZh9hG/q5yaK5kT0SQFQbmA85rafB0tJgbgh9CuQFwY7cvWqYrMJAkeFQIqaHywKEKk1T/VGvxMG678t/zgOOIpJFaalIqB82FIfkivV4lGaU1SraNSTWI0yoW4N1Ebiv6ARGmC81R1iipJ96OwvQx/P4YeN2aybOJQVQgymqE7MYFlxau1NM1MfY6ZuTPMLk1Rma5iVMCoBG3i70YIDkcMu08tTDA/3WB6cprPXTqFKEUSDM5rDgcF9aqiYRRZsMy0qhQhUG8mVFsVlBFmr55iECziIyR3OEAwLLUJ4LVi7miAKwoe7hxw7/Z1OgjPzE/y8c/eZ6efMzU9ASbh/sNVatWE1AovXrnE/NQU1gmNxhRV0aMKn/OewjrC2F+NNdZI4wrWWGOViogCzcTLS9RE6N7ZYvWtm/SO+xz1ciZaNYzRbP7sDhOXTpN9ukU6WWX+b1xj9Q/e5+LvfJnw/U/pP+xSISmrPcLwgxC3r9hBRuLhrDVI+xizPSD7/T+lrqAw0H21Cf4Q7zzeWmzw6ODjjTyUN3lPJIkHhQqaTreHSYQjm9PeyTnIevxia5WQen528wZdEYrBAQch5+bRgCMch+0d+vYkT1TgI68rhFH1Y3S/LHNFMR8V2VvDB54YIMthG1TuYk6LECtLASgsQqxgSR7hlISAUprCZUx+7UXy99ex2HLHYnw9eaoHJ3ICWw0hBv7jc8EQKf/EI0KIuxfTFLvfIzEmLq4un0sHRfABozQJCowamavh6w2T9sOhxjhRKCSnWxSDHmEjh1Qj7oSs70SgJjz/e99i69Y9EqXodtqksxW2/+lPMDoG/UXHiT6nLOlsha3NA6y1TPX7VLMOQqAqmgkHRkErqWKM4b7yTE7WMVpRw0Ao0AIP9nbJpMyvPX7thu9RgKDhyu4AN1Xl0cNVXC/w4uvP887yHrWK5uWJKhuDgnMtzbWZK6w+2MCJ5g9/cp08wEQ1sL3b50oRyrZpNLm5L2IOa6yxxgLGBmussUYSMXgFR7c3QSsmTs2hWor22g6p0RS9nGa1gUqFg3vrzE5PURz02P/vt0lEEd57hN/tl82ysvKjYupouP0meE8y3aA52cTff0CBkClB+YheMK0qMz/apyg8JqQQwAaHExMBp0g51afQIU7Q+eBYqDYItRTdPeJcfQ6rHS/U5zjI1vi1uUt8e2eFq/VpbnQOuDp/jl9srfDK9GlW9ndYth1UNWEyqUZuU2li1LDyMfRPwRFQsT9YDgQEHb2QI3D4D77F+/0eWhkym0cSuAvgBVviHSSA9iGu9PEBkciQCoMubxqD/tEyXmJua2hoVBl6pyLoNI0tWe+w2iN5eTAD+UylC8AX0bBJkpRLkxmZMAnD7Fi8noKMJuHkMXM3NHDCKLcf+VjrxygRLCcYh+FRSwjoTLHy9/+IvGtxtoirewRSlUaDJbGdKblHa6Fr4fryBoVAVhQs1ZroIKx1jljvHeO98IP1NYYjln/8wYeg4ccP7hOwaJ1w85NVSDTeWvC+5JdRnns0XQJc2u5z5bl57t1b5gsv/wqrO8e8eWGB//j2x3x1YYrPTTSRbo/iqM9Cs8F0vcagl7Fx2OFKs8Gm9jy3doCOS5fwZWD/6cnSscb6ZdbYYI01VinxltaZBc6db8V1MgGkqdHPBipJgvICGrQ2XLz8Mu31LRpnAvnBgOa8Yu6182ytbCPKjJhOQx6SlMiHEDwWwfdynHc4Z9GubImJo69y1GKKutfHOhdzWz7mw4IKTxgEvCdIwKGwIS4gLlxB5/iQgKbd7+LwHGpLtZpwkHVAeYKJFaajmRR7bKDnceLpuQGMQJqlXQgBGzxhdgKVCLm16Cwf4SLKEUlUo8q3u8fkf/4BeaXOO1N18A6Gi65dNEIiPBa2DmgRzgdhaqpO/XCfa4MBrWryxP7GodFKXjiHqwvJ/S3EGmTC0nmQo8Sgg/pM4lwkvofDAPtJHWpotGJMP/KoVKzKlZUwHzxaVBnGV6NH6nIilABaFK4k2SdesKFMpgkj05H2AvXTU7jUcfTJHkYbTFpW4UQQUZHybgMuK/jdr73OD9YfcVTA5WaTewdHNBoV+oVn4CzPTDSYSjRdJyzOTPHh7iaHWUbwBu2FXClSD/eP2lydnESj4vs3nMpUsfpmnPA7Hx7wj863+GhlhWvPXeYPbq0wIwWzEw0e7XboFBm7eUGz2UAHeNTt8eriPO98/8e8ejygtneISDIy5Cd5vLHGGgvg/wAAAP//7L1ZjGRZft73+59z7r2xZGZkZmVlVdbeVb1UT8/Ss/TMkENxuIxIWSsJCSBkeJNt+EkPhg34wX6wYb/4UYBsGLYEWbI4BAyLpsBlyFnI4Wycpbfp6a7eas/KfY3I2O52zvHDuTciq7qHgvyoiQ/o7syqzLjnLtHni///+3/fjGDNMEMFbx1x6lhMQiBylmeY44JWcy7oh8SBOMgt9t0tFn0IPtaLHaxY+j+4h6tG/j+obgw0wXlhfHDEyvWnOKk2+Hrs3+HRuynZqhATsvGcm4q+pxUaHX7aQWe5g+/vkdqcwbCLJoamon/Up5xfplBBI3SUjnm6vUIpwvFwTKkjjrb2GZclLknYONonywuU/WCLRwHZ7hFOwhSjNUIYFnMIqvKj0gyAb59fAlsSGQWucjb3niQ2U5NSq2hGltgnNBsKm+aMxJM5oTtKsWXKQmueSElVWQqTitkr6+AsOQrEokRjVFKVlR7XQNX4wPdBko71QaSuEMrMoYgqx/ZwPvbaGWQupnFSkj86rHhk/dsFggkVsDIQLZoGRjmu8ssSgjjeCfi2oXWxxeD2fvDtUo+TR1+UnFdz/Fd//dfo3r/L4dExxxY+uthBe2Flfo6tgy4Oy1yUEOuSe4MxG1speM+V5WVKD/3eCauRYpQr4rah2dQTF/f6WFWnGo3ihZ0h//l8g39W3OPOsMe11UXmmw0OtGZbGYg9SRwxdo4f7x+S3T/gey+/x0Jxwt9az1DKoKTKqfwpk58zzPCzjBnBmmGGCl7A7h4zysY05xc4PNxhvjGPS3NGLY06GhLNR5S5RasYpx02K8PkodEo5REilA4bd3jRamIOwnRbpLBJk4P1XRIbWiqT6orWmKUGZZpVVZAwDWdPKdwn/ks4NMK1Mwv8ZLDHnAjKNEhHGVHLMIdwLprDZFvo7pAlY2jgSHzB5WaTgyPH6oVzFOsbqHHJ/FKbSyaGWlAvp47nPC5RWA9JGchD4bMQUq1C/0kBQxuy+9qNiGSuw9g5OiZGjALrGeV5IErVhF0pjpM8Z6gjirzk0wBiKbxmmKXMJTGJOtV4k3CNNCASBQ1Xpf+pXeen9a7HMYmuwaPPL9L81DV0pBEnWOuIS5lMMOLBNmNUadGlo/X8+RA9pMKkX/zRK+THx7jDQfCVahu8Lzl+c5PhOzuYys7BEdqQ5d1DTm6HzMSQsVg/F5Vey0HkGxzc3YaRo9No0J5v8dBbjBhWLp2jO8oYHTtWO/P0+0OcT2kBkYAxinbTcGn+Ik8vNXn53YdcL/qIUSgJxF3VFbPqoK76/jfu77NwfRn3Gc1rL7/OD5cusDIq8VjIHeN0zGCvS7Lf5e/9/Ivob29xZSdD+gOEahig+nhANcE5wwwzBMwI1gwzVBCCRkYDzcgQRRHOFUiikPEAnUSI0ZjSQ0PRmo8Y7RSYSKF1NYUoghZVkYDphh80P0Cc4E8GrL74PPv7r2PiuMrrU5QEp+2odEinSWls6EY9UQ0T71EeCmd5+92HxC3PwTilUJZRaSl6xxyWJbeGx3S14bbtc2Atd9I+Pef5wd5D9nSObGzgC0+phIePdii1AetO5f0RpgaVp73cRs63GL+2BQKtG6tktw+qwObQqsyLAu88J4dD2nOrWBRdr9FF0Jd5ifCAxeE85FZwXmGcAy2MvcdBIJ2EXMU6569uQ4UlVW0+VQUmexvaeLXO65RsbBrvM73Lgy9d509/588prcU0I5LYsHHSpZVEjEvHYrvBwWAUBgsKT+rB4CmUwliL+sOYpnWsJAlx6WlhiHzBRz75PCejIZ2kQSQhukYk2E+YOKKwJROGI0HD5sRTpilrv/oc/d1D3HjMF1Y/xqONPU5GGT//hRew1vLZF5+lmWjUoGBl7QwrRYHBc36hw/r6NgmCLRzHO0MWWktsaM/nzjbov1tXsCo92YShOzQKpMGvXVhi8+sbvNc2zN19SH99D1+AyzIWen2u55aPXrvMR9+8j340Iu+PQCK0TNu+SukPVAtnmOFnHTOCNcMMNXyI+4iMxjpLE0WsDcQaX5aI8sTzDdJijM1ypNFGjEYrMKqKe5loa+rNZiqU9uKxm4dc+fXPM+yeEN24SudzNylvbwSLABOy6rLhiLzX42aRMjjcDTJiL5UuyYMovAiFCNtRicNxodGgvbZM3i1ZXe7w1uY6X+ys0Rv0+NvnnuF3tm/zK4tn+FF6xC8vXeOPtt7jhYuX2D4+4dH+iF6acenMQihIOY+o6TieiGK0fYw96aO9w5TC+PZBiF1xZSXqF3Ln0TrCI3yy1eBsYjgaO0QrnIPCpmTeYSXBFQUqMuz3C/ayHK0iCiyqbiPW16y+Nae0PUqFa9x46Sl2N+6xULYpsxE6V8jIE6y3agH7KXJVnY/1BZ3RmM9/4jp/cm+b5893OOoN+E8+/lH+8Ve/xafWPsHd/j4r58/iF2Lef3+D37h0jX/01st88uoK67sp1lu+8MULfPX33ufiF66w+90d+re3yG1JLx0xFyU0VIxSoUU6NUml8sgSnASPKrvTJb21gVvfY3w4oL8WM7ddsriQ4BuhcuhKhzaGPM2ITMxcUSCNCDnuclW3UYmmcXUOUcLN2BBrIC85LhxGoskzOLkO3uPwYEvGr26wcHmO//hRl/TcMgdRzkBpkmaHxcuXWCoisncfkW1vUCob7DCk0q+dsrOofbZmmGGGgBnBmmGGGgpECUbr4AdVbdRxp8l4OESbCBmUJMbgMci4pBkn000GHiNYusrhE6YTcendbexb75MVQ8Z/cZeRdfitXcbrPbSHfDFm8eMXGWPRRmG3RyjFpOUolReVIJCXtOKYsSvoGeGNd99nXBaYBxZMk4fbW+wbx+8+fI0ta/n64IB9hMFhlwMDr9+5g/ce7eHEw/3u8URcriZibcE7WPyPPk8xb3CLcwx3u5y78RQ7/+1v07Z1ZUmCrYT3XGi0+DtXz3N/54D5xXkG+YhBWXB9bhlbpNwej5kzhmfOdPi/dvfRkmBPeUA4ThES6taWn7inB/uBgr1vvUUimpwCEY8zJji3w8R1/jFUL3G01eWNdMT3v/8mVsGbe9ugI/77P/4TjJnjX79zK1zp7l6I4olifvv9HqUSdrOUbjki8hEv/3CXLDEM+gpUgdGKcUWmCueIrQ8TkdU5KKWqZrGfEkbvERRHO/u0c0tcOlxhsaOMrCxRccKgN6Ax12DsSso0RceGMrU0TYSfN9heilOe5EGTssgoSk8SGRBPU0fBpqIyX51iUg4kHubYW8ckn7zMXMtztlxi5ArmWvMMtg+w+ynDoyPUWgvZ6wfyWvmMTcKua7f4WRVrhhkmmBGsGWao4T2iQGsddDkmtAnzbkosMUYZvHdTEqJUpVeqBdbhZfTk+6kOq/5aO+Dth8wvtcgW2sijR+SupBiPaP2dm4x/7032721yFI1ZvrBKtn5IJ2nxeI6uw3tI2hH/zX/xn/I//m//C8N0yM25DsvzC7QbDe7t7rPcucidrS1+7fLz/Pb9n/DS0mXetX2ulXPcLvqsLXbYGPUhHYNTxFqhvJ1UIZTUVMCTHg3pW4OcpKTWs/1wA2sdGQ4jQUtWekdhLSWWnzzYo8z7bDcU/9nHzvLVe322D/Z47uwSUamZL8E5TVlafAziXKioSJjqEx9aoeG2BGakLp0hSktEK2gpnC/J14/IFiMaW2M4Zfh5ql4zaRMGewVFjCJBU4jlV567yZoo/mJvl7+59gv881vf5u9d/Sxv93fQWnNmbp43dx/yNy5+kn/y/rf4ufYaB2XJdnHM5586zx8e3uZgY4PIMfGd8pVNh6uEVkoEW5QkUYzzwe1+QpIBBBaOM0yrycikNJoNxrpAjCZuJGRFjkJIogjJS1rXV8juHaC9IzuXoLOUqBTWrqyxce8hUaRoJjG2LIm1qWJ/9ITwP/HQI9VQRvHKIwaZpTc+oREn9BZi3P6Q+Mo8bpASNROUiR7zCJNT74Vw9WcEa4YZaswI1gwznIYHUQolPgT+GoMvCogMOtI4W20uaho/MtG1VB08daoKVE9uUf2so4rWiQ28sMagu09rANlCwsKNVezqHCe2YFkWOHNplf17h4FcKJlUwirlOcOTMf/od/8FSuBknHEwHpEfdFmKNEd5yYVhStfCUrJAbjVJrhlknujaCktHljv9I7zzPNVa5FHeR6kwFygVaZQwggZ4Bn90ixObon/+KcabXXyaYooSorhakOCcxeNI8xwpRgxKxUJjji+/s8cgE5J4nrd7I4a5pSwKnM2wpUW0xZmKjEw7k3iCGFtXAnUpLLkrkcLhTizx1UWGWcGo8CSBtlSeVlPz0UlLTqZCeeccufcoPD+6/x5KKfo25X/v7ZNqy798+ENSCaHI0Y5lHGv+6Z3vkiL8/u5DdO5ZUZ5372+QuZymWcZFQ7yeEur6NtVO6kpU0JOJICrkOdakD+/RCKU4IhHKsSNRGhGNMgZdWppJTO4dTgR/r4tBIxo6uxljF4TzrjdGe0GUQSkNylXVKxUmHX14bqdLrEinF7R3FOcWoBiyduZZTl67RzLfJDvMiOYbJGZIY1yCiT7wlqld82f0aoYZHseMYM0wwynUwnTlwWtN7YCtTYgF8aG0Ugl76xbg6Reo/yOT35WqpeIrI0anoSwy/Hc20C0hbzZwx316f3oHJxGtRUV6t8vczYTDKLR3akd4YLIxX2ovsbTSQu87FIqRH5OoiLlGjPWW1mKLo+ND/uXtV1loJbzBEIk07+9u4vOCKIp46sIqW/fXmTcRS50FyPNJNQJVNSaVoJQm6cwTr7ZwymM3ciIXKni6ytfzOJwryRqGN9KMnTzDPbyHigRscLFPjCatqlxvjx1RI8EoYehyPGUgpd5P7AQmZEUUdusYb10w+VxZYOgEdeMc860In4zxu/3q+oe2m68qSKeF7kqENC9pGcOv/uLn2L27hxoV7LoRn127wZff+h5//5mX+JNH7/CR1lnaAt/P9/kbyzf5Z5uv8cxzN9l+tMnRfpf3FhI0iovzLXpZWS+0Or5MzyHcNCBEyhhjECMhcogpATSRIhUQq9AGtDFYE86kJmrB/V2hcYgDX1TB0d6jXGUZQU3uVGWYWk2yVo9kHf8zaV1X+ZP6aIyyBXl2RIxG4VFa8EcpEpvwwUPrx0xYT79vZu3BGWZ4HDOCNcMMp3BaFH1avAuBUNVRILXu6jGtjztlYonHRSGDrzZtsGVw1rabfeyWg/EI4xtI7CHNSb9/l6jTwowgGlnK4ZhoPkbSqehb1VovYxj9+fv8B5/+BOW5dvDKKsNmqhC8DfYO4hyldeAE5cKm6sYZvrD4osRSIteugQdXltz72ptoZaZj/fV1UEJjoYN0LrDULOk+3A1VtaC5R3lw4nACA18yNxdx3hnuDU94YX4FMZqHvQE3lhLe2Omy0mrQzVLOz7fYG+e41E3SXORUe88ztbEQJYhovCj0xQXM82cZP9jGdFqU+z28sxilq8HNKSkhfDtt53pYaLf4zis/pp85Yuc5kZztQY9UPF99eIttO2IkBbH1HEnJN45v47Rn+8EW43FKI4rptOdJox5vbO8wPzRcWpqwmQmheuLpClqxMkdEV2sSqNqjYj1ihGhUYiNNo9UkU6H6pKoqEUoTRxG2LBFdvabWmEijlSGqpvlipbG2juEO11R8FdJdP9PTUcuJzq1Jgk+hbMXEqaFsxhhnaM4pdFZPHn6QYE1eY1bDmmGGCWYEa4YZKkwm1mp38lOSFakqAFqrCamaaFF83f7zEGuwFkqHOTtHudkPDISpjUPY8BSmCoJ2wxRTBQ/HizFee/xRFITvJfiJ4aYwcYUXQbo5vR+s415skb8/oNgdklkfXN998Mqyvo5H8eAtrTgh9SVZmbEYN/HKMMrzML2nQCsJ5qlKMEpNWz8SPKCa1mPHGcmxrcb/62sl4EMVJ3fwxw/WgfD7W0dDlBe8d7y3FzRID04cOMddJwgWtKEQG6ok4SZMyQqnqoQCkfcUbz9Cv73OzjMR0bsntB+mlM0GiTLEJkLrKqKoqib5qopjvcdZy7jwbJcjxCkKPJ87e461pRW+8taP+cK56/zZ4T2uJC0WkjbfO3zElcUOd7Ie2wf7eBEaXlDv3aaN4eznL+Pf2Am+YBMmN32g5PQgY/W1q6mPs5SJkCwpho8GJFES1qtAxxoFE3KlrUeUwlk7EZh7H9qKwdDVEUcReNBeSJIkPKMV8ddaI85ia+sL6mcxrFUIGZPOhQpgORgTi0JSi/bh2I996KjvUXWysyrWDDM8jhnBmmGGU/BSF0CmBgG1ZkaoNsjJ5uYn7ZZQYam9mCyIwh0Ow1TbKcsAL1V8S1PTVglF7hALsdFEWuOOUqwtgjlnL4VSV0Qv7IByinAoCcTP/riPyR0khgaK3FkK53A+xLVIVdHxXkiSGF+CdQWNOMER2p5n2m2Oh328KIwIRqp2UFUG0qKwez2Gv/MtxEMDUJGpSGPlgO78xHpAK3A1/6q0PihBfIikCakyglMWCHmKlgyFC9dMgTiP16cKLdV/rYKiETP8rc+zOhjg1o4pNl7DOUfpLYiQiAQfqvoueo/3DhNHlC6QO+fUxCz18GSMUkNKBffGXUZ5wXFUMBoNqmM6nAskVHywgshEE+E5fmOT5olDLyvEy+SZACbar5CfKFip2s91yw5Bck95AI0oDu3PukWqAjHWElrUBg9GTWJvwiUNJMwLGK0Bj3UW5cLvKlUFhFfnr6u2rz9Fjia+YpVNiRYVWoNuOu3oq0DD0wQqtIWnJrqnCo8zzDADM4I1wwyPoy5CnP5wDsApHU+tXfHhU7yftEzC5omPsFhCyIyfiN/rNozFsdRok6YlubUoHYdNTSnECUoS0IGMGSFsbJNlTJRY1VScoLxB6wJKjY4E5YTIWkrvsc5RGx54HIkx5EVOY65Ju9ViNMhwhcWIBusxRhEpCb5eVcWtPoVYaVAa5aanVldCvFjmbIx2lgKPv7uFsSHkuErVmWiAvFJ4o3Da4yVoiswwJR4UKBWhsJWGKhzjdBu2znTUFhoPjhm+8xAnJUZFodKjfnoVJeT+WYyHK50WTad45spVXr39kL18SKsvuNIiTZC+JrUlBkffOr65dReFwaIQ8agoJpmLsb0x0dkVbBGihEQTKkZVgWqydg9ePNFak3J3FNzxK0KiAOvqsOj6OakilKphChVrVGlBBRLFKeIjvm6reqTSYT05LzjRoekw0ajlg//rr3/GExzyvXL4OnRb+FACddoAFoSfculnmOFnEjOCNcMMNab71qQF4kWBs9MNq55Qc4C3eFTVggtVizyy6NyACEbH5JJXBEUmcS5GNIOTEWXpEGMwSuFPt1+q4zgCGdHuyUVOlPRV09AH7ZEKrR2tq7H5SttTTsTUweOrEUWMs4xM5dXEZHAV1whaSVW5UkE8XR0nkIVAAvUpnY1WgvdC2h/yX/7hLf7xfMkbiw1sf0gjNoy9YJXCRmC8kGmQ0kMjQitVpSoKN/t9vrinkKqCIhJ8m6Rux9b3hFC5i3KL+8abtMqCwllcZNCEypepqoZBdzStJgXbeYV4RVnAvf4J29n79LIhz7dW+NjZi7x3fMBF2mzrE1pRg+UooTnoc/PMJZZXztPd32DxbIfxTpfO6jJ3+xvMNQym3ZgQ7UlVp35kqmfD4YkXWgy7J5ixQVXk3Pva1CHE/9Tn6SrhuihFNGcoh+F+QahG1c+p8iGiqVA2PEt15apqjTof0glEyWRlvvrD05pDV31AcIBy4c3gqGwcpm+MqmJbVXRP927lQxjYDDP8DGNGsGaYoUK9WYRP8S60uryjdABCVFWgapGvXF3GN8C9e4yKo9D6a0XBrqBQIT7E+4kGa9JGEaH0TH4ntGbU5NhTnQtoP51WrF7kyVUTOpMeEwXdkSg1iZjx3qMlCMiddxitMFoRoTBesAracYIiBDZrBE0gV1rUY60u5cNrB72Vn+i4lQpEoTNW/MNS+FcnPcohJL4gsQU3+o6GjkI8jnMoHMZolFdVXQ1aIiQCBoeocHwlgRQEf7K6hCJVKLNgjKBUhC4VTlVtSgm2DuGSV0TFOerImsnEnI4oCktRjkDg/ZM9to53sUnM72+8jUdhRj0eCmgn3N7dwh9uoxXEh/tgFK53SMcqNu9vEKeKmwvnwnWpb42vOYeftJXHdw7JrCV2evJ3IoJEEX4cIoPEV0av1gZTDwv9jRO0CkHUoQUZkgO8t4HgO0dzaYFxb4BG47VCOQtKsCoMPdRV1nqyMFyXuhrrJ75nurChGkeIwPEqtG2dDmaySgmuYYgGOc6pykJkhhlmeBIzgjXDDBVqbYv3gngD1+bxn74E1iI6Ai0op9FKVxUnhYgj+gQ4bdCRwvvwSV77UDlolkEYr7zn4Ouv4g4GVHryUAWo2m/a6Koy5ioe5kAFg8ipi/sT633i+9Nar+AaThjfJ+hpnAhGR2hVEKswdi/WIs4zzlPiJMJXrSpVVSoeM5Ws/LgCzREmnIegl7LKMV8q/kHe5HjoaccxqSnpyjAI7OfnGPUGKK0nlRQtCsGhtcEjmEpcX1s/qFNrOH3W9Rq0qtpyEiwjhEqMjZ/ov7wKxEp3LG4QKjWvHKwTieUXPvoCOzt7JEmbX778HP/021/hH3z2l/jR5n3aURPGOQ+Od/n1z3yJ33vjW3zpqU8wykrWswOuPn2ZH33nhzz91CXS3e6kgKO8TLVL9b2p1htFMVFUYofBWsNYjVUFxXIb1S0qnVbI+PMNg04SpMjAgxUQo0P7VELF0aPxWLwXhkd9/HIDUyoigeblNfL+iOy4S9531f1TGBNVRElNYnsE4Nwy8a+9SL7aQSKNKCFeSEg6LfAWrRStRpPNe4948M6bXP3TB3BYTNq/M5o1wwyPY0awZpjhSXjIbY56YYW3/8nXkJHCmQLvIVMerA1ETBG8okooKVASB01VZQqq41CFEB8Rd9p89rd+kfRfv442qqpKyaRsJiIo5/HagHcor/HWI07h9KlJrw8WsCa/X6+97tYoCEowkVDR8CHHT3vIBYwoRAcCCJ6k2nD/rVCvp67uAWlZYrBYStrLTYb9FCMan+Yszs+R5wXW13Uoj6BBCbFSaFQ1yagmkSyPtUXrryQQmdqmoCZcThzi3CRWR7yg0ThThjYlBrEO7xXi4N7dt7hzkBE1DO/duY1PIv6PH36dgogYjyKm1I5//sM/xhnD7737Ayg1i3Mx699eZ8HF7L6zSeQdauHclKzU1vvy+D3zvmT1+Yv0X97CKYGLc8y9cA6fGA4OBsFzTEL4t0JjAf3USiXjE8Q7SuUxXqFWOzQK2Nvax5g43HMPI3EoNMNEGB8POHfzAgffu818sxWeKRG01qFlXV/XmxeJvvgM//Wdd9m9PUZphVaGWBRaheeoFIf3DodwxWn+4VGGTwuakak+CPBv//zMMMO/w5gRrBlmeAJePAYh6w6QUmOuKBrXljl87ZAeQ0qERtsQ+4i0n9Oai1l85iLpVg9cgZaqQiNC3s3wzlOOMw429jHW4lUgPZpa6wVquU37556GbooWwbUjirzg6Ks/JlJm0mL6AGqldCUgBwfe45QBQrupwIYRfRFKYVL9KJQnDPHJtFVUt5E+cCxP7aVUHe4DqM1VG6tNyo2MyEfoRNEwwbspkMTQDittZfNQtUS10TjvK9fxUCmbZjw+4Td2ak0WhfIOe7WJOinRXY9Tp0Td+KCVyxxqR+OaglPw3DNr9E4GXLxymQum4Par9/mN3/xV/u8v/y7/4W/9Xb78u1/hhZuXmV+a591b9/i5F5/nq999nS986eO895NHXHr2KqMf3aWVewauDFo8faqGc2ratJagKwSfBl2cFcB7svOLHLyzxcHdAzaHA3RlRqt8sNgAj/FSTYNqGmdayOUm8vIO5iPniWPh3TcfUa40GM4L5qig04e1GxcYbB1yzkZIf5miqsyiw506LY73Anb9iO/c2mTlzBI7ecb2KOPZuUXGojjyDqVKTFmirVC0BboZojTjcoTH0vIxsTKzScIZZjiFGcGaYYYnUQmVldJVpEnEqJ9hopjlRNHwYEYlaqHBWCtirTm5v8+yCxl3JooZUbLfSwGPEj1pGJXW41UZIkyqjU4R7BSON3dpqAQudfCHJ2AdVjzx4wWcKaqJL6kqOfigT9p8vsVb332bs815bly4yDfuvc8vfeRjHG1ssXHQ54WbzzDYGTFO+7wQn2UiyiEcZ6r4mlp+qmqyklozXoUyB4+sx6tMrlsS6QiJgJEjjiOM6ElFSpxFq6osV09XVmJtIypYNIhMhNofPO9AgsGjz8T4YU6+3iUCbJIQZVMdlKvarUo0XhySKPrdAe/deoQ0FWvbKUNfUsSeb/3JN4mJ+bNv/Bmld9xf30E2N0lT4Sfv3iHVcOuN26Sp0Hv7IUdS0jAwp8E4E1p43iPVFF+Yk5hq9jx1CVGjnANt8D98wJvFNhfKNoUqkRuLFL0MtTHi6hc/zvhgn/79A6K2oThMSVoxi515uo1jlI6Yi0PremF1EfORZQ6++Q7XpMGzv/YpBmmf3pd/gN8doSM1vYHV1dHVRKZ4hUoLFhYXWF1p8j/90uc5LjIO/+Aer88rnrmxyF+kGX/rm/cxzSZ//LnzfPL2LsbsEyVRsJBIGsQmwiTx/4833Awz/LuJGcGaYYYKddUJH0botSjidoI7zhgfBpv0lc4CS9fPs/nGPS68uMZPvv4Oly+cZ/XyMuM7h+SJkB2NuTfqsnr+Cj6GWEG2cUzpS8Q7vPXY0mJ00DU5PCpzdG9vodttdH4C9w7wJznGCk75iQ4LHm/D6MpDwX90BbV+hBtGzLcXSM4v0GqdITm/DL15dLNF4/oq6p0haRwh7QS33ORIR8RFSfMk5OFNKVVl0eltRarqSbLQ2gvC6Er8XOmdVDVWpr3HRRpjDGW/ROtArnRFmFTFPpyvJ9EeJ1Gnv5/kPHqmE3Y1MfNCqQrGJmVupcWoO6T9wgrla4fouo8I6IroKCLMXMyv/O3P89xv/Ar3Xr/F7tYuSVny0VwTWzh/1RJ5w9oVi3iFk0BiLy20WekOWIgixkXKxbPLbOwfEivFwsIc9Mc04gb9ncPJ9OWT3lGu0tspMVjAWEjmW1zoLxArBYNxqHbaAkjpXFkmH3VJh2NMGSHOk52MKPpzZNqyaBSD4y6iFM1+wfh+l2vn14jdmNv/4puIFhroSdXRVddBKi8sN7lCoT0tzQb/77tbrMcrOG0xn72ITmJ+nA441znP9/9+h7YxuEe7vN8f85uLZ2nqk+CtpjzaaIg+LFB6hhl+NjEjWDPMUOPUPq8QUlsyznLiSFhaW2LY7ZMfp2z/4A65Eza/+Yi2btJ/2GP/wSGZsqygOVKeIYLutNFKMZcY+vf3ASidI9JgvZtUgAIx8ahWwp8/By/e2me5E5EpizkoqTJRHkfVDhQFNAzj7RPU0FIax7Fy5MYzLnPWB/u48ZB+MWIvTbGZIo8Lem2L2zzm8NJZVkpPwwvUlhMVh1FesK0oeEPlU7m2sp6yobDWItZV03syrWFV1ScPE5G+l2oa0ofJtFp8/1iB6i8hWo+dup9Sgyg1HADp7QNc02BffYQfWyJtQuYfimlQtsNtniDfeJvlvKDpSj7ZXqGwBSOxOHF4rym8BS1hSIEGqS1QaD5+tk3qHEo8pm242bhE3GqSD1PUfIfhW7erSctKieXr9U5F7lODz3C98iJFZ55GZomMRo7H2F5GoQxv/KvvQFmyuNzBNBKM9vjSM9zuEq/MMzo6prnaobl+QBtD2ZpnuLlLmY7xYnHWszTf4oL1IfdQHr/GFWcNVhnekYujiWf16jLeBtPaG3OKq3mb5aVF3lvf4JnOGn/aG7KJY+w82xtbaB0MVk1kmOsN/pI32Awz/GxhRrBmmKGC1DsOVYtKNEophsWYC5cvk7mcJFecuf4U9968zYtf+hQ/+vrLnLl6HgG2tg+5+onn6L/yJi898wyDwyOODnvkhcM7h/XBPsH6QLBCZAl4r3Hak2Rw0ywzt1AQjSAf2VBl8FLZFZxaq0BxtgXiWXzuCkkC9v4x2kVsdxoUu330mQ7SnCM/TImehsHBgKNhj4u6wf6tezQ7Cc20oLd+QqPTQetoooeatu0Ea8NUW00TUDC3uozvjznp9vG1X5Kcai5ODFFrR/UqfLkilaebVaGaIngsOIXXDuPCn9U6MqkqUt7b6hUgTAgazv/SS3SLEWvXLzHu5zTOLrH1P3yZORNVkTJhXVoEj2J0awPrPb3xgEa7hcsKsjLDW4dGM8wzWo0mWZHRarYZZylSlsytdMgOxyjvaK526O0eMzCCcxZT+ZmJMtMbVDur1q24SneFEkrvUCKMXclQW+avrMC9ddbOXKTv98mSFhc6i+jhmL31TfLegDGu8qlywe3dw3C7x4KJSLePuPjLL3J8ps3G7bvsPDjAefjMjWsM3tkjVg3qwcoJEa6+8N5NPN+8ddjMMcxSBuLZ7+f8OC9p3l9nPBhxZ3OHdqsJohDlES2VdUc18TpzGp1hhglmBGuGGWpUn/DrgBARKJ3Hi2bv1iP2+kMSbdj+0QFjZfjOH32bscSM725S5DnDOKH87quM0dx79w6+yPDNeZy4SvAcTD+99UTi8BIiY7yEjbMsCrZbC7z/mWUyLB/95rtcGQUCU4/TQ0VePMT7GeA52X0fB2AtOZ63X3vEyDru7WyhdzbwjYQ3XruLJcc2Wrz7rdfBKMp+QdxNmY+aWGuxCFHUoCwKytJVFSZfucxPq2ge+O6jdxi5ghuyyIo00E/oxKZieSa5iHW/T1yoetnKa6wWdonTOF8y/5klet87RBuDKP+Ym7iSKt5GAlVzwxGD1++hYs3h9oCsN6bI0zBo4B1eqmpZbVtRvU5khCTXqKwIxKjZZDTqI1dWaa8fEc01KIclooUkUgiGuBWRdDO8CFEUMg9ZaVIcD4P/llKT6p1Mpgjl1PUI6xcRdGWAqgFlDImK2JMR5/KSLCsYHmzTPejRLcehvSkahUKkdnK3wcpCK2ykiNoJt7/8NUqjSI2lxFEoS377AGc1RDW5ZRKdM33og6ZNlKta2CXj0jJav4cdp7TWLvH0coNULENnMeUo6Nqqlm3dvlaVdckMM8wQMHs3zDBDjcnH+0As6o1IBJ7+2HNcWVrm2UtX+fzPfY5zzTYvvfgpzicJ1y6s8rGPP8tTUcRf+cgnmG81+eSly3ziylV2Bsc476YTbZND+dAmrDY65x3eOpbf3+PyrW2evnVAcjw6Va35sKV6tK+NN8GJgHcsLXcwKmLBRKzoJjmWpGlJnMJjWYgUzltaTjPvYzRgrUMbRVmWeAfGGLSOiHQUxP61g3dlMNr0hnlJKGwID7Ye/KnzO73QehOWlQTXqggVoBY0pfL4CMyCwroScYb0JMf7MPaPKOIbCmm4imieah1KiMzpHBf0L7TIz7bpRgX+4TFeBOv8h0wfhjUmzTiI76OIuNEgNpqmSdA7J3gckQHBoeNQ0dNaodoGI8HWIo4jvFZwPCJSCqPNpIoTSW2UKqeIzMRDvfKy8ljAZo6j0YA3Ht7h3NWLDIZ9vPesnTnDeDSiKEs0gpISoUD7HIMnEhMc9a0jWWjQeGoJjJC7AskdVzpLIWrHTY1og27uifs0XR4Gj1HgXEHmcrZee4MH3/0ew/1dTo7GHJwMKLIyGO7iQUKrNlR75YkXnGGGGWYVrBlmqHGqnYRyOG/Bg440d9fX2e8dcXTS5eGje+xFBnvrFl3nONwa4zaEripIHrzNTp5xdL8XSBMK5RRWh9bQJKh3stGF790wR2cZl398H186nCgWX3qO4if3HqNYE/sBCZqeAo/EBtNMIM3wFj7yCx9j5/e/w9Jz1zj3wjM8+n/+iJu//BLHD7dwW3u89KWXeOUrP2D5xnmULoj3NM1C4SxoLRPn+OCiIKeqHtXxnWPtmRuI0WSDISd3d2mZmEQiUOqUID+QsjqqpRUZnMkZFTkmTihKiy88LMSolkIdZIjy2GMLqsRjEAdRPyF3Lkx06lrfVM9lepwXks0e3ZMdlAYfCWbkEP24xqsmO6KEbFSE/EUVbB6MVhSiiXSE8wWNRkzej9AolNGowiO5kMSGwoFODMoIGhMMPCvXe61CW7WqN1XXsqbJ1eCAViH4Wgvxpy6xttvE+IivvfUqn1i5QqEc889fZCM/Jh4YZDlGjxQSBVIelYIrSnxhKZRmtHOM3+kheBLnWVvusD0eV4J6j6td7H3VqqzXUmnD6ucpjjTziwus+gJ1dMS5KxeQlUWSlQ7LzYS2afPM4gJbO/s47/GurD6PhA8hugqynmGGGQJmBGuGGZ6A8kw8iJQA1nHuxhVsd8jKXIeFs4sU9+/xc9ef4eW377JybomobXiwuc+nrl1i8849nv34dXaPDthb38N7sMrj7VTfVdODMBnnwXrKpYSoTChxNFJP/tptVGxOWShUvydTyqUAFtokl1fRZY679ZAsV8Q3LlIUBXpccvnGNVJvaV86j+z2OBlC6/oaRa7opFB0++QmoRUnVbSPPFYlqpd62sy0/Vc/Sq87JNvcQ95/hDaGuCKO02FMF0TmgD3fZLxzghQKpwTvS6IyIZMUdzjGugaIwjlPjKYoA2GRyDE+GCMKrLhJtuCEwnnP6BdvsC0DWlfO4XZOeGoftr/yfRpmmpp4evKyJqm6NnulJghCrDUuihkd9mmIgcITWY+KIvKtHnEcg3XEczGxaFBVNE/ldF+7y9cC/mAR8USjQIc8RJxDv7FHOTpg2GqCUugoIh86eu9tc17PMzJDPvHSBQ5ffUQ2sljxOAP2+iL9e0PcuKQpESy3MOWYJdskmlvkucZlvvzwlao1q/AfQnykEmJ5EfBCwzTIY8W/t7rI//ryywy1UM4l5HfvocQjpfCmzxkBz/lGqPI+8Zh8aLl1hhl+RjEjWDPMUMMz3Yi8oBJDNBejKdl+7W2OhkPKEtaPjtizY35w/x4nZcrgaA99FLFjM97aO6FXwN337uHFYCeMw52yJKgbfNVXImgRWlfXsHlOMy1hd0BWWoxXePFBe1RvZlMeE+wODvsM9k8Q7/ELTUwGJ+9tcO7F5+jlYx688jbnL6xy+M46o+4RkbJsPNzk/Nw8avUM7DrqPOkPm9w7XelQIigDj77xY9SFNdIf3KdZZdGdckaoL2cQ6YuC1SbuOANXIEXwgMJaqNqc4Vc9OIX2qtJPKXCCpcB7jU88Pg8u91Dl9XlP87VHvNiZw9/ewh4PGD3aoW0S1BPrmZ7P423DSUBzRQyTOA4VmupHYkzI7rMhJ1E7h2nGmNB7Q+lAoGoHdl0dWBBE+UnXrCZ2SimcOJTTmN98AfOV19kaH+KUZlTmHGcjotRi8GgV8ebXNhAvKDTelSAKE89hGjmjUYqdm8M0I7LjEdtS0C4zeptdxHmccshEs3ZqVOGx9mWoVsoffI+1m8v8z9/8Lu8cjyBRiDOIBD8240E5SzNJSFWKdUU4R2EyFDHDDDNMMSNYM8wwga8V2SivKPKSdDSm0TCcf/FZ8lv3aauIK5cvMrj1Npeevs76j99j4cwaC+025e4GT104y51Bj3NX1+iNekT3R4hylFjqjlVNJ8Dj2wppREQp+LuHuDQla8SYYUrkwOu6pfNEleBURULVujEE3xujv/Meyjn6P7mLtHewzYj9l9/mZDhmVFqOv3mL0pf0hmP0o22eIglnf2qC8sNQu5JnwPqnb7C8do4uPS5/9R2qQsnjr1PlMjoc/if7OAe6JPygk9AydT78Q5jGAwKx8g7lBeWgQEHpKSIC4VRTkulFY3oZJ8fHuO4omGZWOYbVDOIpQuUfr8hVf+eUg1PXOYi1a72ZD8agCFocBsEphTYaZQTvQntQKwEqM08/JR2hOvaEjq6qGHkc/rVN5vHMjxUGgdiwstBB+hl4hTQVnasdum8fML+6SJFbhvsnjLcPWPnoRbp/esLc+SWK+1ss5A6tFaPBEaigYVtYW8A8GE2nY3l8XbVthHjh+lHOf/cX63z9r97khW7JL/3mp/nh73yTy2PN2b/5ad79P7/F4qUlPv/FG0jXcbR9N0xpKj3xQPtgltMMM/zsYkawZpihRl1pAJwXrHfBusE5jh7uMjjuI+0W/tE21joON3bo+ZKye8jo4IgjN+TO/Q2yMud475CizILJJWGzts5NXj9oxhUMClzmsY2EwZWE+I0+fOQs7rUh0Y0O9n6XKt/kQ5dbV5a8ktCuig1zpsWzfpnVhQ6uaSiOxjy1dol0f0Czd8By3ORjjSYyTGmZCFH2sfH6D4+lqf4ciJxn+Gevcmg8nd5wUv2pUYcIu2qR5tIi85++gD0pcBaM0YgxWFXSGGV4D0krJt3to9oRai4mutYhSmKUMsHTyXviSLP7jfcx9fUQUN7h04yo8Hgd471gjA4eXU9M8IWWVkW7qgEGLx7lw8+ravKvNuMMh5DqOMHTqyZtqspK9CpUH+tKDlU78N9czQkVzPG9A741fIQvIRJ4dLiDT3POSosGijgOlhntzgK29GTjMY1Wk3xnwLE6wHRi5nLoimBunCc6HFL2B1gEZSIk00inBaP8sXbptOss09U4ATQfn1tk/eEDWqM+Z07GNEoNo32ujBxt6zBbO+z8yR10BEZC5JOqBxn+DWc9www/S5gRrBlmqDGRGAWy4urWUTumeb5N4zAhakaoOUNnkNBeasN+l7lWh3anSfvBfRZXloh2UtbmmvS8QR+PEaWD5xXqFBEJm7tHg9c4Dy4Ogb28soVRGr958tM36oq4SS08X12gFcU461AHJ7wQdWgun2eY9plLOjRzxZl2h2Rc0lIxN+fmGGXHpLnDVOHKp/tpHwjt9ZNV47SwujVgM7G0bAiPfmxOz/sJGUM8xeYB3UGP/Qd7FDYYlaprZzAp2NhhR4pyNGTu42vsf+0By/OLuJagOg1O3tnCK8FrTyNRzCUt2nEjTND5oB9SVOHQWgdtla5aiI+FV1fkyk9JQE22cCCuvgYepYLJqIhU+qTgZm+0wXlXM2YUBhFfkdOqEvT4lZhoxuo0o8lwg/f4Tov5z1znS/4ah/0e3/7qD3nq6Wsc7uxS9i1eoL28imhD/2CHcx95inGasayanJRD8u0DtFNQ5JTWg44RPcRqHcitc+wXY1bHauou/yFzqcpTZR16+Px1nnrqLFe+eIOkoXjhszdpFhZZXcJdWGT5r32So1ffwrqShkrwxgW7iDo3ciZyn2GGCWYEa4YZKkioKVX+Vxa8x3qPz3LGh0OcBQrHuD+AomDYHRJhsemIvcEx4OkNB/gih9zhRyniHKUUlBQTn6Rqfw7jdVUCjSs9i3cGRCtLKANFkSOiGZ70gQ+vKtWbmVeC7PcZVhU3ccFKwO4doMuCRiPBHw8plGI+SXDWku53wVoSgrO6EjWZHoSpRkecD55Op45treXcb/0VlB4w/6MN4vcOiCp/p6nIvWo/uTBp548sZatJMRqBVlhXUGYpq7/8PLtfexsZ5ozf3eXMX7uOe+cEWWkgznH2F6+RLeWY+yNO7p4wyDMiE5EoPSENp4cA6jidD1avfgpRrQRmCkCZ0/OPeKD91DnMXKPy4KrifUSYu7jI/o/XqeOVTocMne7f1hXGydomzFhQg4zszQ0epntspycYo9l7uE2rGWNq/7E0p6UNXR1jCoiHOVFnkWxUYnxFpAqLLVP8nUeoWHj23/911nv7RH/xCuP9LqhOyGv6adehqmgpJcSv3Ce/v4vaGnHnrqXzfoE0I4rX19EHnsEfvEra7WOcRwNGdNCiMRX2zzDDDAEzgjXDDBNUxpjOIU7RaCk0nry0nFlocnx/j7Sp6KwscXw0hDOachP65YjF1Q7b90dkiaB0xGb3hGihgTghfXoFZTp4Z6opwPCv4I8eSEx07TzF3hH5ICWZi8lOhug4QSk9EbP/NEhYeqjqiOA11FQhjhO0C1UXJx7BBFKhFPg4kEhrK5I1bZFVX+ATyEYZiUkmZCUywtnfe42WtYi1xCaetMbURH0/vaau9oBSITLHWYe+voR/54D+rW1WPnKBo5c3KHopJ6/u0ds7Zo1VjosMFiPSuMFznYgTG+wN8rIgik8Zn56utk2U3E+Q0b/0vruKF57KEJxLOPfZF+i9/YB083jy576qRg23Dyet3nB7puq6J4pY1SGmthJ1TJD3AgdD2lnO2ieepXv8GhcuXyI2cNzfJhfP7s4uShRxFLH1YAOU5t5oD0RRVnwmk4iLX3gJ8UL/zfc4eP09No93ccOMhBZq4pR2almnCbvULWtQZXUDvWPlwgrlO5s4J9izEWp3iFVxcG73YLRgbWiX6ppgzxjWDDNMMCNYM8wwQa2wAWcsUgjeO6wTjLEU4kliRXrYIzIRkXcYZYnb80ROsRjFzLdbJP6IxsIihXHMScz4I5ex3UO0dWgVxN+uiiZxBOJjN/ZRaQGi8aX9/9h7s19LsuvM77f23hFxzrnzvXlzrsqaS5zEWRIpqVuWW4Jlu91tt2HIj36RAduAjf4TDMOAB7jtNiDAA9y2GxIESd0y6aZkqilRFEVRYpGsUg2syqqsrJzvPJ0xTsTee/lhR5x7sgbZD/1i83yFyuHevDHsiMz93W9961tkOEQMPtbEx4Ic/5pL51wlmfcTOZtKZY8NIQakKaE5+7hyNfu1EfAR5+S8gxEQtY3yJUTM7GvaeYSNbHMeR6EQxaNrS1z+tV/h/j/4XVZCjyrPmeyOOHtrDyIYa/GDEb08R/qe5XXD9tU19l854EG/xoRA3smaUTGxGVYss7iBliCjcU5PatWsx9PwH7/flqwlpclur7HxiRvs/ekrUIWmrNbeB4gqnScvMHhvj7zbwcgcyZsrk50Ppj4/dxOXShTFCtjLXZ4rVjg+rrkXHYePdimdsq+jlEGmgSvra0xPj1DrsBp54flnmN58SBUDauDto7vowXvUKNMM6reOmBhl4sB0MqQ2KSyjvTZJlNI0ZdDYXiYNHbY1ihB8QJZ62HFFXmUgBjWKKwSyNLInhYyeq5+LTsIFFjjHgmAtsMD7ISkscuniNpvXtpBeznC3ZHlznaVel9zk2LxkehTZunIVCQFKIV9dY3/nGNdbRRSK2GHtqQ5bN/e4+rkXmP7VPdKEPYOgxBhQ51ARdFo3m3igGiti7XmZqykrzSdwz9GgD/iltG2x48M3vPdHFKQv+oD01FTP7Ac0idgcPHXrtVvz+Z8yIinlvE5BraKkezwbsv+P/zlE5fC7rxGapHGrhmjTmJyNzS0q5wm7FWejElmB8cmIbLVHOFOiBjTa87BVOe8SFDGomYuc4LFmyw+FQoozsCA+ULxwle76Ovt/9Eo6hjm3bguNDqSK9ByhYVJtjMWMhc3W74PZW0QQazCayIrfnzAsR9wbnpE7YfXKRW7evUPQNF5pGj3HWvHpf+1v8Pbvfwev8NbNd8kjZOJAIdjGP2eh0BTLoMZSi0erCrHdZELX9G7MzO7vW6dIGskja10iJU9+9kUe7b6BGS0hzwjh1oTCZmgnUMcKNPt/scILLPDjiwXBWmCBBjP/jRFy5/Df3+HFL30e41JpSEhdayhoFDQaKhfIfUSN5Xkf8RaMWHAg1mE6OdVkyvHNu4zvHmLPG+BaceO8rAVNV1tMpShNIZXSeGQikozI82b0uS/WDymNfRTagtU5eTj3hs2iumaWaJNSwKXxfSXJBqPn45sf817VAWstfnYOxaiglzYQA1mMuIMBwThkKaPedOQOTJZxdlhhBwG5mmPGNSevnmJVePpnn+PdP3yVqBmqZjay5zG/V2Nkj3GeiOpjRCetrxAl3bGoEgx4VS586ePoyYDDv3g9lWbnOgJncQbNmjhr0nNuX4zZA/jgM3i8hBkx3SxFUqgFFygubXN9bFjyJfvvHHLZ5zxFFxUwKvgDZfD1N7hYdSB4fGzmAKoieJYudrHOUnS7TOqa7lKHyd4RYrtMfEmxegmt/OyZftCMnz6s0pRA3zwlOGH31/8SE2My+u9Esiwl2nczl8JScUA1Uzfn36wFFlhgQbAWWGAO7U4RCVaI947R9w44GowpQ02tIak3UVs7PJ31DtVJHyMWjZBt5IyOR9imNJUtF0zGJYVNs/0MkTn+kkIg7bk2JdoWtxJRcNY0hA6iidjWFc98vlNr6G49Po8TsA/0tkVm5OgD00hVU8q4NExrFjjVkLHm4tty1/uXbtY9yDmxUEAlMrj1CFFhKSuIJiNWU7TXpVKLlkIxFZiW5LXS8Rl5NIyDx9ucN776Ms5m5Fka9iwNoTpXr+YUNCOPJ5c316QiEJW68dnRMUgZ6V7fZvnyNqevv0fZH2FtcrAlfqWztT3/HWkwskkErl3dj4q3OH8WDVkrM67/219GKwWjqLPILyi1TUn1de0JU586Fpv3IMDcCKJmXU3KExMvuBqqEMk7PaZ4vEYwAaY1R9/6AblJAaiP5YLFc+ktvScWQgXWpAw2hGBsQ2JTiTEclsSoWJcl4jxzrr3Ph7bAAgssCNYCC7TQxBwa8pOUF0RZXu2g4wg+qVs+pDKfAlnh8K6ZPGfBFRmZyxBJ+Ug2c1hrU8mPczIgJHKlkpSYGRmRZFZXIhpS2abZ2xpvT6uSMNv1W+M079uAzz1Q7yshck6ENDQ/N+QplfPirOQ1I3zStPM3sltsCNpM9XsfsUifT+RDG8Vk7bmn2P73/y6Pvvs6g937GCKT79+CnRI1gWJpmdFwwlQto3EFEjCZw6ine32ZelgTfA2SER+/pfP7nVOyZkGhDcJKh2xQQlSKLz5Pp6zpvnCZ/qu32P+L17DisMbOFLrZOrd3OmPFoBIQ/WB6+UeVZLU1tjvl8A9fZlrXaJXKwhEl1pFYp2eZLXfoj4bo7CalIVugMaRmAc5LlqmcmPjSxnqPs7MxvkmMd9bSKbLkv2vVyTliFVVBA0YM0VTkL2xRvX0A4kDSNYumyJL0PgnGktLro9K6Fs+7Nj/4XBZY4McVC4K1wAItJBEeaAhPIwZZtax0ujAdE60hTs/VE+dsMvg2pTNxhsZPPCveWdvmK7UjVWS26W58+hqDN3awrou5nKP3J8SrBXU5pbjQZXowxBwbio91qR9NiYMmFDQqZAbvI8ufusxocEC8V2FiSqFnxhHOSVcyTQvFF55E1npI43g2EcQKMXiCRgxgo2FaV7gQkbzAWcPx995m47PPQJ1M5oJSPTyl3jl7bBmb1TknX6RN2DnLo698m7OH+2SPdrDdJXKTYXo5Nka2iyX6Z2OW1jqEwQQkT0cSg6nTMOK1SxtMd86aDDGa+5x7ZrRm8qT4hIYkAMTTIXJxEz0ZoodnDN7eYzoaUR4OUOsabbHphDTzV39+X6IpZX5msG8/NxfeeX4tc69Wk6lm1IIGOtYQO2kkDxiiU3zuCaoUKx2yWBFCTO9SKxvq/LF1Vs91DfkzwOrldeooBJ9Ke84aMkl+OVVgOaXnM1KESH5pGbfiGL19jHtyg7BzknLHSOQ6rDrMqKatD0ujfkUlJerHOVK/IFcLLPAYFgRrgQU+CgJph1Mya1np9aCXcbp/miKsRMgyl0arkDZRZy3OWMSmj+m0TnlGTRu70IxiQbACed+TB4dEz+jRkKVQUB+WqNaEQ0XUA0K8ZwnDEmtc2vyjorlDJmPKm7vYSpEIiG06xaRRWpirawkeWNrqcfQ7L2GtSQnwUcFZpEq/DCJ44+ktdTmzAS0jubEUvQ6H/9erSZ3LCvKtLtPxEEOG0whiZuZzI0KMc4qGCvbRITuvvIF1ObFryHuW8f6APMuJ3rNWF1ArZiljfDJk8ycvUfenTHeGDI5GOCz98hQbwYeAF9vM/5tXjs5Vu3BhhUIcEiIQKazFXFgDmyEXVilUYKNHddRPJcPW0P4RRGF2BgUlnIdqaiJzcU49ez/OFcpEaoVmSHTDS1QE6zKCieSFQfFYa7DSjsuee47Nb2KSG9MxFESVleubjE5L4tCn4dOm1Vqbc7qM4eiEgqX0uUlFeTREFeL+KL27MaRvEAR8rHGNetm+Q+evlySSNSsNLvxXCywwjwXBWmCBBufxT3Nz2jg3gBuxdJY6jIxFUYJCUeQYsRhRMIKxtjFI03ytTRtdG2UAszJhVBgfjIiFITOCLS21rxHtQimEXKA2UAOTCCH5nlqjvEWIBnToUSOECJYIVmiLN60Nvv3BBjChQooM41zLH5Mac6mHOZ5Qm4hMDOqEJZNRlhNMx6K5w4kjOhDncL2CejTC+4CxZlYC/UAuFYARxsOSTKEshLNpSWfvlLDq6A4Cea/D3tNdZKfGW2HZdfHHQ4rtHu7CZTafv8Ly5TV2/7fvYlAigo+B3Ni06bfPqlX3Lqyw9StfojwdYqYVagOZ92gAe3mVGJTBkqHe7TOqa6SqKLI8qY1/beZYS1ZiMwYpNkrWB7s5P/wd08d+np1JQCysraxxdHRE4VyacwjnMQhtDlcb+dCUlyXOHTMXOnlO6ZJimpyCKYDWIOjYIxMDJqBRwBisc0Tv0bGHpebdbcrFhRdCiE334YeXPxdlwQUW+HAsCNYCCzSYD41sy3swc+AgRnFFRm4yVBQfIzbLyYxNznGEopsxlaZM+GFqhqSQBnMuA2AEahRLQNRighIIiLUEHzEBUs0rdRG2Y01M06EXxGKe3mD9eo/CZUz6I0YvH6EmNiNlYiNlmfS/VawK0QWsmpkiZnoGv7JEKPvIvdTuT6ZEiUT1RAJqlWJzHT+Z4ENEOxb6NWrNh2+0rTlchLUvXGXn62c8+XNPMibS/+YDNp97miIog1v3yHdPCZ0MfXKd8eGYuHcGJ0NclnP66l22n75GXdUU1qUyphi8KK5Z09ZzpSiZCPVkwqB/Sn7niKuXLuNDnBnexcCx1hwP+nR7lslBwGbJW2dia3A/fwGSFetchUr+qNRdaSCFb8aQFEoVgkQESzTJuI62yxybbtDzn1UMxilFt8vg4LghVRmmGSsg0qpE7/PStfkQpnnECvHUs3xlDT84xIlr7tfMFCcThKLXJZYBq6BZgRt5wkoHPZsCUGHJALuWIcEirsYPfcq80kCYhd9qisaY2dUWTGuBBeaxIFgLLDDDh28QMy1IBWdcCu4klfqcs+TWpdKPQNHtJI+VmVnHm7KTPH48TZxJfURrIaAQDBICMQR8tOioTptyVKrK4690YW9MEQzEgNQRlQypI+FBn+HNASOTQtqNmMbMnHq9oPFFhdCYZ2BmFmtKl/6kpNrrY9fyFBWhSogpiT3GZpyKwnQyxjoL/RJrDRXgYpoLOOtwm1NqRASNgrt9SrfjOLs9ZnpwQr7cZXTW53TnCBlVuFGNMxn84D62DKysr7H2xBoxRg7e2GHy3h7OOnDtcOU5D9T8A2vIa7Hco3z1LTrdDlMiFlBNhCeogksdiZi2LCjnbPpDoA1XlUhSLFWaBgODEmaJDZoJVhyh8iAG23XEkSekVINEroxglzLCsCK/vIycloyPB4goIhYyMN6cd0g2ZGb+HnVurVuFaXDzkLWPX2Hrp5+jPhzMxh1Fk8i4tRa3VCBlRUDoLPUYFkq21EVWK2xX6H3sSYZvPSB3BVkd8RuGeDBiFlMRBd+fUp8mQjbLQtMP9FMssMCPNRYEa4EF/p/QRhqQyiy2oU2eiDUGa0wKaTSQdzOsFaQdOAwfOgDXGMU8fZH8yy8i3qO1x6qiMWJdOp6KIfhI1IpOd5VpR8gngSgBsRHxadNUBbtiMGc1iEeiwcRUTmzLf9BkaHnFbS9zZMDGhmtp6lrMoqGMYDe6+OEAU9XEzIAKIUaq4GdcpB5PcatLaEzKRtNwmRoFGvd5VJ2FSlhRRqcTFA+3HuKiY1iUSDXETWucWCCpQXGsqHGMTvv0j8+48sRlnrqwSWYNYwLlpKa1SrUG9raTsjWT26gEZ7BloJIpZjlCSPMlY9NOF+qaGMK5EvTXkCtIHqd0L4YwgeKpnHi/pPOvPom/NUBvnaZ1fKpL7I9hBzKB/tWMzls1xcdW8I/GhJM6vQMdSziLCJHJaEIALIbglY3nVhm+18eIa3LJPmSQcuN7N63vTAANnL31AKzBrS5hXGrACBLwF3tUD0/R42Set9ur9P2UYGvK0Yg8z1nd2mD40hv0rCNey6n2KtxeOovG9Iw9gbXPbzN5eMb4rcH7WNWCYS2wQIsFwVpggRnOc5XOP3Q+5kRiYyym7agyTakOsIKLBpMZbGO+bs3e88kKqTtRU1v8zim7v/UnPKgHdPqpjFOjhEAqffUcagz94zO2L19gcjomljXZckGceJwYLELXOTrO0cnSzDok4kwy39sISEO2RCAo67/8fPqYKCYKwUTUgDWGqol7UALeK+ZjT6F/eRfNQNUTC4NqhMxhc4uvDDbPECNEK1D6pHRZhQDBSEOyIhQOcwYuwMREik5OZ2uNcnKcUt9NKp3arS5XvvQC733tJXJrON095JSIOMtSZnEmnz2eCNh2feca/zzgcke4vw/r67AZmxJibPxS6R8/6wPB2qZBYK5jcN7TNXs70h+JAoNXjygu5PhuRvXqCdPjIXnzjMt3TpuyokWD4N48wy0vc/zyASt5Nz3/GrK+4o2lfjDB4RpvWWTzMxfIQuoGnVfp2vcxoHSeuoS5uMZ0d0hxocv41buYuk5GfQXvFX84pBnMgysKppnn5J09gijRB9aurDDaOUN2h5yVY5ZXVjh+2Gf84JjCFWS39nChydpqFLKAsrFUcPz2ARufuUJUg2nS4Vuz/QILLJCwIFgLLDDDXJ5Pa3inMfLGtqbX7MPS9HZFRSRitenSsg5rUtfgLOSz9Xa1O3RDdsRaKjEU17eRvzqale0Gn7+Mfv8+a5eX6U1rDk7g+ud+gpvffJn1n3qS8Xv7VGUSDvY2LJdHnqxwqbvNCeolKUImdXk95o7RdM2OFGXg8Wz+u19CljuIjxR1TfCB6BUbIlqDuXwBMUIda9wwoj7go9IrLNl4igbF2aQcnb70Llm3R3SgXmemezCYbsbGxhIMap771Z/j+MEj9DAw/Nku2e0Bo/tnKIb6dMq9b7yGkQKbC/hINIZModvJ8V5Q0Wae3jwhjkAit3WdZjj2nrhMh/QsDNI8t0axq2PzLNt8srk3YS5HS+beDW1Kc4aIjoEYcHVgPJqgppNI+MUuZr9MPi4lKYBnQ5wVrBiqqxnmbpU+FcGuCpd+5jn8pKYOkVhOOHljH8SdP7PZhRmsj2Qv3iB86jrV177Lyr/0WQZv3sNPPJlxmM0O7qQktu+hGnxdIzuT1BRBKvfmVUV/5xjb6UK0ZEuWelqTZ2mwd1VGgrazME2zflA38RGTt49xYpDYvGGzmUELLLAALAjWAgs8BqVpSVedRRjMKkcRJDSOrGZUS0BBLWqSuuWwidQYaQJDU2p6a2hPZunG9IyyQs6jV+6xJL2kAhSOT/7Ms7x3NMb2Pd5DLBxnx33KVYc5jozKgEPxN9b55H/0d5j+zp9iJlPCzgnLn9xk8vJe8sTP0tdbL5agEjAaEbEpnWFrFanh/n/1x/TXDU4trmPZ/rlnmR5W+MEZ5RsP6b5wjfHuEaM7xxRPbFHtnLD91EXkdMJkPE1hltaRuRydepiSPDtbPZY/dx0XLZsKlDC9d4L5q0NWSkHJ0B2DdnP8i+tAMop7AjEKNio+BIgRE5Tj8XA2KmdGetrng511v2VnE/b+u98lfvFJJid9ju8fYToWmxdIiHSvbXN255Tp8ZDiwjrBynkUAe9TsPSxpIvkTROhUDC1pA5PdUkFi0Lw9SyrKiPlToUooJaYKzzwmJCGLZsgbH7pJzj41pvEseCzCUiGsfa8bDkHad6lmzvv8c8evUqx3kVf+RP+lf0DVl1BbQJP/PLn2P/t72MxM0U2qWGOpNKmAc9111B3DNOzASZG6nGJDjwO0wxyNqgBh0kTCBqPlUGY4uk0Cx9bZmoUu738L+qv4gIL/H8eC4K1wAItVJtNRIkGglWMZ+bbiQI+pFZ5g2CM4KIjorhoUsnti5/AvHEfGpXlMYIGczs1YBx7u7uIK5hGxUjanF/+9T/GBM/Gs9c5vb/PSGrCaw+JZoJe6BCtQbVm+mifW//oK1x675QYBO8y7JtHZN6A80QcpgnaVG2jMSHEgAJOBXM0Jrx1wEgC4XMbLLsuJ39+n+c//wyT33+HenmVjU8uUU5LJp2MpSc32fryVe5+9ZTMWNSa5PPJHWIsYiyPlVoPp/T/4GbqmItpxuJ4SelWhuOTM9QoVZ1SyrsrS/jBBAzUhcFPAyZGXF7gRKhixGWWzDZqCi0JYtbpZxSiEaKPVAY2f+kzDB7eIoxKJLPky0v4iWf5mYvo213K3z6mvnuEtUnxmy/IzZSxD3HSS1S8RszHrpFf22Z1OCGzFuqIsRVmEDFCKt3GGuIUk2WIr9EqUNaezlIHJjUqY3wV6f3dbaYv9akP68fubX4UjzazKQOBrYMRIyLhdIRVCCGQY9n5jZdwRdbw6vQNgYpijBDFIIUl1srp2wdQBoqNFQZHJ9QSKa6uUD0YYKJgJL0nqVnCEA3JJ9ioeKoRbVK6Ug6YJRyM/kX8TVxggf9fYEGwFlighYCJKd9q+Zc+x+jTV1mZGKIR1FisOJwYOrWSqcK4RqcVHUKKcMgVKs/Vv/3zDB4+Yqc6YfmdIXZQNWUZeexkopF6ZYnL//GX2fvv/4R8ZKhXHWu/9AmOvv06Bw/3Mb5GMsMr7pQsGqb3D3Clx3VyCpuh7/TRzSV6T29zdWwI0xFm3WA7BmMstkmPD2qZ9iviyZRomnJYawjPM0SV02/d4ShGlpbXOP7GGxQ/2MPiqWKA7R50HEd3HtL/vT2MK4BENqPQBKmaGZk8JyeKca6hCKlmlm/3yA9KXJHRubhM/7CPqRVrDZJZxDq8VvQurGCOpxTLXXRViWclWc2sBGtbJTGtJgrUAsVKj/psRFczTv7rrxG8UE09Gjz9hoydNIkVzgci4JrmhTZ+4KPej1lWmgEi+Nv77Dw8YC+Hzt/8LHHvBD+YsnFxg06eE4Ln9I9/gMsdEMlJAat+4umtLqP1lMlRHx8jw28codX5s0knas97XrMWDD7CykbG5tUN9h5NCUJTEjZkzjSKVXsfSkvY8vUuV392i/Fuxf0fPKBY6jKtUrnS2QKZQmetR3d1mfG0ZHrY58KXP04cT3C39im6XTJV9k5P5tYlefwcHxHVscACP6ZYEKwFFmjR2KwAJBT85s4jvjoYs1GV7BuTTNGk0STtph6JWDWYqESX5rRlCJ+8lvPvlduULx/S0XamcjsPLu3yiqE+6rP/n/9zYh05iYHSGPy9B5T9Cas+KWPOCC/m63wqrvHa4ICgyvLWMmVectVu4S502bi2wc43b2IN9FyOE5uUK4GgSr6xRH51g/HhIyQ2d6k6GyVjorKEZSSGjs1Y+8JTdD77MbwZI8Zy9O13YPeAkdYULmNFUh5UlHNPzzyxmu2zjwWPNkOYDyZYycmzgnJvSIZgrMMZizeWLM+IkWa+o9A1OaOTMS5anDFYY7FNMj7SdCuKYJylm+WUJ8MmOkDIvSVqwFio1RBjKv2KBIwKxjjEpAT+Nlb9Iwc2NyqjtmZuA1rWVP0pg3XH+i/8FOODM04f7nH8cIdPfOljvPfD19EHxxgs1grGGS58+hqT4wHeTCiOJmnYszHEaUzKXBMqer6SzeLGhiiJIBaWqoxyClpXZJLUNyuCin2MJMrsh8i0P+bOH40op57sJy5z9vYDohpqDfQcTM5OKUogROoMzFqHw/0HTMcVWf+MfOQQAw7XVrqbcxiCPCbyLbDAjz0WBGuBBebQJP2gCFWEzsmAX9w/4DefvIIXgxehbjoBJaaSYkVAY8SrxRpH13t87Xj0Z7coTsbk1rDWK8jteRq2kv7y5SEyLZuwyk88yXTdEX94F6Y1ZSbkVsiJ3KtPeVeO2L6wQTyF0/1Dim7OiT/C3YXhK48QETJr6fZSGFZLFh0GrYDQDGlWffx+FZZXluhc2KSuJqw8eZXv/Y9fRwtleXOb6uER2zeuomJZ/9SzHL/+LoVLIZYqpkkXl7k8JJ01B3zYTL5u0SWEiMsdMYa5kmtKLBebFBg3SWGrxiRzuGlGx1hJ0RgiKXrCq9Jd6kJUJqPRbOZjy0vars7MRWofSFP4pMn1Sudtj/eRiM3gatXGIp/uKwiIMbiDU279p7/OsKzouSXy0Yg3v/kKMRd48SLdW/sIBrvU5TCv2VjJWF7LmQxLYh3ITaPIyeNxDImLn5eZrYJoxBaOMK5xoxF5DpiUy4YxKUpjvrRIus9oFOeSr7DbydGdPstFD4IyDTXVoKRYWyGnRiP0VpY4ebDPk3/ri/SWu7z5v/yfzRgdi1WlxpNL9thaL8JGF1jgHAuCtcACLVRmMQpKJIZIubLKV1aX6RKbTcSmpO5m3C8aU1hliASNxCowjvDK/i6/HAIm1kQBRp61pS6FcbT6Tlzrcu3f/HnufvU7eAF96z4b3QxDzvLli+igRJzFFg4Ngb3jQ7Y7ln0f6T1xGbPVo3rlDpIVOAU2OrhxRZv+bUhRDG37vFWLxpiCUDWVuRI5imQ259QJG89fpXaRoc3QesCVT13iaFKSXV2lulMS1nt08xz1bdkqeXukUbKQ87ExHzU6JvomYiKzuDr9EyQoGINzjqwoKAnkkhGoMdaQSRr6Ii3Zas4TYmR9a5PpcEw1nWKMaRv3mK+0oSljyuYpXNTTqEQC0h6vkXo+MqrDKkUvR5xBohLqiFHBinIh7/LkzoSVq1dw4jDFGkEjGuFuJzDQPUaZstafYP+ipC/K8k9eJ0ymBGNxOOx8GG3769hGIGiTw5WS97cejBkPaqq9E9ZCTaEuRYLA7BsEMU1NsyFoG596hp6F/R+9y3S1w96rtzFisQFix5HVHp0G/LSm8hOuPXuV3VuPmN7b5fD2A+rgMZll5fo60wenrOhyGhDAeQlTFxrWAgvMsCBYCyzQQJvtQSJEo4y9x4cSax1pokwqvVzoLDHRwLXeKo9GAwiBUTWlrmokKEEMQYUwNyPOo4ymU0whaXiusZS7xzx681byfvUcK8s9zg5OAYeTIWtPX0WpefRgl80XLlMM+uwenSRT8VGfbDSlNhYTBTVKFkrAzTZUlTaagMSwmvEu7Qy7pIrEJsRSGJwNOfn6fXIRCg8dlDv/6M9RP00qTW4Z/+mP4OoacjIiBk0jYRSipM5EIBEQTfVW1UgwiglmVkrUyiNFhjOmyclKpUwTIDqHVJ5uEJCAsxZjkjJirJ2RiJaK9FaXGZ6eQVDEzHnA2mfadtEZMyMBYgWnjVYpNF6lVjkSwlYPBlOKLEN6OeVhH9eIc9Wgaoz0AWOzNDDbJxVt9Mkb2NMxyyur+GcuoC7iY4W5ucvwxiaDawW920O6T21j39qjQBnNkg1kVmJNnYvKjK70Omz/9AvopGI6GVMOSjYfHtOtc/b7x3SswzqHtfZcBZTUvdgqWSLK8OY+1UZBuTdi79ZDxFlMjKi1GJdhVSl9RbSBSiNnP3qLWpT7r95iyaU/s/HpZxmOjxFricQmpPVcKVtggQXOsSBYCyzwIbBiqGJEEXwIRAQr4J3h3nSExdCvD/FeIFap9CapZBSJBJNUrtioR0GSeX7qA2JTDcdtrHBhu2C65vBnnvVffIaz/+lPsGWa+/fg5m1GVYlVx72XbtLTTvJyKZSfuoC9tkbxlR/hxJAbw8rVdcrbA3wMOCOotCNxlGgBK0hsog1EkwYnQjDK+PiEJVOBOuL1VZaynNJ7Ln3+EgdfeZnhm3dQC2Iccf8MubBJrGqIUMeI8T5lYWUZoaqIHYNBMVFZub7M2Z0h1tgUwwUgkEnyXLlm4rRC+jOq5Fk2p7IpYgQjgm2S51ulqRpNkDA3BPl9Zb4ZYfnA822jKziPskjhFjCZUANlv0/UnF4zL9ApRFWiCFEdEcFYTU0DCtO7BxxMRpzc2Sc/vcry4YAbn3+GvOhy9/CYzrSHX10m//hVyjd3mRyNCCpNStf7uk1nNwBZkTO5tUv/3j4hgl7OcU0q/VpvKRn0m5yq+fttHn0DQ+fqFvkntxi9fW/W4OCLnOpTlxnd3KVbKavrqxzdeoAzLsU8CPTPRlz9+FMYMZy9t0dW18mDpfExA/5fW2JdYIEfQywI1gILzGGWrxTBR0E8ZM7RdY4bm9usrKwx9Ir3U8AStKLWgHYdLgrH/TP29g8af9Ks2X7mUQ5Eao1IFKqTPmMbqCmYPNqn/nMw04BgyRXOJPDiL36GW99/gwuf/QnCD+8RRhGMMHr5IdM3HtHBcmHZsXSpw/jtI8gsQQ0hmnPVpkkDnylNnZwoHsgxgBNFb6yz9NOX2P2tv+DKT32G4JTB77+J3N4nC5bgpA1BYvnpLV781Z/h9H/43sx4rT5SUrOEEBBcU0JUhbM7ww+W3EyardeO8UmerfTp+bBXYwy+CknBEklqG4JayHo5VX8KaDN2sW0eeNwL1BKvmTKkirm6THFliXhaUt45IeYZTi1KxNmMfHWJ0/0jCm0GCKpSt2Z+SSVDgyDRUFcV/NqvEL/6PfKjChMt7O4wKgO3h2PGe/ssTyJMBvQfHXPy7n2WY44ZV2SdvAk6mCtnkshR++5ghOp4yOSzW+gbhww/0+XCDwLmNFIYi6FVB815mXBOTmqVyuqkz+Q7J2RrKyxnntFxybSTUX7iCqP9E5bvTqhPB01uW8SLEoNBRZi4gHE2jQAKijiXctXm8sjef94FFvhxx4JgLbBAC2XmwbKaBh23w3Jz49gsp/y9n9jiH3z7Za5d2ubK6jIXVpb4xve+g33hKcgstXqCFYq0/cBsu09bZowxhZJqxFpDfnmT7uYKg7uHxH6FMxaJBjQSgJNHB/jKUt0+pZN1QYZknYxQTohRCB5OjgOxk7FSdBmHitSxnzY8gxBowlNRrBXG7xwjzcBnATAOOR7T/+abGOu490++DVisyynfGNK92MNmDn80IAQYPjzlR//4O1wJWUNYTAoD1cjZUkbvszeY7pzhHg1wURGTwi1bNcU0ZECazbkdIvxhDyQ2ZdbW+C0kRcvZnGiFqvbkRZ6UlDqkP9N2+j3G6eZjDoT60ZCw28dbwU4j4sBPK6z31BeX6V2/RC/PcB2LLTKmf3W7ITLNQXoFFBlxdYnszPDOb32NzOQMOhUEZfvFp3H7A/jLHyAoWfNuFRfXKJ67BN97j+7GKmE8ApKyN7tm1XNyRVLNtK4x9RLVs1t0B4L6iKCzsnWbDNY2FsxrSYlcp/x6K0JYXuLqSs6d/gM6Y+He//ptNmKGVcdWvsSVG2uo97hMCCK8+/CY0a0DpE4EvR0eLs3rvfBdLbDAh2NBsBZYoIE0qkREUQ3QFLRKX1NUjptHj/jB+ip5d5Ws6HI6LhnUJc8++wxvE+iJIccmL5ImXSbpM7HpXGtKTBpJOpWwd+sOVahwlTC6s5dG2Gik6HV5/okbHD7a4+nrlyg2C87e2U/kz2XYFUPc7uHePaSzvUb2k9vU332AFXDWzXw4NBERpk3jRHEq+CioiSAWWS+QjQI5HhBzQ3HxOsXTFxndvs/K1VV6K5vEizmyO+L0u2/hItidCWa1ILtUMLl9hJLjY2Rcluw5JT8+5MKoptvp4mhS0ltDNJoaCkiE6HzYsj5W3orSxFv4xis1d4zKe8ypYkllxfFwQJHliDTO/dlDff9Dbjo4oxKiwQUQm6ETn84VIPuXP01phemSENZyLjxzhbOXb9IjB5MOaH0gdiyj4RkrWyusj/v0blxn+2SEcRa9dBG1Xc4+f4nN45rhN94EYyk6OUvXNin1IevPX+Lk0UPsSUuImkHZc/MHRdJ7Ugdh4+d/mqM3brL8ySvUt3+ADEbNulnE6OwbhHM16ZycRiJhf8DwbEAVIoPpGHt1g5VL63x+80mOv3ML44Wd3WMIgdAMwRZRVi9uIdbgXKAuw0wjnDUyLEqDCyzwoVgQrAUWaNFwEEHQADEqq0YoxVBNK3rLq7wy8dTdDrvTirGpWI45letAGDMNFdNJhQ0pOT2mgz224UVVfIgYl6IBjHWs2oy6mkBQkNQlNpCS8ctvYsQx3T8l3g4YLEah9DV4pff2Mc7k+PGYeDIhi4nKGTnXg2Z+q6hok39lgWBSvEBUJWaRG19+hms8g22yoqahxq6+gOl1qI9OCW8eEivlxvNPk6shxIhMa872zjCSQ3IkkecFuzsH3LhyifroPmY6xWQFnas51U6FkJLek0ojDQmVFPOApA6DRu2yxmAvLlPtnCYfVkM7QozkT60iu1PKqkrmdk15X0ZarTA5qhqr1Qd8QkHMY6RPSGNhogj8zrcoa08VPB7DOzplwxRE1+aZCT5G3FOXkVdvs3c6gNGY+t4jpicTpJtx+tYtWF3j4qUXMS7dpxPB7wwY/d7L5Max8/K7OATJMrK2U/H9ZEVBYupqlTt72NMJ9YMzYvBMp57Nv3mVwff2EG1XslneuawHTckMOBE2tjaptnLGr9+jt9Ihd5b6zX2MD3hjqdY7XPrMs/R/cBtzMmRS1UQC09Mas7IEPYFRjcYwI3SPh+gu1KwFFmixIFgLLNBAU7YBEgWrigk1v3Hjk/w3D+/ykh1za3jII5kgWY56T46lDhHNC3yocC5D6xI1ESs1iXS8/yRJwfG+xq0tsTqxTKtAp+g2HX8Ru9bFfGKD8J33UM1mM/KkqelZFawR6GUp8ygoo9d3WVteZViOUyxEc67k326VNKAxaZtGMTJiOP1nb6IRzsohXgMus6gI9WiaCJ8VovdIVIwacKkrTayklHYjiKYcpxCVjZOKejREogdrCcEzPvRk0qEtXNrNFYpNiztLMQxRBIcSSEGi2s0Y/PAu4eEAMbDxseuMXt9Nik6E4vIa+mgfpxYJiokGUyd/VDRC5ix0C9QHQlXODOTazGdsZmCfQ4CYyCe9DsXFHnapwL/+kPy5i8iP9hty1TyJANNX75BVyoo1DJ1h5ekttp+ydC6v8egPX+N4qcP6eo9Ot8dQlMLl5MsOHVUoBmsEFcFLTARSzi9lpmJpo6xmhtEfvYStIuWP7mJDoMgsp3/2iKzpcm0tZob3e7AU2yioIRdO/8Y2/vY9ekcTjg+GjMYlPiQiPpHAqQzIs0jVtWz/Wz/N+Hs3Cf0JemMFt1bgvv+QzNlkzG/Vx8cWcoEFFoAFwVpggcchqZwVxDAU4T+8+xqTtR5F6JEZoChwWQecx9oMjYEYfTODL2BNSromNIGMTb6TNBtf65GJGMqdM7Y2VlnZ6BJ8IjuYlNckx3D92WexFggRRPDBY7VRpyKYCE2MJDbCYX8AYolzm15bJpyRC4VoGkWDFI9gXSqzredLjMoSY23a7F1IkQ7LGVlfMRs5PlboxKQZh20JUtKonJSv5bnyxY8z+Par5Ne3WC4Lop9Q9kvE1hgjKQyzyKjWcs6+/zDNNAzQ/ewT5Ne2CTZgUTaf/DzqUskvCKx86qnUaWgdoYpw7Tqrwachy9Mq5Vy5RNbsygoP3r7D07/wBe7/t79B5lOn5SwUYVYyndNcRNGoqA2YByeEMlAAnbePIcvRmVE+edrykNZx0smQKfidIfsPj4mrObUB6Q8pv/ISg2GZ8qZcMtFPu4Z8ImRiE7GydsaIZtqjatMtmZRGXckY9QR7+wz75evw3V0kOpw7N/XPz06MsYnooOWOSco7WrPs/s8vU5AxzJSltWXW/s5n2PuDH1KeTJGzEv/H96hrZTlP61qfDIlGWX59h7OqZHtpBWsNmTbvyfuaExZYYIGEBcFaYIEG7ZYrAj5zjKox756N0eMzYlNyqaApt+msvX/mG5Jk5jZEtoLFaTOjrelwa0mOAojivXK2N6A6nTI4G5FnGThLXU2QzFBPPWNTk2NZXVlmOp0itUE6hmpS0el0mJYVLBuoArnNyMUmj5dGrLTZTwKS8q9me7BhTtUhpaQHKKzDWYcnkGXJfE0ZwVl0EsiNw7s0xsY0pSGhqexZIWaW8bfegqMxS1+8wdlLt7E2zURMakfKshrf2iG+E+mY1KVG9Bxctnzjn/4BOqlSWStApgJGmdaRMxtwYiij4rKcifqUkZU5+tMphc2oYiBTg+sYLv/886x99et8bqtLePeQ1aKgm3XaImXTWdhwG0mEJhjodbt0fnYD/fYenI7PS8dWGtKTktw1sxTPb6BvPGB5Y5Wl568SH5zgrl7i+vZl3JVtho92Ob59j8mdfYIPXLArmKCYblKwKolMYn1uTp/zzqWwVCHb6DF+dwe7YjG9gvoP75J380TkG22yLYOmwd4ffLMFiBp54so217/wHIW3+LJmfDiEOxVLTz6FPllRxoiNEVWIGrh27Qn6L06wdaAeTdkqa4wqflKitiGojSq7IFgLLPA4FgRrgQXmYETACf7wiPx6Fx2OIQom1KhJZhajgIaGZKUA0hTNlLKyogElpLEupimnzebcpVpObL7zNyjOpU47kynGRHSjh5lMkczRe2aJ6e0pxMj61iqjoxEr28uc7g/oZA4TU6K8GsGaNH8QVUKMRCLGJjphNJEs2u69JHxBEz1gRDAYrFicc4lIuKSchdYzpe39NhEFLXkD1CpWhc7AU0kki46zl97FNuXINMalaVucdTga1Dabsskw1nPtJ29Q7p+w82iXOhouX7zE3/o3/h5f+93fIgtDfu5zL/BPvvEKf/tLT/Otd/b40oV13hqP2eptcN0F/o8He/z9z3yMf/i918hO+mTHHYIFr8qgmqIRlrICY21DPg2qsSnDJqIyPR3DW41xabWLZEJ1MiGfi4c3GGId6Xxik87NffoHfU6++Roo+JsPePCj++l90TSvscjSO3I2GeOMQWIKVqUJBjUIdq4IiZyXM/u3d/EaKVxOvLHKyY/OWPOOKDGpnq2G1aqVTep7u86iNOqbofrhPcqXPIMQUl5anuOmkX45YbPXY+inbBQZh+MxdISH730ToyaZ5CUNdDbNqCJtu26ZN7ovPFgLLNBiQbAWWKBBmyQQRJFX3mXluKZazehWiu7vg7OARQ1gLdYaYtu5VXuoPWICBRnG12hYThEIhA/6fZpwSgRkOYezUSIiVnD9CtPNkoRzoDgjdLOC8nRIx+aEsUcCaLPBWjXp2lSaob9pw9YmFsIayFYKfGiHPJ832mnT7YikTrMmNQFjUvq5GINpusnaDjejMY1wacIqoZ3fqBRqcdEQnGkIpGCswZg0U3DWxiftQjRfb5WA8r0/ex3bdayudxj0p5xVff7oK7/J/skp0yD83p+8ircZv/f9d5gaw1cGQ7wB5BijSimWf/jDVzkMJTuvP+JXX/wC1ckjTGOqjxoJMWCbcqEPUzZ+5ZNkTpkcDRi/9IhgLON3+83lJZJqgyJz/1qqgFjD4Cu3yEzOStHBh5RsHkhZZdKoYu0woES4TVNSTWVBQxugaj7QjZcaFEBUyLB4HHJzwOMhDO97h2ljE5LNv11mbXLZxAiFyQjWEKNQ5sJ6zOlKxDlDnjmsWMRGzFKOGQloxIrDhZieY3NtM6+XnJcHFyrWAgucY0GwFlhgBpltcrUJ/P0Hhv7mKa8VStHrkkbKpPJgNqmRXoFOp/jpFDsuYa1D0Mh/sCdcKQ29MEym+fa/WQRBGg8jJs20K0uPcYIRS+4cUxvJrCWK0slyShSLYnE4a8hdB289zlmkhmKpoI41lIJ1tjHBm9ntKDA5GRA0oEZRr+1OnMpMKlQEgsaUTyXp2lpSNBtx046dCWk0T7vPJyuYEppNvI2FUBTjbKOstYUqaBPUjeiMLBgxybfmHM7As09c5vU37vHM5jbvPTxmEGte3Nrm0zeu89uvvMq/8+In+crtW/zrLzzHayenrJKxurbCH959l1978Yv8l6/+EdezjCWXM/KenBRJoXL+jEXAmYzDP3iN4CuWblxMXrLNVcL0mOgDIiZleNn3zShs63CSqOyyLSipE63RZk4lbYOBNKGq54GnbfxCeyG2KVfOBkrPp7GjqDXUaxnxp67T0yeJX3/rsfc2xvQ8LJI8eA3akndnw1AeNc9NFWssXYVOnjMux2Q2EWlixDmHFYeJFkExmWPj4jLH90/TFAJNals7guij0vIXWODHHQuCtcACH0AENfTw/CeDLv9ZHHK9X/LpoynOpQ1srJFoDFONDDNlbAz1XprjdslbumoRl8zQQiI86bt+adShVLrBWdxUsUUvKRyuUTlM+tqiyPCZT8qRTaUZsUIuzSZHRHxMRIakGLk2m8AqlYl0vEWmnmlVpdTwkPK4TLORqwBVSMnvs7KnwTafS2rPedSBtY0VW5l5zDAp/d6urzCppsiwxKpgNI3nUYlpUDOk0ptpylbpyInvqW2GOQvZmgMj9OsJdVURovDmyQk/Oj1gguF/v/kGYxP5zR+9QZDUIZfvQmkyvnLvDSqgnyfCOoyeYJRcZ46l2ZNO95chuaGoDSWK7p0ikBRKGrVGbfq6mXGtNWal41hj6EqO19h016WPt2dqzzvzrDWdjGLmIlbbeI2WgLar05aST2q4uY+cDrFqz++BAAjaM/jSN2XCpIxpQ5riaEKUJawwM+CpifQ+8QT3/uKvuCAF0QhFt4vxBimhazIkUzS3VJKRZQV5N8N2BI3ASJqqbzqPNeaxtV1ggR93LAjWAgvMoVVr0IBiuFpF/oszQ1UZpnTxPoI11JWnHS3syIk+4IkQFOcEaxq1Z6ZY0PzfjHxpiFZbanEmdcvFOmJNUqq8VepJnQYeR8jF4sTijKUEnEuBpqYWci+ITenx2Y0tRg8O6cUCE8LsvhBJHYkewrJgRqlW2PKFZLJuf5+UjnbzRGaaTJMDkI5q1dL93FOEn7mB+b/Ze7NYS64rTe9be+8Yzjl3yHtznpgkk6RIUSJZKtUgSNVSl1rlrnYXGm4YdhtoD29+8IthwA2/+bEe7TcbBmwYcNtlw267qtvdUFVJXVKpqJmiRJEUxUwy5+nOw5kiYu+9/LAjzjmZJD0/lc6fIHK458TZsSMu479r/ev/qwl5mbMWQSpPbEmkUaXe2ae3b3EukYdH33sHW7dtq3bvIyBB8CqMRzW+itSVB8CEwMuXL3Cu3+evbt7k7119nv/h5nv821df5C/397lsAMl4c7LH3/mNX+eNr/9TDqsxjUY0xPk1WNwLSNUcJTmcj6aYGNq9iO20Z2tpMe9rLtwrnSSrJRgiWHFz+wJIZCnGhQm/jmC1RE/o+rRzwX178EhklgFglPx4ikw9YVphbDsRqUnLJmKRtVUOjh+Q47Ak64xIqlYFP8Da9G8SoRGf3Pxrz9XVkwxHQ7CGIsLKSo9sdEC/yGhijbdCmWXUBph4fKXECGVWJuIvsiRWSyzxMVgSrCWW6CBKl8nSKYtAWCkHHAeI6pFoMLkhVg1qSRUaowSnDNRi1/tUxyNcy6hkgWB1VSyiti2hRK7srC0nEA0u01TBsgatIrlziAjOpuqOn1btMRXrkui4e9A3qsj2OAnvrcWfLchv10wuZJitCb7yiMnxazlyPCXT5MUk0SQD0lYcbdt8u6iBFEfctr2kE1SnLVMbeWj3+VZvj6w0RIk0eKSfvm5xFIUy2dnmlT+bcKYYYJ0hbylG5wQe8WSZY3W1YDgeMz6qUQOF5IgOCaLc2dvjw50d9n3NP739IYd14E8+vM5OjNxv2327seHPf/oma2r5rKxT0ZE8w4zlQiKPrQ7LxMC1VeXRiyepxxPyvOBkEK7+7B7GJL8nMfI4v5In4mi6Xmz3ZxZePhPUP/76drbvCS8pWfhtYSIwdsSQlhCa2esV8FaZ/I2nOB6eZTwZMviL91mdGvpFmapN7T1Ca9haXDpBcaoHWUbx4gX6kiqbghIiXH7qDBhto3GSc/7m+U1G7z9AD6fJbyxGrHXtvbfUXy2xxJNYEqwllljA4sNx8XGRZQ6aiJGIKRyjqZLbDOllWBxZPyfsHJFNGwrrCMJsgk47jQ2kisNiu7CbqGsrAaat8NRNNZvWmlW6TJp4s6ad4orgTNsqarlPsVLgv3SF1ROb5IdTNM8ofk1ZG+QwHSPDKUWvx2o4Sf2Zijxzre7KzAxNMamaFeqAkcjUVxy9/Qjd8/O4Gk0vFDVkn17BnTugIOm21LjuMGQYjI3oBwXRj6jtlAEF4lw6SFsJExWKIuPySsnLf/c3+f53fsrVKxuYtYK9+4EYDefPneHM2VN89yc/4ysvvcz/9rOf8LXXXuPbv7jG1VPrmLLPWw/u8Vpvgx+GO/wkTHlKp9gQZ4HKqaGmaGsbIQqKcMcJbxw9Ilae6XbD7x5WnA6GnvQoVWYESUTa93wytJ3SjLMpvsffMC9mJQd7Wm1WN5U3I2vtTTizQWgrXsr8/e0poSHwIFO2sz690yWD8haxrf49qZEKRuHeMf7OMWAR7zuLenxbNbNRiDFVMsWBD6lNaTMLLmPxhHS2KGWZS7jEEnMsCdYSS3wEbYVmoepQFHma+lJopoG+LSl6OWZ9AMcVo71jSpthWyLmiVg3nwwzJF2MtH2qZMq52EKcf00EcpdRBZ9adqYjYp2lQjt9ZuxC66ldaITaCaNv/Iy94TH5ep/B1GPynLxJj7/QyxkoeAXnMhpfY31EQkS9oia19TQoopGAJ9W3nqSdgmjENnb+lahoK/JWkku5tali12jEB8HbVg8104JHVIXxZMLdrSMO/+In7B2OyfKc3f2ao1DRWNg9OODuzhZH04rvffBLJlPPX/7s5+w0FcfjQ3pFzn4T+K5sMTCWPEK0yZVf2jVFTZFBYpOoPrbxOidzw/PRgA/084KTNlCHmsLGT7hD5t09hMcqVIlIR8gMselSJ1uSpBBDRMWQOVpB+nxPjUrbGpxbNixOaprFz+hYmKRrWYjlqc2SutfgO43fk51NbVvgkpzbjVE0LrQ5W/E6RpLJrSb7D6VO5qVKazWic368cO2XNawllphjSbCWWKKDLvj6MG8RgpK5jJAFMhFMMIgKtlLYGmL6OVkAm6cx9xA9UZUMi+2O0gmAZpDHKhmz/9q2kXWGxqT2Y/KvatdHJDg7Mw19PNhXoJ9jxgGxGZdffYncRrL3d9OUWXqSUl08yWE/kB8HxmVN76lLjP7J26y++gLluTX8wyPcagYhQNVQ700It/YWumttm1AVsDQxYsQms9FOjTN7kCexvtNWY9aOLwYfcdLVlaSd0LS4Bi5tnmM4/JBnz6yxP5rwCGFghJ51nOutMq09r5y/xL3DQ65euUB97xHn+gNyk7O3+4DX1s/z3s4Dyq4FqcmbrF1W+4cAMYnurbX0XniWK0+fYXv3ASsnLzL+6XVO/OgtNASC0da09Qmu0i19IVS5K+ZEA+XJjOGdMcb1WoGVoHkkuzDA3xiiJsNdHOA/3ENNhnWe0FfiYZvRuKDH6owwjHQxPzJrU6qmatMf/zd/yuagTz1oeO3uMZuDszNt1OMEUNCY/h7bElnXxo4dnZuVKmPKrPSxbQna2TGSHK8lZmtZmlBcUqwllphhSbCWWOIjaHVY2j1olBBasbUxqfriUqsoOaYDAi5z5HlBU3fZcu04/mPalJYpLbRtZgSs/bJIemBKy1C6SbPkC+qg0dnXOpjW+NG6nHjyFKMv5Jz96R7UNY14YggzMXLv9j67a4HJj25BbhnzPoOyx/GHtxi+HzEhYj99nvCL+6gz9DdXPqIhonWkNxrxTZhZNIimoGvt9o/0cC+x7dRjel8URdcsRdHHH05wSVlOZZSt/QOmHj7YPkBDugZ5v+BoVEFU/DRwb28fEy27O/uMplOGwZDlgeAD1453ia14P8pH8yBVBAY55qihoy79Exvsrqyxka2ihSMLiqhjEjxBpwyKsp3qk4Ut0Mf+rC1J6cxo/VGDxoW2niimEfQgEFEk1OjYtbonDx7isWBip3Vj4fPSvkreZgCyEFWkkQLh931BdRhpYs7JbLU1IZ23HTu922J7b0E61v5dZmW5KEpbxMI5h/fzluPCbqb7dRraducSSyzRYUmwlliiQyd9UcWe6VEfjHFN8jACyGxrGWltciWPQIC8yMmcRaISJhXWGogkL6kZwXqilbeAKO0UH3MyJkFx1s4rCouLjEKe57PqBMzXLVHRkae4egbeOkiGpCFNj82kQE6wzhFPryMuVURMXhB8SGLwKDTvPsKYnNyDfzR9bBx/9pmSPs+Y5EfR/UqVMtqKW9uKshFHaPeyFfkPPdXxcSJCXhAf0SiEQih6GUWZMWlqzJHw9EvPs3XtJoeTGrWGKkjyqTIZREMdAmhF9MraRp+1vTKdbLsWWdhEUSXsTxBr04CAGMo//Tm9z15kp6jxG2ucevCQLgopagC0bSfO8wxnV8QZojOgMZHgWtEYyNUxbiLYNCggEomA9YKPSTdljhqCV/ABNaBRENu2Dk2qlEpM5LW/tsJoOGmrctoS2ETgrAjP9zaJl9c4vvEQjKTpU0n3jKpCLmgzbyvSEWCZRwYZYwghzCcu2xa1+o+2SjuuJgJ4SGYZSyyxRIclwVpiiRYC7ewc1FvHmAjBOOwTpCgJ1A1iFMESRjWlzcnEYkzKAsTaJGZn7mcEXbVqrt0BkjdU+6CS2UoSQetaRU/yMnmy9NDGvkhriumtgrFpKrCtNokqnXHm4MIm8fxpTGYY3n+ErK2SW8dKf5Wjh4/YeOocxjma4SF6Yx9/a39OrtoHuwG8AXcUeXprAz2ocNZwJA170pB5CKVBLDBp2hBsIEsP9SCm7XQlDyUNyWX9wtlTHE9H9DYHFL7P/vaIt777Fl/6/MtUkwp9tM25E+tcu3OL86c3eTA8Zn1llSIvKA4P6Q0GmIxECtpooMfCkB/bRwgGVtb6nJcea2sbbIXIapOihqy6tuXJ7PcnhdzFiRV6p9YI1iZSk1sOnj3L9PQKvZ1D6kkg1jWmNBjraErFBEtTN3gc0aQpTslKGg1EBawQrTIxQiNgyh7Pb22j/8v3EWfnovfZvZvWNDkekRsLmXlMr2XLjImf4NQtFsXmbV+YufuLebKslXzR4mO5m/P7cCGVh/9z+f8SS/xqYUmwllhiEe2TwpERJaQGUqQV9cps2qozjEyCc9vaJaQnlpV5nAg8QY60ezCmjLqZMFhaXYwAJia/IhGyGFP0itgnn3ltG671qpp9ThIu989tJK8jSaLujhSoBkQjk6199n/8Pme+8Aqj775PvbFOearg+O4IK5Hp+3dxtdDDtXE5cy3PPPMukZbim/d46TuOzBh8meFDwP3Oy0zevQNnBgy3dsnOX2LIHhojPkaCBKx0gulOAJ6Od+2XN9jdP2Q8HRO1tVIwhmsf3AKEydGIW+YBEcuHd+8wndbsyj7l1OGjcv/hQ6rDCb3VPiH4VGX7pAqigotKfWmDw7/xAn0NbBwcUfRLjKR8RXlsn7vzn5ONZvuQeiUjNjXNzV1Km/OHu7epTpXcOlJ+faXg29PIcFzhYsOXLmzw7igQisj9SeRrNuNbLjCZNnzlmaf41rUPUlUKx6t2zEknbLHKf7wyYNUHChWMlVkbWmeMXdkYprggL+Fx+tUEbNd2nksLZ/mS3d6E4FNu5IJ4P0UcaXvv8kSjtN1E7aqwSyyxRIclwVpiiRZtsQcQQgiUX/ss8WhEfHhAcXqF6BvGb93HiptNpXVK7m4aMB1HZ/YLT6J7jVkpOfW3X+PhP/8B+ShS0zD47FkOf75FeX4FHVWYY8GfLMkE/E5DarjRaY9n02DzcpiiomQ+EP70Gjaz1DESCa2TVcqUEwwUGeu/9woEWPnKi5hQs3b5IvaLQh09xamTZFtD1AFGGf/pNRj55A7eVT00jfS7CDJpaGJAXjhHfG+b4x+8STioCccF9e4+ozem5GJQURrf4JhbUnQHNDg0Ki9+8WWyn1/nzJV1th4eMz3YRlHOnFplUFg+qBuefeo0j3YPeebpc9S39zi9niEhcP/gmGdOrvPmBzfok6E+psk9BTsL3F6oKIpQqxKPhlTHI3Z29jjz9EXUWaIKyf/LYK1FQ7fP8lj0j26uUBrHyE+h1cvlYljf2OD+eI/tGOk3NZIpNIHnhhXfVtAGVrLIC+tr/HhySOMypvUI5xy5zYmm4Ygeh3XNU+uGslEOJ1NWC4eYkgw7I87dGUUW/NY6vg6tDUcK/pb2B4E0FZvCvIVWP0cKdpa21JruN22PPB8AeVKSN78xlzqsJZbosCRYSyzxBISkt8qHYw7e+CWyLVTuPuUXLyc/pfZhMm87JXIzExJ3x3mCZHVfU1Vi5dn7q3eJhxXTJKsiG4XkoH5vjLGWEBryPY/LM6oQsPajDzCRLnuuFVgZ8E5wv9iiqmtUAtOqIumekhGo+Ej9wyHN2DNuaowq1mQc2O1knCowMYq4gjw2iBVMkSdhtlnQIM3Or80ULCzrXzzHo62Kla9usvcnN8ifWcWf8pjveWzr54UKTQzYaHFtNE4y0TQ4Z/j+6z9nfHDM9oNjfKwRawk+sD+c8vDhlKn3XL/xiBAs1z7cYng0Ylr36LUX762b9zj/9FNcOL+ODwHTZTPqnAd0xqGmjbYZ3LzHuf/8fU7HSN3UOOdwucOpYG2KyXHOLniYpb6YiqDDCj+sCfUUQQhG2DyxwulTKxxMpkRrefHsGmdXVvnOcMw/1siGcRQKz2ysctMY/qY7xbVHj7hY9olnT3DYeDbydarRiJ5EpI4QIw2RqW+w1s4ilbq7Nt0dLYns6J8IUcGJIhIB+2RJNV0/TROEQSK2zNBxmN1S6TK3wwJdu1kWMxMXBfRLLLFEhyXBWmKJBbSzcUSN2DJPaX+9pK1yYmli92CWhQfV/3VjZJFcCYI0kWZ/nLyFDEiMNPsVTQ15oXj1xBARZ8gAQkRNsmew2raHmD/kuqEzUwdsr6D4g1+DsmL/r97h9JdeZTKsmX7/Ov3PvYiK4LJItX1AVmZs/9EPyWyJVYslYrM8tccAMQVRktWCQWcTgnNqlSAiZBh2/+pdwo0Rox+MsXtD/BsV1sYUEty9ywgBaNrJRkcSiPsIE19zfJxyDCtCmooMHiVy8eQGcsqzezDkxRev8I1v/pQvvHKeH//iEes9ZTAo2H1/xNe+8BL/3dff4Jd3d9n88quJgKpiH1MtJUF2cqkyRAy9PMM3DdgMgyEzhsw4rDGE0Flwzp35IRE1W1p6X7xC/fpNmuEUUWU89Xzn3Ts45yhWAmFqiGvCxX5J7iu2d6ZsXHmK0C95e3uLtbLggyrw1fObXB9PuTuqud8c8trDfUIF9zZq+trjMCraBk9/9K7TZBLbVtq6nMnOqkJ13kqO0WM1VRRDG/NTbg6YHh5iozKNEWtNOymbfgAAFvIju8vZ9gZTH3VZv1piiQUsCdYSS3SQdtquZ5FJJGaGOFGiUZzJcM4hmSNowzz4t60cLFSvPl5MLXNypW0EiijZuVXqh8eoGN7ZUNitGawU1KXl4MY+L7gNCqf4qBgNZNERzLwF2QX6atsubA7HNH/+NtMIq1+4yO6PbvPoR7ep1bPucvwHW+jUk188gb19gB+FNBBZVmiMaSKvrsicxVlH1k6idQ/YTtw+bxYxJ3gSCNsRa3NOPn+RB3cqznz+Eltv3qGyTdJYQZvZl44Tg9KYkLIWV05x+uXn6B8fsH1wSOYccVzhRMhczk9/eSt5b0W4f+8IjOFP/uJdBOEeio8ewfCP//g7lGsneOYffpWnnOB/eCNV/8TMmnuL/0VJgwj9smTqBFuD2NRqc2JoR/EeiySaXVcEXwWqa1s04wpUicbTH+S89sw53rx2jc3iJJsn1hE8xd4ef/D80/zx3vtc++XbfBBAreGRKJdHwjt332dro8EEh5rIpf4Kk7Lmcj/CgW9blpaZEWmnC5wNMHQVqWRWqis5dtIQL+ZU+4F8P5BfOUV+0nDwkwcU507QNyXTm0eELKDRUY99mvJspwrrcQUkc9HH7vW2Na0SsGcGNFtjiMtJwiWW6LAkWEss0UI1jcf3vnIJ/Ze3kDoSXzqFfecAu5bD06fwd/eQrYYgnat10rIk66K2TTIbtpsLoRcn8PTsCWzm6F84R3Ohx93X32Y/jth2nvEz61gLZqVPiMqo3+er/8bfpP7D/5WV9VXiOUXeUzCxFSG3B51psATZH2EaoXrwkP4E/OWSOPCY96YY7/Aamb7/AKcZuCRQss7BVJgSyDCEACFGYnRkWZc3Zx7fsE5pT7JsiM6y9sIG0zv7jN7cxR5FZN8zKHtE1yDtfhhtnehnZE0JVlh/eMi/8/u/R1M1jCdTQiZU05reyZP4yRjEQOYIVYVRwYcaZ1tHe0CJBFFwkUwNejDm8Ouvg8kQY3BiZ7mPT0JEkQhnf/McD79/n8wVs0GG+eRcV8ZZEPuTLsXw5iESEv0JIXB7OuHhBw84GMP1Ow+p7u3ircFow3d/sEeQrPUFgxgjEoUjpwwrw7lGeN94nArjwyGjMvJwf4pkJxOJYj7g0FWOOlKlameDFB7FDGsCirkzIdYVIVqaO/uMtgOilnBvRLA2KayMIYSIkXk8U0KaZk0B04t7JqgGKHKKz/Rpvj6iWcrcl1hihiXBWmKJFk4hiwXyjQf4YXJMl+u7VKt9Vl68guxFtu5ucy5bSfobFFlxeB8xo0D+bJ/qzghXOsLYty28uTRFEbSp+cXf/w1+PjymrhqmTOGrLxBUMWKxwXB7fIRdWWH8aXjm+nt8+u5DRuMKv6cM3AouhkQ20hEf075obFt5mSE/WWJdRnZhEx7sEq3DNJEMBckQUSKC28hZO51zfKPBRKX87bOEuw313X2cU/RsgWxVrU5KZsRKFp6lCsg0UP3FHmIg3D4gx1Bf38ePJvRcF7WT2o2z+pEIGhOxHb/xC/bf/DnT0FCNPaVzRDFsrRTkwxFxUpOv9GgmU9QHBkXBaFAw3TuksHmyQJhMKDZW0eOKfK1HqAO5WJxJ+inbekt1a+7iZwSDWjj86QFFVs5MYqGbpDM8qa/rKjkBz+bVdYZbY8ZHU/Jg6aH81uZJ/qKuUOfIBZoYKSSDwnFh/5Arh1N+dOUsW1VkFZhay/1BQ91Wp3xbcXNZq39y6ZrRWiNo27qVUyU69uAjofKpqirpnEQhGoPmQrZmkIeBmkhwgo2KlpbcZkynDVp5FNr0gfm5GrHzi93qsizJlV+wmCYQDpoUi4T9/+NbcYkl/lpgSbCWWKKFmozi+bOIE9y4JjuxwcbzT2MvnWb8xg2KVy8wePkSWivm1j5RDHbckCnUGpFphVFlfDyicMW8utM9q1SJCkc721y+sMH/fu+Y49EErSMTlyEBisNjjtf6+GYIYhi89wA5+TR1bGhGkeZWw0pZkGuRxOGLmhigS6zTUqnv17jMEH66TYbgLaBtg29WjIgwjEwnASVgjaF5a5c49UgUJj4gJWRRWx0VCxW6J9CJxxWyLENVcS5VQ7qKVUcGF9fcRQRLsBiJrG+eYK/awxmLzS3NwZD+oOTYe3LnEGtSjmLZZzwa0V9ZIdQVkoFrLJIZpOdQUXJjyV2GlZTbmEK1P1qVWqxqWWs/QqYeC3t+4rStWiafOQOv306moApFbPjM6ZN87/Ydrk6nnBr0+cZwyis1POor3pUcuIb1CFvG8w92S/7rjQm1zdmTgEQhGqU2EQqHaSw22JknWufFFjOhsMLx/og8y5I5KS0pBIIFsQbTKNlqSTRjYgm9jQGToyNs6Yg+ok5Ql4EZoy4nmpimDGMyL5u1JNtKraRE8FTb8mDLgkxd+illiSWWAJYEa4klZqhzy/C3X+SeH7Iz3kXCPnzmJPgAX7qEhoB9/hIXnZAfVpR7FcErWWbJiIzvJhf3zLhWb9WxmFar0upWit4AjxCmgTCuqYlI1rmhdx0fIYoQXIZOpoQITiONCFMfcXisZI+J3VPlIv3d1BDeO6TIC5oYMNEjmrdtpKSTUdXk3G7A5IKZGKwVgjEIGcZGECVcO8LYDDdzXO1KWB/dQ5mN6yd9mLEtoYkt+YLHKkMpWBicKsEIvY01gmnICkM0MHA5tW3IMWRlQX/QZ3h2ADd36DnLUJUSwzg39E6t0QyrZKwQhTwriEGxrWO7VUPX5fzYCc/O2sB8vFT7I3FBdJUspfpnN5C6AUnRztELf/bW24gG9nLhiAbnMkY9S0+EZnoMU89+rLFq+a82xkQV9h0oBi+KjZHjjYyiqVAn9EOOkBp23USfU6FupmltZk7+RAzewuDvvIrdPYZosVYJV5OkTGzD2rMXUuqAhuTirkLz0hmK0tFEiNMKLQLH372PVPM7GYUQA4PfepEid8jUI5dXcZ8pWH31hY//5lpiiV9BLAnWEku0qMWy/2jK5LWz/Og4Y1L2MapMvaFqxihQ5JYvf+9DnptUxOmEwghFbw0fI0aTN1TbQyFKTLYO2k37pa9bhWn0xBgQNeTGYq0Dkpi9m/iKEgmk+Jogmqa+tLW7NNJWKSxKXBC7tyQmtq/TmKwQcEgMBNppMiG1fSJ0Fg4pWNoiIWKswYjDdtUnMa0RqtCVUT5pYkxbMTQRgkmtQWM++rpuUKCzbrAi1PsjyvNrOHUpwscFnBisGIooUFW4SnEY1EBubSIJYtHDKeZoQnl5gzCs03RmS6yMGKyZt/Ye88JKiwE0xcJ8DJGCjx9eSHttMBqJKmQxQ9Xjmil/f/0y/+XBe1y8chpV5cN6xEpWcmtyyNrZ0xysVawOSi49VH73nQH/xZeH/PtXnuZ/vP6Au82ELzJGsoJxCGzUlupivyWBIZEiyVKI915sK4Zp740IMYVZcvzNd6mGY2IvY7pzRIVP11HBYYgKtY+IDwQLGcrmqRM044rS5hSDvM1GTOdqFYIIaiC7eIo3Y40Eg9mpyU6dQO884sTnX/rkb7IllvgVwpJgLbFEi/LyCs07DdOVgteee4WNbIX9Zsq3728TdoRam7ZZokQRGgMOYTqZ4oocsUIMAVVPE0LyT1Kdy1disgpoYuTW3X2M95zb3+XhyhrFiRXG9RjVkMiYxmQFERVxrXBZOs/2OTonbm11V2ikCYoLpFLFQviytQYJQjSxzThM1ZfEBy22V2KaiLHpfc7Y2dTgk6Rk5pEEiXB1LGXOv2YEzhiLtvl2HwudTyJmKji15Fg0RsyJHmbY4IwlMxarQm6UKBaDwUXIjaNX1TgL0VmsWKJJpEzFzNuC3a9FnwkeJ06fRK5mE6Af8zp59jTZmsNOmrRmcXz5XJ8bfsjfunwFDdB4uNpfoZDAM3lGfSzEAHFSgwkcvBT5N7fgaOsDvkYADIV3aJhy7tIVPnf6Ijf+6Jtk7dK9xkSo2/vCmPm0o5IkeqJK7QNalkT1bJxdJ88ciEl+XrlFnaPxkXJjhVjk3P7xOxiXvLyCVWi0NU+d+7x12np85C9fuYxKsjxtQuD3nznLy59wmZdY4lcNS4K1xBIt1Ncciechymgc2XH7DOvAqi04l2VcPHOKbz7YImhNbQUXI2otUcFXFSqQZS7Fq1jXjsrTCsITEQrOMirh3qOGXzvXY7U8Q3HhCt/54dtMfSDTSNM01N6TaY5vJwWjSX5Frm07xvYppx3TIU3PuTVHWAlU707IXQFAWBFkFChfucDwjfu4zKW2oSpYxUeT4nAqj9hWvN0GVXcRM3NjSZixk9YeYlHsTmsPkF4lSO1TiPPsLQt5dk9egNk/JMepDIPfm5Ibiwi4NoKoKHOq1lXemtQwK8QmrVGWEw+nOOcwJlVouvMwmBTYbASJ7eSjGCSkao+Q7Cg+0sKcndvjAwUd/M4RNvYYH9ckJ7GG5/eGnDcRrT1Ijkq6VxSS44EYEMFITFVFMTN3eE1Jl0QMxhRMfnyPw4sP4HCK7bduXqrExY1v74Xk0zXfa0vk+MEeqpGVT53j7p1HbK5vUrgMqSKRmrqp+cWbb1H87RdY6SuhVqJG6ujJbUbO/HjpQsb2Hok4ybH9knPrq+wej5KOa4kllgCWBGuJJWYojMEVPXyWs1r2yG1kd3JMFoXbw4ZRtYvPAsYkV+1kYt3FvaQKwtT7ZFtpDahJo/JGkNASpRi4kBVUOYShcLBygp37j3j56XPc3TukyhzPnz/L+zdv8an92/zMBly0iOmcuufTb61/+kyTIx7CUWR8e0gWbapexYgZ9Kj2DlnPGg7DlKwYQIi4Xsbq6RW2b+ym80GxpNZgivt5fH9kcQGPabDmeX1RFNtmKqqk6lm3T+kYn6RvYkbLOjIkVsEL1rm2xSdYLDoJ5NaRWYeVFGMTnUt2DYUjeo+xDoshGIORRLLiaoE0EapA5SJCpPAt0eqm4qJJGZRP2Dl8nLi9QzyeUoXAZDxlEAzBB+o1S7ZqGd05au2iUlWqK0B2blw+HWE2ANG1TSOCmDSRN8CQX91kLGlqT42ANWRREAuajLzSCOliZQ4haiBKoGnJ4ma5gmnXYAuLqGHFFZR5zuCdA6rtMf0Ta7MLHjUSdR4cTXcLxOTqH42AGvZGE8aVp/mkTVpiiV9BfIwyYoklfjVhtwLjYcXU11xZ7xGaKj3UnfDZ587z2RevUvaKNqSZ1tgxVZMUwFr4W6/R/O6nGb64weSEY9rUTJvOHUiTc3vjWe2XvHjuLJOpcD8K/+6/9q/w1a98jtHZks+9/Bz3y4KglklmCUYerxK1mLnDt/aTElJVARUkGiRYvPfIwxoX4PBHexAytBLUW/yRZ//GAY2P+JhCre2sndZ5nX8CPuZBakSg7wipp9gSlK6lNP/12GEWiJfStrxMquNI28qyNlkspJgag8GSOQdC0o6hOJfhjElTdK0dAzFp07rPdK9eQF9Yx69mrP3ey/SeO4NaUrD2qsVcdUTXfPzJPXn6T5iNFmPPmro0+Wgt7rAm3ppQOkcvc5Q2p7SGnrOUzpBbS24thbXk1lFkGXnmUsUoy8hcRibJxd8YKLNeIuodsY2R8YUB8fOXCM+tE0PoaO5j62tioNKAJya9Fcq9ySEjX+M+dYbymQ3UJA+z6mxGDAohEtuWaEw/FaBRZ0MaXWsSk+59ZxyiSmbThOcSSyyRsKxgLbFEh8EKkmd4Fe4eHfHhuGYy8RTGcn3rCHuppDACJhCaihCVIKFt5li2qimjn1zj4N5D1tbXOFHVFDFQWEeMEYNgFeRwxMFogt/5kPHZkxwMA3/8k19wffcRNx6M+e/D2xzsHwJQmdRGktavaVa9aqtFDlKrKSjDy2s8+sKLiG8QAWuFWgKZWEIdySz4GAAw1lCIxaG4CFVhORhOMHXg0o9u4I8aTB1SS02emBqcaa7SnzsVmKggkzDz9Jr5U3Rvn3cWZ1iMEEKFICFV07qJw9Z2gNaLajaXaQw0nswmrZYY02qLBEwyFPVNSO/vPKveuoNZNVSPjpjsHhIeHJI1ijnbp39hldGdPSS45DX1BB47lSd0WtK1SiWFQ7vMYlyJ+AZip5rrpjcf13uZBcrZNU5VU8Er/8ILhC88w/io4qdhm/svn+JYLD4YVmq4JAV2a59XX32K6fVtejFNSaZ2bmoVGmOoLThJlbWpRHrGUViHuX1ENO30oVeqI6UcFBgBZ80sWkitSeYfsbv0aShCDUQrDBultJEjH//vcNMllviVwZJgLbFEi7qsMW3LxWjDxZUBN5ohVhyvXDpN3s9TNQUhxEjtG6zLMNHSEHjwO1f4xbl1XP4sj96/xt/97gE2K+i3AdGqEASwFrGW4zynGk240u/z609dIKvG9C9mrJcFU6dkdWo7RpnXkmbhuq3EPCpYURDl4OoF/rOfvU+UgPdTnAo5ES9C9B6c4+rpDR4cHjEQx24pnF0p+NnBhDXreHm9ZM+W/Kd5icaKqGkKsnMMn8UDdWtBiVGwRoGUa5eJI2rDTEk+6zNG5k3Aj4Gk4/VOnaA5mhA0RcK42TnrjKAtVsGyPJ8J0Nt+aYIRHHauo5IUUZSd2qC5OUZ8IPkNQP6pDQ6+e4+mCYgVXExeWB1ao/QUxN2udUa4BBYT+Gbu7iJkLkvTfOlf5l5aCyc9q/fogogcwQwcP3r1FK9//c+pguH1jU0ObYaNIX2oiZg8pyfKf/KjO3wuRDyRzMzNbRVh8wuf5vDHbzO8t0sdlQufepZyfQVEiUYSwVaD+eB9dG+M1J7+2gYDl8KtrbVJ5C4Q64ZYNWn4gmQnkYgvZC5HGo8uk3KWWGKGJcFaYokWU69EA1WoOBpV7EzH1MFT2j57leGZsiGzMjNaFLH4NpC5UEOsAsFaTObo9YoUlOsDmspMbWtRiUXO1n7FtyYNVW0Jgwn/6H/6JxhbYK2llMiEFDiMm09wQSdq79o13coFT8QWPVZRXnPwocmJznFupY/t5+RR+d7eCNfPcVs1vz0t+KtLDb87mPL2HrwQxvwH6vjDDG5dv0nfOk5kfSBixdCp1OdTdBA1wqkcdhVjIlEkWQDQERDFlEIcMms7fhISQRLi/hgfwkLVJwA2+XtJWwXTJ8xV2wlElbTHtvWEeHI60J1Yh4MpRd7HVzXqI1WoyKYNbiXH/85pyl3Fv34HNQuttm6fdbYNc53/4qbMP43k5Sqw4ADfucEbffzVslDaM8agEfKyZFQrK1OH9FdZPzXA9gb42LaAVbC+4lJvBbN9SOU9vcs54WHAtoMKJipb3/0Fx9s7EIVjGzgsh7hHu/jTfcqxIqcHTI8nmFrorTm894zGY2of071oHIVLPmJpsYagEcksEiPqDBIajBECScu2xBJLJCwJ1hJLtJCoWAPVwRE/320YEzl7eoMsi9jJlHFZUoqSCygea1PbJMaGWjLs3T1OTcfkqpw4OqA2kTUMoW3nSfs0lhh5FDMelganilZCKAeARzSADynGxmSELAMb23iXdqrPzKtYnXbJqBBM5FPqefjeLSb9FW6dXeVNGzCTjIBBM+HeqIJzm3xABM24tl1h+j1+GXL+o1Hghdww8g0SAn2TUZisjV2ZG5qKdJNqQjOqcSYjttE9MflWptahgeAEg0fFJhG5PK7EWmy3dWTFOZce1WJhFr2SxhX1Y8hV92WNCj4i1i6QKwVtQ5pjpDmu8Mcj6qaPPWqIQQjOwrhhuuvJJsxyJbsYn9n6Fu0nug9lTsJmGrL22rTRyPPKW2fZYQQTIZj0P+Bu+k/b0piiYIWJRK7/61/jNwrHP1hzmLVNpA7kWUYdKo6i5dsfXCded5BnNIdJL2WNRWKny2toQippvfSP/oCH24fs/OnbjGPNyjOX2PjUGSbViAf/4h1O/MPPs/Pf/oAq1oybhiJmYANCnqKGRLoITKgabAhYAyaLnM0dd8Y1EsL/u2++JZb4a4glwVpiiRb+uMYcQf+8o8Fz+ewmq33H1nBMGRomozFllnywpCUGWWukaRVO3Txk4+YRtW+oTYN1OZE08o62REEsITM82xPqKvJQDP0cztfCLc1T6yoTVBvMCEQiNhOSFXo6xGKrqfPBSgiIqynF8B/uVbx3+jRfX+1xM1r61nLcBC6GwJmtMaJJEO5NJK+PmDaR1zeE11hFYiQYYeobXG6xmsTki9BWd+TKAX5VsDtVCsA2qVUYFdzFdcLWEamE95jwKk1fLnpJtR1FVRIZbaOQBW2n5BTELMi4NZmfLkTY2Na2YXGNHTUkBmpfI84SrLBy7iTNgyHh7iGh8nhV+h9OyDeEcbe7T2jF5lYVj1dpFs/DArUGNHO41Zxqb4KJitq0tqABImTWgoJXxXXtzbbxa9qNqFCsy7nZ1Oy9e4+a+2m6cG1APRoyylcYH2zzbJlBryDsHiJZTq4tuQJigN5nLuHfecgHf/Q9/Kihee8hmy8/xfDb7+F/dIM6BHJT0PvjXyLDKdLvzUjwR6Y+26WqaecgH+0zsjnvIrgmYOuGJZZYImFJsJZYosVk9xjZ3UH/59e54BqmNewZg+Y5UyM0zpKfXSdr0mg6GhAjiWRFYe2lZ9hZg82Lp6mkxv3ZL2BYp5aQkoTboqg1fKre4viwZm/lNFklNKMxn1bHyX1PEQWJnvXcpYqQSSTHtA7ps4m7mdtn2z5UyLBUXnjr5TPIeMydIUyyglfOnuP0asHBpOYnJ3cIxqFGcTby6z/f5lNj4bvrMZ1bC6+RJngyl8/+bV4xEoyCe6rH4cGU3rnVJIqOEUOBeekc09c/wFZJM2Qwj733ScTWqV7Wc6pLa4RfPsDUrYZq0xGOPM4rMnBQKRri4+t5AjNypWDWcsrfehab54RxxcrVAGMlfOpp5BmPLw3Fa6uIGMaTLbxGnJrH1vlYZqHC4lindBotFFs6vjG5TT9m9LIBdw+3+J3V83x3/x6v/tor3Ln+Pruh4asnP8UPr7/LS/3TnCvXkNbaQkQgRiLJ0kOicDPkTHun6Q0GXDy1wcruLsOtfU6vOW7GDHyDH42JRMxiyU2EuvaceuEpJhMhXN8lWyswLhK3DykDcFSju8fkqz22dg6pfCD3bYSSMheg0ZFVbecdLL31kn/rz3+CQ6kAauXy6jp8bunkvsQSsCRYSywxw+ZnzvDSVo+XL/86IRokz/H7I0BpNJJfPsPo4AgVz/633sNkjiTetogx9POSEyf6nFjfwJjI1vQtrM4n/7o2V4yB/aHhxbNrrI0PmFZCEE/VH7GTedKjEm7UJe7Agp0bf7aFDj46jQYxRLIYmETL66fWuF2PKVdWOVX2GGvg/sGER82Y89mAh02FRHhufY2SHU4GiCIUKkhs9VAhzlzfu8+BtloUUxUjBqUXHWbioQmYEGlWHG5niK1pw6h1VrVaxJOmo7UGTrz8NLx5Gx8LzDlLeFBhTyjV9oS4ssbJ37nI8Tduz6wp0nsXZePM1ggQY8R+6Rl2v/VzrBb0Tp2G1lGfJhBaryctHDv7h2y+kGHUtBUgeUx8/rg1w/xP2rZQzWaPfFIjHnoxY7MecD1GTN7DG1iRPnUDq/1ViqLEupw7owMKsaxlZfIga/dJFJqYqoTV/hHHD3fIzp9j/cJ5Nns5zzz7FI/GU4JP8UepbWvaO62t7oXI4Mp57v3JjwkxEGNsW6WGentMjCn8GoFKKnLnWClWsGLJcsHYZHeqOm+BAqld7YRqa5/q2iO0KIknS8qg5NNlBWuJJTosCdYSS7Tw79zn6I/eIDs9QPIMPbPG5Mfv4GOkyh3rX36ZnT97gwxD7txcRxSTs/X0p9fxseZRq+XCGMQlG4FuXCxaeHkcePr5l2E8oSgtMUJG2fpXWTJlFpcTT44Z37hLrhaxnQ6raw+25EpMSzc0ZeKJoNaytn6CYSMMA2hdc9IJ++OKOowI9RTE8tO9Q06dWeGHGxW2qshyg6hg1KBtVl2MEV0w3pQAwShWoeytc3T/AdmZ08itA6anV9m4eonRzbvI5XX8rX3UmPRo7khK6xv2ePVJsEZofnyTUDpkWtHEiIlCjGCDxRxMOfzmPVwUGh+wzs6qeYvHeYzGtWJ8t3kaVxrK3oA4qdDGE6cNPgZqAvmZDe4YYWXi8U2N2CJlIX6kQjZTVqW/LVgt6MmS7afPUrx+zOaVK3ByhcFwh/rl85R7hr1TJb0TG2x86jnuxcD62nNcuHyWyT99i8wY+iafHdcAQSOW5FDvfUOI4KOyvbvL1oMH1JsnkJhIsHaTkmJmgnRjDKdsydnXPjvTplE4fN5OL+amFe2nqJ3Or7QjlC4oO3fv4e8dMh/PlLnpal3TjCYMJxWXXn2e4Q/fIbt85v/Bd9wSS/z1xpJgLbFEC2Mgs4I+fwL2h0zeuI585gL8/D722XNMd/bST/Wd4FdIDzNVogSw4LBgtdUtde2kLsNNyVxG+LO38L2K8Ts79PKC4+FRMjEY5MShp3d2wHh3mMTKYsDQBhqbtuKQ2nNzJpEqHiIpyy8GiGKJ2YCD6YSrecE9Hxj5hsYIfuIJ4waoUJPxiAmCsjrogaa2pHREQrpKTjfCB7rZ59S/+nmO/tkPCS7DPHuJzOVkDydw9hSSF5y4+gwhG3G7mTC4P0GNwXb6ncWl03WiElEZr5bkoynTacQ+CIhYdK+dKRRweMDifUheW1YQWfCXkrkYvROcZ8EwlYxyvUd25xhpAgFlqDXDT5+gKB3mTsPUNCiGoGB9gNw+sdL2I2ZlxMU6lqDX96k31/AYHr59C3f5JNpEbr93g/sPPuT54gQHewf4ezdZLQfsPHqEHVdshEi0SmNSzFDSYMWZaWxe19ijfTh3HqeC2BwvOWDTnlpt/cJaokSaVFRjmG7tooVl/+EexjmaaY1bKWmOppiexTcB0yg2z/AxpDavGEQ0mexawZo0oGCRpK8zqfo33huxfvUsW7+8y8N/+T0K4Oita5z58uf+v38zLrHEXwMsCdYSS7QQbPpB/fY2OmwwWeTU33uN+48OiHnArK5gTXoAJoIl87YdiVBlbc6dAYxK8gxqKzjdK5uDET01xKJgsLHKOEygCgxePku8fkAoTAqPjiQDzW59YtrP7/7eEp5OHyORUkwK6pWkoVrrF3gbIYAEy+m+Y28y5AjP1UGPm5OKKI4TxvLKS1cxd3Zx7aSfWyuRzEENGuZhx4Nfe46fb99g+JsnaeIY3wTQhvhKjtS7xOE2xoPNSprfusCVb1yjf6yIuNk04hwL+XlBISihCmgMYLJEONYN9W5EAgg5alPVMMSAtczE6Kk49sTxJRG3OCip19fx72zhUYSIyRxma4w8u4GRlEcYRYgxoGrn4vWZK326Sz6KtP9WDWd+fJ/t/bucsgOmv9hmtx6yaqfEoLz7/TeI1nB47R65Sa26M9s16oq0+KiznEIT0v3irOHZz3yWp64+k1zWmxH1Wo8qO4+KZbpzH2MkGX+292V3bwSNOHFEa8nzDCRFB2WZI7rkkE9QTAYusxCT9kpI1a9kONq66Hd70N3vThj+5C5RkmB/5fPPUr1zexbvs8QSSywJ1hJLzGCMYq2h+M0LTN7dJh8p+7/cR6+chkqQzLUtmNZnqK0azFqFGtsA4uQdZWLns5lUWIGIa3UvcqAUqxkMMnpHOU1U/FaFmSrl5QHxoE4HXfgsSB5PtrM6mBVtWrdwGyijgCupfSTPS46PjznKHQWBAwcxCE8XA/Yf7nNpo8eHo8iVTOifPsloOEY0puMbWFkpaCZTfAO5Tb5eAhwfHfHT/W2+/8qnaXKHb6b8Rlny1dM51SRSB59MR4G3b9znQoCm8Vhju5LYQpWJxEY3V5DSIUZwp9eJo2mqTuGgn1E+vYbXiO3l4CNuI8cCOvXoUYNbGPp7zGldLIjFSIOun4B/7ytsf+cHhGHFxR3oP6zwjx7iz5ygbv2lkv9obCclzbwa9gmCetpLHIg4r5zM+mzkKzSZorvCyRPr3NgZsrm+itSBwzjh/OYGH2zvYDJL5meLpRPmKwZXOq7983+RPt8a/P/B3psFyZad13nfv/c+J8ea7zzfntEAGgAbBECiSQKkKIlh2bJDZtiMkMOWHYrwg4fQg+cXOxx+sjzowaFwOIKkZVMK0bI4yDRBEiAxEWgADfTc93b3vX3HqlvzkPMZ9v79sM/JrOpuUpCsJyBXxO3uW5WVefJkZp9V61//Wr4kLkQqaIzukIawJxmJE9RFMoRUvYoa1ajEOKQsMe0mJoujWCeCsUIwUaEyxmJjdGilhFVbmSciL4553KpgM6tKx6WUN7egOPkLwRxz/LhjTrDmmKOGEax1ZLcP8IVHEkG/ehObZ2hiKe8XpCKz4mFjMVUlCYlgF1MoQYJw+b/6FRTD3svvsvbERTZ+/0Xy779HsBozigQMDpsFnLe41MJ+jiaOxn4gV4vaKpySqEgY4gq/RXCmVhqkGq8FbCMhKR2aCmqVO5u7nGo22N8/orAK3uAtvHtwSCLCnYM+adKksCW7u9vkB8pHOqsxtNOX6MSTToTURuIT6+eib+eJjz3Lu9ee5srlVe72JjxS5TfFcbQwoVSlLAOXevtclC2KrKD0ii9LrEuQykSmMXkhRl6kCdp22E4TnrlA62GPIglRyRFHsJ5WkpAfZhgNtC5eZPtLP2D12cuMvnMXscmU6p5QsDRE27dRets9/GRE6ZoMJOfV6ykmh24qLKwu0B6NoZ9N87qOTwHr7K8T2tu0CxJK9SRffBJ7mBG+dptTn3+eoXjGb93h/Cc/TvLtAVc//hzr9+9x4fFl2p1F5KXXWbp+Ff/ivVm2WDWJzUPOX7h6ldbWmGbTcTTJ6RFYXl0gGRcEsdhGQqe1wLNdMLe/DmJiuIXW3rE4kDU2VjnZ1GKM4BqCdw7xQjNJUR8LyevacGMqUj/NLKuOTWfnYnoORDDOQuaxYuNYfI455gDmBGuOOWYQwZhA+W4fWxnX/TgjUcVkk2jSdgnWRI9KrB02sWPOK+FoTPAC1vH23/ktgoN8kLH14huYvR6GQEOjAmUQyjzgFwUxgjUOcRCC0mq3GPXGsSOO6qpejWasMlPP6nFNRQZaSyuI2aSNYS8Enr9ynqYz3N7aQYH7fkw5HvE/tk/xJd3jc588za/fPOJvfP5Zvn/zPl/b3CO0Yr+hxVTjnvLY9l89kvSITbHGUeTwM1fP8I07j+j7SUwwV3AiJI1GJDeBmPId4jZhbc4XhJBYVn/hOQ6+8ir57TGTsx3Ssy3cq+ts/cIl/KMjJFMW3xuTPdGFlx7R3gvIL10kHE3Y/eo7NFNHMOFkFMT0JRXQAjRhsCIc9HtsfnaFjVcPcZ++SJoskLkJayOh8f1NgvfMTvlMJYxPXKcLnMdJnBdIFLK3HuGHOcZZyn6ffJAx2thj399EjOC3dymKMf5WYOD3KB8dsOMTzlUjOFu9popiM8/K//Ql/sqnrpI0Fjh8613KjQPO/fXP8Ogfv419co1Js8Tf2scUgXA4xjXS6hxM385xYcGa6P3LShJjMI0GzuRIVaDtNcTnU433TGS9mGO5Y9N3wHQsHb9okOgNrK4kZq5gzTHHFHOCNcccFWJVr+KMwZu4fZaEatNKonkYpTK3R69MzLcyhKCEUjCiMYl9Yz+GhAal2D0AVRriYrlurSyIieZkUxnXiaMXa2282Fo7NcpP2wdlRrBQptUqkjgWf/CAzhc+ztJvfYM/3DlgvL1PYWuiFKLa5QN/OzxipMo3v3sPcQ3+9h+8iCJo0kB9jiGQJCl+kk3/BzFNKNd4Lrw1EAJpw2ERllOHhpyUBrd7PYxJCFail8pHp1WQOJIyUzVEaS62Ofzy96AfordstU2rYWNEweEQk5eEYaA1CbQ2PNtrKe5gyHKnyTAvsGrxZaAUjzOV+mKOHXOIm5tpkbB+eMSBhVPLp3kv8XQzT7/VorBKIgVnSPAmixlnddZYXXNznFjEO5++b2yA0gluZ0yhnqRU7n73dbppkyIbYdYP2eGA++OER4M9mply2bRJFw32KEMkmWZp1SXXQRTbK2g8fY3JWw8IvT6JMYgDc66Jn0xILy9R/uABySAHcbhKeZoqbWEWk2atIIXHGovfG2GdiUsCIqiJz0+0JpU1w1RKgfTaMv724YkQ15p5xbeDOUbA/gV8EOeY40cEc4I1xxw1qmBFkTiGEwxqohdHjKH2U8uxP/UFzIggVvEaaP700ywsNDFimKjiFjscvnaL4s37BBTVgFVDkIBTEDWo0VgNI4qxjqSqqAEqwjBbj5+FXsbvm6qMV996yNNZxoWf+gh/yViwCSoVbQxxNAkBfBnNzF6xJYSiJMlBCmjtDti1KY1mC1MGrHGY6bOtYAVvLUpBb1JgkwQNMMgDR7sbjJOEZtNSHMuqmsVUxrqb+pLsXULr888x+MYNjDNQKGVRMDjtaK1PkIUljtZydssG7d6E4qPL9N87pE30IhmAUBJIT3qvpkesUHjkVJMLnzjL0gS27jzAI3QbC9x7dJcnfvI6pw495Dm0GqiEWdej1MdfpffXRKR6KK1PTVBGC7AoXa74NczVM4T3Ngkd5czCKZ7dGXCtsUi7UBqn21zJU0q/RwvBBYMxJw3qqBKcIb99H79/RDIooNmgLQkXnjnL3ivrtPdLBp0WMg4kSdVdeXw6ioJ6NIBe6GDWBwRDNdauy7MNiAdnMEWVnC8BsZWH0Ah2b0TdDql6bGPzA/rWHHPMcRxzgjXHHB8GjeMPRWqn+jQfqEYdjRBnRgHUYBUWP3EFLpzFFoHJ3h6y1EW3tpA3ievu9f1onX4wS/E2mMp0HEc10xDLSj04HvYZr+2zHCirAu9u0317g/4wp5fnhBBIUktRBrSMF0xEsdaiBELpAY9JLK3FLuNxAcYSygJnHaYaG8nUkR6VNu+EEAKDcdyQCyFQhoAxhqwssUHRYKbG+Fr9qhPWa3bYwNDaH9PPcihjPU6z2WI3y9g6t8hKmaPr+2Rpm85IyRZSbKIk3TSSNxWaj63RFMtkYxCDOnV2bgKKsQlmPK4KuDPCy+usNnNWjgY8/7U3Kd97xPJHn+A6HdKNXXIz80NNn3vtGVPFixJSsEW1dVdtlnYvnabY7nExXSA/8OTe0k6WadqETz72GHZvwmVpg3eoL7m6dBoGIxrE2A/MTCGLJMsQbm1Q3uoh1mNC4M6vfQ039CSLLUbFI8zOEDc1tx/zjlVvUEFJRBgNJtFhFcC1UtznrjH+6jssfOYCve/ewZJSWs/qX3qagz++jfiSzrVzHL29jj3dQQ8miHLSn0bdhTnHHHN8GOYEa445/hzEcUntG6KSLKp5Tq2RVN80XnHXlsnevM/G3/ldilJjfUliCb4kSVJM5UGqL1BhUhKswVERKQWxAVPFC1A95Kxk+UOM3MRcrPpuDY5O22ASIc9zTCok1lI6pY5JSBsOHzylCKUoPniK4QSLRrOyxhHSccUsErmA9YrYGEx59fRqtR8pGOfoLLYpJiVe66z1OG5SPLPi5oiAkvuS9pMXafSHZA+2MWUMUbg66HD1jQGZOEZBmWQD2oc5F75TsiugoVKvRMl2BgSx01Ryan96rTIlCWZVsBsHNPKc01cvsZL0CQ3LwdllSiz2qMeTCy3sxEWFZxofWp3tUJU3GwgdR/r4KVjvEXZHaGwIpHx7Cw1gvKddZFiXsiAWyQu6Ex+FLmchU4IYmocFAYs1DmdOFlSLgvWKNpQkMXhR7EKLxnKLYmcfm3skQGktWDs9Vq39VJU5XRHEpdh8NmLWrCD7xk0oIX9tE1ldIMkCOvL0v3kXWwZC4hGTRXFLDYM8RxZTrCghC1NVU6kY9AlVa4455oA5wZpjjhP44Cr+sYsenPhtfVqhoqBBsI+v0ri2yOGXb9BwLRIXYp+cD2TGxlRyYpRD0OhFKvvjGOxYj8wkYE1tsq4S1GvXNdNDOeF1EZjW2UAcKTo1dNIGqVi8U6Cs9TgUxViDMYrxhkbDxW6/MnqAnDU4sbG65UNKnq3Y6XTo1qM9mm6VzCuFQCdJefT2bVYvX0YteEpqg5FqPW6tjlPBGcP+l79F9mgUC5FXOgRjKX1JUGGyUPJoq0ezmZCfsrheTmkNYpJIJgyYHMTUMQqz4a0SPWrjL7+Jfewsiw8PsEYoteTnFYa3H2KSRYxPKd8YkhwOCXkGEmY+pNmLXak1AYYl5WubmFLr+XDFXDR2U+JQlBRXhXMKTSNgYvp/CJHk5qFEsVXu2PRhQGNtUdCSxZ+4yMGNG4iNmWqmkyKLa5Q39un8lccY/MZbSKjCFabHe4zsVG8LKzEZXjEUoayy2TyiQm99m3R5BQmBojcidU380Yj90RZWHW5coiGwcHEVOWvpf3Mddfb4R+PYY8/1rDnmqDEnWHPM8T6EaoNwOg6sVqY+7NIRowsi/Vq4tMLWH93AWUcqENQAluRiF2sysof9igTM1vvrmAcxlWqiigSLCQ5mPGamxsRDmRKq6XHWXqF6hEgMPrWJIySWwASrsU4HDTgbjfk4Ba+UXuOoqQ4zlTpvSzmhmQkxX8nGBPtRr0fvqIkx0EwSFtMEJjlXljuYQR9TbQ7OSOLx5LB4VlOalC6nFCUNQm6Ug/4OuARWWrSvLDA+6GHOLJONBmTLS6h3BBdJjdHqXo8pfFApfyhkJcWNdcZ4XOYx1jAucvxCk2zviNaZFfqbuzjTILQalfl7dp/1eVcn2OtncQcj0sUu6gPjyRC33UfDjGVUlYBYE0e+qhprAqoXUUy8b1sZ1Fy1zYcyM5orSGLov7iB2ARnAgwL9F4PlgwSlMH/ex/r0xm5UTnOeaqDDmC08uIpqh7XTJiMJlT6JK1WC1ElNC1hVIINFACnm+iDDIJHsezefIh56CAF60O1aRpJ3DQnbM6v5phjivlO7RxzVFCil6j6S7WWr8e8Q++7/YmvCYlXbBLVDCPRuIwVktMLhEERe+VkNr6Buig4/jyitD53heavfJLG507T+vwZvPoPDl2OPew0i0n1xPFofewSNxtTa0itJbWWhk1IE4c1FmctqU1ouARnLM4YrMQ/Ux2k8h5J9d+u/p4YLp5ZxlqPTZTcK3ujjC9++mMsNRI0CIlOre21hasiXJHsFc6gn71EGTy+vj4XwMVzJMMCxoK2HcY4Rvt9xBe03n5A2R9jq2yu6uxNh3onx5pgQ+x1bDcbNFNHgqGh0F3ukhSeJCtpW0PSTNA8OxbgevI111bK6X/3FzC/9AyNf+mjLPy152n9G59Gzi8QkA+8R44fy8nxLtVmn53GbUwnbRWCRPVNNoY4VymOIriGxd87wniL288q5Y4TReC1XU4BHwAVTKXo2QuL+HGGGId97iLZaExW5AQRJqMh3pcxb62Asl9ShhCXLwgkRsiOBhTjjKIsmW1ZRhJdv+fmmGOOiLmCNcccH4JQzz1mhqljBvPjF0NFMaCBEkVTi+RRPTEl2J84T7E7wPZ89YMnL7YzIqO4NGX48jpHr94jH0wIBto0UTurfzmhUPw5iFxmKmvhjEXNzDtmXYIvFVuN1o6v4NtaualzoGo5RKLtn0aCWmF5pYUsLNBTxSbgjJKIYbeM3YnLHUMSCqyXqRIX09HrnsNA04C/uRdHo1hSFYoypzUaM1JlcrrF4dv3keunaZRQ7vdwaToNPhWpzjXvU2+mZ6guQgabWIqJIb2+gNyY0GgnnP6pxyneOaDsdLHLHcJBr8o3OzkiVCD0xrz7n/waPV/QsA0EISkyWs5hTaM6prpSaPbzx+t7jv+7XlyoiVh8b518nU3FwOvxpDWx/DmKbMdjE2bv1bIU2heXSBc6BDxydon22S7NScAttihPr+CthW4b86kWtixYXOhiJ2Mk83S6HVx/hDYcduxpnmrQWW7StEKxd4jfGWKMjQrslBxWj+/ml5Q55qgx/zTMMUcNjTELhliZ4qU2hQPBVp6omVpkTH0ZDDF9exLDLiGWPZcrbXiwSzgocc7iglKiU7WhTmdHhMQlZOMJxgiJGpxtxFFcNYL5Yb3DqseIVe1Fmhrk6xtVNSgSfVizMNP6tsfUFyRu8tdChTW0zq9x8Cff5tS5c2R5Se7jplpHFaxBjQccWSthaWtC3cUs1cgxnl9D6+IKk90e/cMezthogRcoS092MKQ18Ixbi0gjYWByWtcuwlKC3xmw8Nhpdt9HWk6ch/r4VfCqdJ49xWh9gC1BnEOcZen8Mof3HqCJY0ESiv0haTC4JKmS8o+PMsGgSKtBisUlCUYMbt9jiB2LNeM7+VPVf53wc1XjtKDTaIYPfy1PKpKIiX49sfFPvcWnM39gKGHtF54mjAuGd3fRUcYkL7nZzbjx3gaesuJi1f0VSlAFH2ggVVk5pBiWui0mI8/io5RzFxfQYUm5e0hbLUn1vpRjix8SDCx1/+w35xxz/JhhTrDmmKNCrfoowJku9EfoxKPes/DTjzF88e5MbTDEXKnq+mhEGd14iClBjUFaDdrXO4xefoRzjThCsoI95lURIXbAGUOWTWJXH3G06IMh2JiKXvOfaKg3BOOpd/pn2VL1c6g9WfE7JjLCqPJoNFwbQlVCrVOPkGjt7zJT1eqk4b82ecPotXv88i++QHtpleJgjKWgHAwpE0PYGUCryeDRPqm1HLhFNooHiE2mI6UgihGleNQnBE8zbc7iG3xJ59pZms+PMVKQMOKxJ65izrbY2ehRPn6W0VaPza+/ivGK2uMkptICjxEOJKbSD9/cJRCtUMWDPuIsh69ukA0mkAeSdswti9mbs3NW56Kpgqx0+NT//O9z+x9+hc7FFdrPXuXO3/pV8BCIr211qog7hzI9LtXK1ycSPU3TNNSZj+6Ef+zE3xURg4pWiufMfzf9d5UyHxSK4SGH39zAOBNJ+vWzmO1Dfv7sJfqHA44OhzQXW5TDDJ0UhJbl1GMrbD/YJzcF+9mEO/0xjznY3d6laHV56lOXOXq4Qz6eIDbFuQRnk+p9V51vCWR7B//sH7w55vgRxZxgzTFHDSNxfCWCPxhQFAUNUpRA89wS+UITTIwoMCJkkwmNxQXy/gDj0hjWWEVr2qUuWgZMkk4v+KYau8XKHYuo0kgShqMhSZJMRy3jtmCkwGSWUMZCXa09WwrZ413cnQmJj+Mv0WNKRkUMaqO+BBNJU6VUiRJJVhBMUMRrVdCrMUKiFszep6zEMVwkeuU797l76wGtBUuRC74oGQ9GsNqid3sLe+08C74kG2fkR0Ns4sBUrquglYJTSWJGpllZKsCwZO83X2Ttsct4r7SNQ0yOKQ2rrQUMSzzan+B3xlWcAlF5k1jHY6aEhampPBBbt21FQkzpwVrCKEfUUJpoQlchpt7Xc8dqeaAWaeRwzJt/6+9SlCX9soxFzT6Ok41R0msrZHcOpmZzrRSm6dBPQTSgptouVKbJ7R9a8VOf+6l/Phy7RYCqGmhKTtVgXAkhVD2ZAeMMW9khfOQSv/sP/oijjmGvnHC+WGZvPMQGjwxT2HwQ3/vWghasXTvDvSJn8enTfOuddU595R26q20IQmlC9MxZGx+TKcVi7nKfY44Z5gRrjjkqDCYZW71+vFibEEM2wwDxyv3f+DJp2qXdMDROLyKlgg0EJrizLQajSaVOxJ9LiwHkJXlSIhkkxsWIA2PwqrQXO5TDjCLLcS6hDgyNi/SGYqlFOgxwVKCVDycotC4usfrEBYZ2nzQ4QjXSJFQRAvU22/llTFmCB0wgLwOSK1aIXp7EYYoJLoAcjRluHpJ3HOYoQ+o1uPeN3o6P3TqFoi7B9/qUWRnzqzYGLDda+J1DJiEQBJJmAxGIOeMxrbwmcccvxyox7cAqDN97xMHNe2gpdM4ukV5aoLzxgMZqwvAbr1A2oZE2I7kkkqHj9zM74Gp0VZEbrUayJWFmkA8x0FXETMd1prq/6RbhtCZISfZGOA3RRC5lTOYHLvzMUxy+fAcTiF434UO4hkavmTWEJYvu+HoyO4N8yI/VIz0MIqEicDNDP9NnWb9/LGgAKxgP2cGA8UKT8ytnOX25xadDyrWVFf7+D77DX//8C/y9r32H/+CFz/BP3nqXU50mqRre3t5mwTbIy4JELU3jKI76WAVXP369AaugGFTKmHY/xxxzAHOCNcccU+TB0/c5eRPWnjxD8+p19l+6gdiE9mKXh9+7iW0LX/gv/yrf/x/+EZMHhzTbKSyl6MYRk1MtxAiNzZLUCpIIiXF0mk1cWn3UNBqyxwf9uJFnY+bTzPhedRJuTyjGJal1Mf0dwXtYf+Eiv715yMK1DmIs3rgYv2Bi2Kixjol4DoYDvMRKG2egrLroSBM0JFAq6lZ47swCz3/pZS4/fp7Jnbs4TPTknPASzVShyBsCwRi619aYTMZ0ui2OipzmQRHHksaQBz9VcKbPW2Z1MAGddhLW3qzpKNNY7FqH9pVV2B5hzi1R7g1Y+kKXw60BTjXmWZmT9zmzjB+jhmKmipJADOxspsg4i5lf7QblIJuu3plqHmvqaZ9WY9fqHIgIIcSbBwM2cZx94QqHL96i7JWINbOdgPf7q6JFDZMHwmFebaxGVTN6+gzWOkbZmMQls3NfG8iP3V9d2zPdHq1eG5kqmqZ+s9FZbPM7L77EOSyjzQE3JmPWdzuM1fP733+Z0sKvfe97DEpYHxgSC3ko2JUMFxIsBV6U5/+jf5kf/He/SYOkOh/1+0HwHxPkrbjAMMccc0TMCdYcc9QIinYa6P6Qwd0DslHC5nubnHruMfplhiSWphd+7z/+u3QwOOvIspxya0IzTdFOSvfJJoOdbbi+QvJwjDeK9wGvHltV39S27DpGIV64640wwbabNFsNJuOj2CFoKj9VMPQmBf9PL+OsBi4vNikV1g96FJUiY0zgEwcHvNTp8Pxql/uDMa3NHqvDPkkuHJiEK60WX+lallJLO1vk8d0Dhu9scrazRI7iZtkRJyFM62kwwvj2Pmbg8aJ0EwPW4jXgxMRky+nPzTxDH4gsmI42YzQBEhPaDYb+xhHnWh1Gd3bpnlvj6PUDrAO8YgM0sNiqcBsnYA1Sjc1qMY/6fIug6jEI9lQHU3QoDvqkpxaZjLZIncWXplIZYzF1rDGKqqQEraZycfsvBE/j7BJnPn6WzS/fpMxd7FKsWGPtszMc2z5NDOPS09CA+BS0iN6qSi8LQaOPS08a3CFudgaNRntT6VRajYE/FFNPnWBL5drqAvJozIXLl7j76AEfOXWR9/p9fvbJx/nt197iF69c54/XN3nm1Ap5VjIwSlMSLi2kvHRvHQ2W7a+/CaFSrypCSuUrkxs+vn7+h/2wzTHHjz7mBGuOOSqULmHtX/8JspfWOXr1PVaX4PKZM5TrewRiSrkBzoolK0NUcgTwAeOE0fqAw/v7LJ9ZxF5qIesTEjGzjrnjvpr673Ls6yK480sMM0VtQM8tk23s08RFX5UErKScW0oR6ygKT6vb5dxam1HZYKAlxgm/uLjM3XGPtwcTtrKS1U7KYXuNILGq5e1JiaghLwqGISpJeQjsj3usNLrVZE1iFlN9vO8zYRMUOcxxxHX9UHisc2goYzH2cYLwPg5wIsagulmQqpzmdIe1U00m+0fYZ86S39qh+fQ5ii/fQr4ImgYa2o4DMfGAsvyzH4WGA2JpNhawFqygiSEYG/9PJ45SAqV6rKQQSkorpJ+7ghoTx5i1mqSKD4KGONJLGo7Jl15B9kaIQPr0aRaN8OD3boJxWFcrTMc2/2JzX6XkgfoSV49wnSKF4EPAShwbG4ndidRLB1J7q3Q6Tq3JaSTTMnttqvM8rcyRuOUa8AwzT5k4Mp8x7O0xyUre3N1GvPC9BxsUGvj+xg6T8YT3tvYoRMhtwHrD3jhl6HOCBN5+8W0WjhFPrR7bSMBXPjC5uvzP9qGbY44fYcwJ1hxzVMizMZv/x4v4UYG1nof33qPUgHrFoPjKV1TnWVkSGkEQa3FLHRazCX6hi9ma4L59iGlYTKV0iZhjRKp6wPd7bxqOU//5X2Pw/RsYLWh/5Cn2/otfI80D4gxGlFKEs90GzU6Lm1sD0tBnpdvGuITTqWOt2+W7bcvT5Rq9wwnLRcYaih9nHBlD2wQO+0MebA8ZeksQG1WZoJQhMC5z2i7BatUbeIw0TElWpc6ohuhhsmYaxWBqhUrjMsCHBbTWpvbjSo0hKiGapDTKgrTTZX+vh9sa075ccCQJjXsJ6QWHbAjGgpec7pk1jt59wO1X7kIo8HFHkgIlaMCjZBrIEQ4bnqL0BIXSWYKN1UWoQdSgNkTVS5V2M6UliuY5v/TkVd6+s84zz3+Mxv4Iq0L7rGPnTx4ixmIstTmtOmVSeZGOMUs1WCOIeoJRtJnCoCB5+hSTd3aiB6yTxLFhmAV2Vh3i1ZgwxPMMx7n6ie3JWR7W7A12trvAtdGYvfaE/c19ltsNPtVYYEN2+czyeR7t7/HZJy7x7fubXE5bDIox2mywLMo7u/uMRxNCN6qjcV+S6batAl4V+6mLDN5dZ/Tuox/mozbHHD8WmBOsOeaooEYp2o5TP/8Ym7//NmMdMyoLvAYKUbzxcVvKxM0pUUPi4Se/+FPsDw/Zfnef1uoa9lHO2qXTXHr2Goc37xCOMkBnm33T8Rgz74wqZlJw/7/+B2SLTcrBgP7vvY4ZTPBJI47tFLwxvLGxR6uREqyloEXR7+ONUpaBR7uH7I0zAvBXn3iM/OCQl4fjeP8CiwT+7aeeIrkY+F/eeA3FgLFTL09NSgx8aEbTNA5CFTVSRS7EqaFlpkSFP2M7rr6TD8QSUG0o3t3FKNgrCyx97nEmN74DpsAJ+HslSI5Za2Ft7ErUYYa02zSXmzjTQavg1Mx7Dg76uJblzHNXuP3KI37+3/o023c2+e4f32Tp6iLXP/MU3/7t7/GFT17gMFhefv09funxJ3h3MmJNLS88+SR/7xtf5g9v3+K0twzf3iCxTcQYyqMhYuw0nX6WiRYRKhIalps0njiPjnOcEbwvcAi+Icj5JWS1S9skmGZKPslpiqVRlJQtR+P0EqOvvQ0I0dGmFBQE9ZEAv//UVurSbBshGvaL8YSPfOon+PL6H3JoQIsJPxjtMTbKq4dbTAS+dec+u5MJY80oi4KOhTHQH08IPpD7AjTWWgdhSgBrFbJ/f4tx25E+du6H+7DNMcePAeYEa445KgTjoJ+x/4N7qDWsXLvEYpHTaLYoDoY452J9iTMYZzhoW7Zv3OXhi2/RGw4483NP8/DFd+mWwtF7jxjf2aLTTkkbTcTVwtfJq2J9oaq335K9PqwtME4c2Z0tjFaJAUHRUtGgfGRllV/+yBVanRXc3R2KR5v8p0WP1uCQnfYK1sQR1yt3bjPe2qLfXAEJlGr4z154ns9dukbSaHC4t82LeYnFVt6qijjVRxYCYswxf/XJY4+l1ZwwYJupIfvPP9fHieZ0xFWxzSBKKD0Hv/otFmwLa6uqFxPHrYmYmGYuBoOhs7xI6e8xLIZ4rwQDzUtLrJ46S5lAMfEkqefut24yGBcE6zjYPiL70iv4BL777gZZUPLE8OLeFgflmCNv0ZsTVpaWGGcFdlxS5AWT1NLC0Gx1GUgP6lHn+2DVUGYZrb/8aXqjjPylO+AM4Cl9wPi4tOA39hAElzSYDHpIiKb9BIN76wFtkmkMh0EoixJq0339HjqmEoqY2VaiRiO+WV7g1//336BvLcvNNkfZkINhj0LhjYNtFMN7gyNsMPTzCQZ4NJ7QyeDjT19gd7/PgJzVZ87h39iO79m6Fqd64zb3S3w+JinmJqw55qgxJ1hzzFGh2XQ0my3CQpdsdwcvSu+9dRaXVvD7fQoREFuNRmJx7lNXL9DfPWBhaZni3R0WQ+zxW/2JJzl1YZntN29R7pcU3pNYN92sm2YXSbVJGDzh8irpF57F7xzi7Artn73G4a/+6azM2QTyoOwOB9zZHXHv0Q6SefwpywsbsL2bMziV87CZEkS4O/SEdAkjCtbhNacbDIPhmI4FR8yjqmMT6iv2dA9PJG4UVs93JlrMgk3j36KMYYieJUwd8/BPx7RLsfpHPT5MOk1WFlaR0oMJMbzVEEdyVccjCsEKZR7g4iqd7Qm5UdR7dvfGlOUIoyXnP3aa/miE73dxp5ZZ2B5y6twKj11/jN/602/ymUtPsXl0wKtb6/zMJ57lpZffpLDw6vCQpNuhnRcQwJeBnuZI4giln56zDwhJChBY+jc/zjDvk94f0mp2yHsTkkKQTptMCobnG4z+eJN+N8ccZWRFwAaludxltAif/Yuf5/DrN2iUDvVxU3TUy5mZ1z68/5BQ2/sEE8CqcP30GfaM5bmzZ3jz3n3+wjMf55t33ubTZ89ya2+PT166xoPBAY2x52sP3uOTH32K/v6AdjelYcDvF/iGwVzskJdQ9gOtyqEXUNTHhPh8p/9Dve5zzPHjgDnBmmOO4+i2uPbLX+T2//pb7NzaZOXaVXrvPcSbgHqhlBIstMTRCobsqE9GQZIpw0xJrMWqof/OAyZ31klbDXzlb3JGp0ZlYDpvc0lCnns4GDJ+9R2yUUmZZWRFjlU3jRhQNfii4CDz/M7de3graFaQGMUNJpiVFi+MPV9baZJ4wSYgzah8YGHHj/n1W+/yy70+uwd7/Ob2JudPn8NK7FeeeqOmh/fBdHGoxSqt0smVOlAqiCCiJ5SVDx0Rvu9Lx29XPQKlFkzKnCTAwqkWY2fx012AuLFoqh7H0XjCcBVee7iBs5bgid44hOvdRQ76nkOEYtDH4DmQguHeLvcnQzIRXt+4z6DMcWK59+rb5OOMxCZc1gbZVi8qZs0GTddgUEwofEFZRiVJ3sewpNocDALDf/gWyb/yNIOyoPlEk6Rsw0vbhIMhPp8wvnWENyXtpEtuCrLrq7S3e2TjDIY5N373WzQmymKrTbPRiDliSrWp+EFydfJ1iselYpgAE5/TH8F284hHh3u8vvWA27ublOMBW1nGO4d7FIXHpY5MM97e2CIZjLjSuch4e4zdHzPeGiJJgksSfKOFTxWrMQ+rbCaEMiAu/TM+WHPM8eOHOcGaY44KJjGUm/u89d/8n9gUOkHJHjxCUNou4fIvfozxwy3W392hYxOaARrWQasLe55DGbGEwUogywvCRNBxILGG3Bc4M/M7xQ5CpunpBoFhht7cR853aErCUDISAYtFUcqWpX1lDb+xgcdyCuWCpGxkGXm7iS9L3gGWtwYULmdiUxIRDr3SYYJttnh9POD1zV1UAqhyEcWKQwhUe3zT+hOOjfCOC1LTgE6j+OCJCRNhqmTVBvY4LTw+vqqZyMyf9QECVvm5yltHMUvMCoOvbCJiqq5CwVgbtwQxGAkECey//JBhkhBUSUy14Ynw8uAAP9onSw2H44zL7Q7nO12KrOR82mFLjlhuJehI2dccvbDM6K0eSdNQliU7mrO8ssBBnnE+myAoPpSEUYmaGJ1RP10z9SZVuVvOMt45wjUb5K8cEkYjmstLDJ46hfnGDUoCBE846IPA7s8+wcWvvENjs4ezDfwwwyZNiuBJfEBsTGfXmuBO4yeOLSHUrxH1bQJnrpzFvlrSSVukaRMnTZ659Biv3LvLF699nK8+eJfLZ88xPhpyY+8RZ1ortIcBTRq89+o7oMJ526RpHA0sTanS7mPmKWKUZKI86B9xMR/9838A55jjRwxzgjXHHBW0UBrPXuKJv/xZXvvv/z6LH79GYZXBS7doWcvu1gbd3QHdliPPA3koaWWGgQssYMlF0BDrjEksjeuLpEcT/L4nBJ0Gitq4544S1/KtiRlIQvQaeVdi2x2c6SK3j6DKy3KjnCTPcRpYbqdsZgVPPn2ddu+Q7Y0NnCpfXD3HTrfJGyEnG05oizLWwKp0ySl4xjpeOxrhRSl8oHAWFY/o7NKsf46Hqi6DVon7ZFp5rkz9nFRjVMIJl9DsZ2EWJXD8a7NC6up7psq2EAWN/Yy1MmMlqllCmMYFpBo390ojFBiG6quxoqdrUvAlIUB/NKIhgkuaFM02Jhd80sBLETsnC0sBrCy00UnBmnp+8rmPQCdgvvRgmluRDwrEG9REYlpDJJZLiyqKod1usd8fx5ytZkLol2w/ucaFd5aQwyNyEzcxyxA483uvoYdjvEL3yTW6Kx3Ca0eRJoU4Jq30sWM+txnJqgu9fV2dVJFkGU3ISs+AMbfu3CNRw/dvvImQ8Ee33+Co38d0mqyvPyRptwhFyZ3xPq5haJQFZQJSBMKVNgvnz+DeOYwiWtVagBjCc2fJn7vOwuef+uf78M0xx48gzD/9JnPM8eMBnwp7N+9x5/e/h7YbZA97yKMhxgpOhFajwXDsaTVajHzBCM/IF3RMJ/5C78E+eQ7OLZAHjx8LXYmxkEGVoCfVoJn3SaebdYUI3WeeIH9jA/3TB1ixVb2MgIcky1hOA2cYEYqSW5uP6E8yXGkYB89XjfJ9X3BvMOAIZTcEJmK5K4FxKbw+tnxmrctKofzNYUFpPM5V2pUyNS0rSiGKVn2HIGiIxxuq67tSebSUaM72EEK9jTj79wfwvq9NN9I4dn5mMeFYJHYpGsEYiYXHFdGrK2ycxGJjjxKCcmZlkc88cYFPXL3Ip565QieNuVQ7oyHrwyH9YsxodERBYJxNGI5znEnRUvBGeWVzm+ZBwf18wD/6k6/z0h+8Slb51USAUtA/w2oWFwUEI1C4Ap3k6OkGiSpS5jReuk325GmMtbG8W30sEuoNY+G3c6TNDmGi1ch1RkjrtP/Z4+rU1D4b4cZzEhMdqq2/QlhdWuba5UuUwXP5uceY+Jznn/sUSwuLXLl4kaVWh2aprDQ7JNKgc/48zWaD0594nKIFOixp+5i0H0ej1S8FBka31rn9f/0pm99444f9uM0xx4885grWHHNUMGIoipIMz6lPf4xwf4N874DUOJLuAnJrQCtt8/DoCBMADEXhKXcOWUiamCJA6pGuwe0q23c3OXP1NIG8MnHPNgal+ntVjFN9TXFZSfk73yfVAC7FWDutgFFnyCc5mTQ4sG3UjpnkGWc7XTYk0Flo4063yIcTHr9whqycMMkm0WDlAwMvHLpAq9VlKxzw7U6K9yXWuFl0BNXYMmnQeuICk6M+6cBjTIzNtGE6BCRJE2xRIiZ60/IQB4WpsRR7+wQbR46hCtGcQuqS5lnVy8nIhppkVbcJTCeWAU+wIJrE6AqqqpzgUc1ZU4PXEp+N8cMGt3d6lDqhPy5xYgkVgWw5w9nOArDJ1cunKP0mk/6EU+dWaT26z+O2ySm3xJWxZ2mxyZm1Jfy9CfVojlJBTqpXJ7xkqvigaMuRXr7I5JLBLlpa9yec8Razsceoa9EhIA6fwrX/8F9l43/7CsbC+OZOJPXWTQlWnY5lxBCSmF1WR5AKMeVdbSwsD+KxEjsJi/0ef/GXfg4zAkzJZ68/QeEz/ubPfYFmDqtPfZxynHP96Y9W51b5SbmKV2Xl2tMcDvoUnzpNs9PCbPUYTX13QjDAhQ6NtuUX3/CcDa3/n5/COeb40cGcYM0xR4XJ4YhChfuv3cCXOUHAGcezz17jzlv3UWtIEgteY2XINKYgUIinY4TBq49o4Mht/HoI8Tf8acxBiCO0qFxVEs2U3MRxm3MWgiVIqLzKlbcpdVwZWv6dK1fJMwhpSVnFJPzk2csECzoSxLaxo4CRJmlICYnBu4C2LRglt8K/9+STTGzJmcUFTLGOEYOtN8/EcOdXforvtQzWGMbGUapSxIciEGMj0BDjBAyI8zQEnBMuJClP/bf/NysuxSbuRCgmgGr0Rwkxd2tWE3Rsm/G456vyqGml1oga8CVGAqUNiCqnn7rIC0spw3c26DRaPMxGPJ10eH30kJ86d4XeQskPtjd4YmWNzf6QCUpvMqEUw8GDfcZZwWAyZPudB/SyIYdS8tNr5/jjgwFrecngoM8nktUZoQqhbs45MQhVjb2R0Uum5N/ZJFzyhNs9ynFGyB0hEXypFFlU3gopoRR6v/sKC2sd7HITfXMv3q8xmOpP/X4zoljnohfNSJxDiKBNh1vpoj6Lga+qeEBfe0BalOQh52hvSJ4KTSxHmtEWg3QSxqMJEgIr7S7DbEJOYK27yPpgyOK5FY7Wd9BGihgHNo62A0qiwIMxTkvEJtira/8CPolzzPGjgTnBmmOOCk88dYnOv/YCXj1SKpQeq1BOMq5mCSK2qqsBSl8FckbFIE0MeUWQgg8EVVJrONjrRxO5ykzBOpYbpUTloc46qtUbMTKtbYnczGDEoH/wJs83oD/OqvsKBB+VlHjJV4KHQECDYiQawcUajFqQEDfRJI7cKJV+Hg341kT6YNImv5/3eLgz5nQz5etHuwSN3XdGJY6eRCtLPLjg+RtDR7FxyFevJqw8d5VzDUveG7DUadFO0njbmk/W2V5CrIqx9dhLqw05TrKW6luikfwFhOTaKVY/+zTD9T36G/s82NxicPOIi6fPQVBMGRjaFE0TdiRnWJb4xLHSbrCVDek4w1qngxjPQqtJVwK2d8TqwjKyc5+mteSh5MzKCh/92JMsdCzmT+7Mjm2a1v6+Y60QiEkSfqVL8d23UbF4AmmjxWR9H9TjxhlZVfhsPGQ3HmCXFmHooaTyd3GSgEulWeUlnjKObAUkgD/yqDOknXpdIZJYNeCswZxeYjQpKfGkjTaNTht3MKKRtrABitIDQjNtgJakaYOGTEhalsRZjHNVSXf8jUHLgLqAWLBi4/eyeQ7WHHPU+P8AAAD//+y92a8l2XXm91t774g40x3z3pwqKzMrq1jFKlKcihQpkS1aA9jdkqVWy4b1YAhG2y8G/GKgAQ9AP9j/gdsw0AaMBgy4DagtyWJLTYoSRaopkUXWpCJrzMzKebpD3vHMMey9/LDjDDdJ2QZa/aDW+R4qb906JyJO7Di1v/zWt761IFgLLFCj/+EeD/71jwiUhKUsdoqNx5RnOuhel5ENtBtZ9EoNSpI0w1TRaN3oNBjmJQ3jKPBEF7ZG/xaCFZk5HkVqkhGJRUDjZGLLrHw2falMN2vVSEZaeWA4yqdRAc5Eo7fVmbF5alTXKvp4KkUlDjue1d+ihyar1REjcVixtYbcCjcGfXLXQYNFiFla0dBeRzpoHJ+iRnjQENqrKctLGTeu3cAYS6kwGI4wDaWZxpiBmp3FjkANmDShKiusxCHKzJcLn/Dax3B0wTihuLnHw29dp3lqGbOWQeHJJSFvNjjqHtFaXeaNW9folwX5qCJDcSEwto6y8OyZETcf7xIsbI8GHA6GYGqTuMBFs0RuYHv3MeNv7rFGyqdWNkiNEtSjPnrq3E8gV1qvb9oxrD6/QePlZygpGe0d0DjV4pSPRvSApzw+JoiQLTfwoxKTQd4dsbyxxKg75uh37yA1cVZCXKP6HJNlnIwsNFj0cR/bWGZSdp48WoY4FqjjUqzEgdMrY8idwzYttjAg4DoWO4BxEFgyaFewWDCeDKGoFU4r0dtVEUjqVTJGMIeLLsIFFphgQbAWWKBG0nC0VlsUVcUglHRW2/iBI202qdwYmwpLnQ6joo8ZQ6PRIIwrBCGxCUYCaZJgjKUqKqyxaNA4/NjEjUnm/EfR2A4m1CrEnLI1weT1QXVaQhSB9WaH49EglqkmQoqZqWSRzOnULC4TJ4/W5uSa3BlMTVxqH48xBAOVWLxLudPts5I0aFjD0FcsJxmDIqfSgK11sxLlFQNyusmppIUf96c+7ICQVyVWDIlLomFdFW8F8eAKj9dAcJZax5p99r9inZwxlLWKVBLoiPJbv/RzvPba2xw3G9iBpTsc88mPvMS9D94iL0esr6ySDQ3PtFY47HRpOMtzK6d5+2ib51tLVD5wMBoyzMcAPCi6XM6XESs4myC+TkjX2iMWYkRFcCYSTpkNYZ70SpaVpffVt/BrLfLjIUu/+ln8713l/obSetjFry+TLrVJNWOwfsTozoBT2mLr5m309DqDcR9nG5GYCtOOyamfLS7okxXVeI/FoHWXZaKCj2wYrMFqwJs6w8pB0mlTdHNEPIk6goOGExojz8DCeDCktbyELQ0meKyJhE2MmS6SAjbwY8/vAgv8bcaCYC2wQA0RwSWOoIG2d9hGiqQWJwazuYrtDjAe3NkE0zVxo4vTW3ABsivLuAc5VaXRM4PgklhOMWKmv5sUByUI7S89x+jGDsnyCs3zK/T+8j6i9aueSDqYlg8Ba4SlRpNRGeccTkbaTMiUqTd6NVHVMiIxSmFOIZqRgnoUS62qORF8EKpYAKSVZLQyR9kfU+JIxFNZRTwUxlOWJQFDlqRkWQt/SL3RBhSL1t19RgMGg6ks7/3HZxifXiXkOed/5xprhxWZc1iJ2VdTxjAV23RaVpySGI2fKYhjuxxxHMb4vYBUJQ96Q37Y3ccaw8Mip9/tMVZ45eEdunmORzksCxKX8Oc798nV0LaOvd4BVem53Fih2Wjx7LMb9G90ufT5Z5AP+0gBIoqvPIWPxDG18/8brXOwDFRFRSNtI31omRbhq29j0zaNGwfYNMHcPqT0h2SrHbrv9LDBMerkNFoZR4MhzjnUxDXRev1ljjDD1GvOhGgVWuEunSIZVRgMiEENZBXo2SXGq8dsjIVhb4RYWM8cjCqSTpvOxSuMH+0hbWGp00BKz1qjQbPZwHuPjsfY8YiqUCzUyqyZGfsX3GqBBU5gQbAWWKCGqTOqGklCiaCFh8zBwQCXGIxJSIzidyxF4rFGUBOJibEB7vZwWRPxsWxiiERLBZxYrEiME6hVKQnKeOuY8v4Bmgjlg2OcsagRPGGqTJ1E1JoUxVpDk4wy+GlO1Hx5DZj5d+Y25fhZJ4eblS4npSaROPNQg2JKxSRNCk1pt1tI8OQmY1XBpgHUEdwQZ5XxoMKKpfRVfdgpLSD4usglClKy89YWveQ+ea9Pp0xoFBp9YNbNZWMxp/YxI1tBZ3fCR9/W4YNtyr0eobVC5T02xPKsUUsnzfi1T7/M7/7gFX758z/DD955j7LM+aVnPsL/9ub3+OWXv8DN7R12izEvfvaz3Pzu91htt9mTIY9uHtEyjodXt1jXVn0BtuZ80aQ/mcU4a1xglkFVK5WCYtVhxJMawXkhpCnGB4yAbafYsWKswalDTFQTf2zg9iSSgZOdl5Of08pw+MM7dE6vA9EnRQjgFHM8oGEtNJSVVgsfAlJ5QuJwS0vYYZ/GqQaqYEUJqeCWmyhKahyiS7iB5XCrh5F6wsCJpP+ZgLrAAgssCNYCC5yANZEWiEvQoJTdMeIcBF8PbHa4RPBSIdaQmDpGwVoSieU7awVr7NQEPlGHrMQNc7LpBlGWGhnlagt7cRPbyqA3gobDv30XNXNKzgRPbLjWRoVCpkoG081+UlqKmGUkwaTxLB5/WlU0Mw9X8AEN4LXkZ06t0AzC06vrpJlle+R54dwaVZ7z2sMtTjfOc46U/+Ob34XVpVjyi9pV5EWTAdK18hTE4DZanP/EM+y+8h7m7h6qWZxjaJmLaJgoVZPMqzlRTwBRKvEkxpA8d4lOobROL9Ha3ODoX/4Jm+c28M5zc2ufP3j9ewyqnH/1nW+TeyWI8NV338BLwp/+8C3yMpbNvv3n36W/f8xja6m6Q063lzAIx1WOWmZdoBqmt3UWwVGvrejJdZNYjMXFCAxnHc5a1BgqU2EQ0ixFfIGtDelSG/+FmXUvEk79sUdiHt4E/HHg8GC7fn3df1kvsg+KR1Ffx0ho3Q+o1JlliqjBGqXCU/lajRXFqsG1LKnUBFBPEryovC6wwAITLIJGF1igxmR7EBGMJSpOJqaISwBnEgiKW0tjl581WGsxxpI1GlhncY0UDeDEkIghEYtTcCYGhk5Kf4rBqKCJRVaWsV98keTlS/Dx83R+9dMUJlBN1JEndtR5pcqKkInFOgMuBnGKKE5iTMDUn6WCTNPQmRE1IQ5RJmYqTYI+JXjQgARDt4iRFUXi2e8NOBgP6A0GdMfjmANWFhwXI1aWOnitalIQ63nKrHQ0KXURom/syjPP4JzU2VSz889/XFWdep9qUxdaB1wqijWOMoHdr75G79o97r/yPle/9goW4bOffZZf/ORllltNvvKpj9OyGf/hx17ikxfPsJZm/PIv/gyJFT7z4nNceekya80mn/r8JyjDmM76CmP1XPjoFb7y978Yu+QErE48b3FtvEwErCeoRU0ApwMete44NTG2wzmDc4bEWZyzNPJA08YSqRWDUTMl5dbMEfMn7s38n9T33WksIVtrEKNgQOqxQ9YJiQGXCGkCiYPECqkTMhf/TJxiEoNLiddmLU2XkKWOJFicSbD10PNZMC3T8uUCCywQsVCwFljgScRaT+yqcm668Ys1iIXBzghnLVJUsf0dQznISa2jyisSEVx0wESIOakw1T8GAawlv71L/599Iw5PRtlziq3AJtGDI0/8NWjim6rUExoZQy1IKmgGw7ENNLyiWcbRqEtTHfbyWbi1g8NijZw0k8+X4ajN8FF2wsQYLu5s3aMhhlsPO1w0ws3hiNGtJsZa7o367BtDyzXQFDy+5oQnhz4zSU6SmF5ejsa8+51XyR8fk4qdXY+cFOkmKtt0WSZqW60G4gzjRsKu5vgA4hVfFLSs41vfeBOxHlPAn33/LZoifPtH7xOMJfjAn3ztVc7YBm+9fT2ex1i+/2ff5+zSKqPbW6yqZefaTYYf3qChSuIsZVlhBWyaTEu90+fjJzQonExXj7+3YrBiUFuTZGvIkiRmaBmDBlPfh0juJ+8XZKrkoWCswYcwvcfz55vc0Cf5jojUaxB9e5PE/ckxJmVPsSCtFNNVEmtmDRqTh1EmazV5nhbMaoEFnsSCYC2wwBOY6gHTEpWQOAcG1ECKJViPq3OZjJhYAjIxckGJbewQc55wljQ1VOO5jKB6MzPWgHhS59B6LM76+XX2b99Dg0ONnCRn01qb8sPygCRpkBule3zEi+km38m6PDVQziSb/OXwIV9gg9vXr5EfHfHFM5dZCRYjShAbPVJz/qYJsbIhGtSRmNH0sBJ6nTYI3EGQ9SX2NMT5fq7JoS851XbsGmiFQJRM6nLT9LInqeNQmcDmj3oUP9ylZaKRnqCzIdPIzEKms2uckC1BcFYwYuFwyPLlTb74G18hNSmhLqtWddp4/AQOBarKU6JYiZ2SglJInaavijiHEjDYOPdIBKcBDZOpi54kKKEoGL7xAQbB/iT1arrEJ6VHqT+bNUBdTjZ1WdEYM2s2MJHEmJqAiUayxfy9ANRPZjFORkxPTjQxws+LnzOWOhm9NBHZdPpfpe5qre9/CYmJXjapi42zV05y1+a+KAuOtcACJ7AgWAssUGNGAp6oyU0M4rW9JjWWiVkoiKBaKwsSyzNeJxtXLNGFpov+nVE1J8/U56mznyabl1HB6Wx48hMXiKhSavRL2Y1Vnjr/FO+/cy0meJPQKlKSRiCtlKZpUnZaWD+g4R3pc5u47R75sCRT8MyfQqd/TjmXCElqWDuzRqe9jA8VlUBDLIlCIoajckwLz0gFCQlVUURz99yOe5IbKkrFxt/9KQAOP7xPdqcHFHO+ptilFpSTUQD1yJ1854jNX/88Ky8DeHzlufetH9J/sBsHUGtMGcdM1JnYYZk5Q1mVUTksAyqQmIRCY8edGINVCwlUPuBEwERqZbQOg7WW1BhsYjENg4aTBHgyDPvEmk1+FCjV14Rc6tmKUUWKp5K6K/Wk8jVVHKdG+rnjhhBLiM5G71vQGXGaqFjTN514pKfHn7HZev1t3RkYgOTk+WZKnc69JRK/JwnlAgv8bceCYC2wwAnM/Z1/UjphrixTF7+CxC5BrAEfiUHs5IvGRi9KtL8HljpN+o8Op617k44+tYajwyNyDTTRaXhjdKhPvC312Wt1SYNSnUlpNZvk+zuUK02WP3aZYn+f/OMvkH79NS7/+peQcUXrlRFLP/9Jqr0tjnfe4drWNs+PlIZNqapQG6k5IXVMf7SKsbEBbXd3j119jBEbSQ8WrRPFjXqQOjUeqHwx3YBFZppHCIFgAgGDSsJo6wgSwR/0KLsDLm+cozfoU3pP4hyiBm/KOG9wrnyJKpSBrX/5StTHRDHB0wRCp8XYlwSNBnuAoNHArUKcpdeNRKR5foXe7j6ZTbGa4X1Fo51RDnI6p1Y42j9AnBDaCSxlyE4Rc87EErW/gGummGE4WW+dJzJ68j9FbxpgzMkyaP2PaVFZojp0oiw47Q6tn8kJ6REhhEA1rkg7LYrREGcs8P+P8My/ZlbyZDZVgNm550mZaqg/wxOlyQXHWmCBKRYEa4EF5jExI9elqKBxpEzQKE05E2J7ex2/MNl0KjzOWmwpFChpJ4NuiVdBU4+nxGoWc5wQxCgGS3V9CyGmelu1WAS1irgkJqXPqUBRiBAkD1RS4fsjRvcec3T7HnQS0hv30Crn9h9/nzObZxjeeczD996n//CYy5/6CE+tL9MJI7JLK+z+wTXajfZMnZCZi0YNnAsV/zwk/JNxlwNjCUbxGhW4SjUazYNQEGK5CxDqcloIVFZx0y06lk2pq4eJBNZe3ybXgkYAZ1MGxZiVlSWqIPiqwKwZmq2U/GGBVTtnlp+Q1Bh06hWMSzAKS9aRecsoVHVeVk0QfEBSR7PTYNzPkQp8fxwbERopYZyD+kignaBBSY2hubnK6KCPDR61cW6gkZjKL+IwAx+7RevnIEgsA8rE+F0b9ifmb61f5EycKagCQQJGo6I1eZ4mCpTASXJ14jmNzyoK3hJJm7PxV5EFz/ngZtcTn776fITZPTKgoR7PxFx5d05xnXyWmj7/WHqGm1O2FlhggQXBWmCBOSiqBl3OSJablHf3cSr4UlBf0nr5aaqHhzQvnmH4+of42jCuVYXrtDAqeErSZoOwl6MSEA+2J4RxwGZQSqhVGaL6IoYkcVgVMIbQEFjLcHfrjsAnrlCA7DhguyMMwqN79xmWOcXRmOPDPqOg+FHJ8c4uZcOyd/sA8oLx3l32XErPOtI3tmikTUJNFM1kp6w3c5+XbL56i/+SHjkpBEMlHkHwEqbbttFIKqwPBKNYl4IT0qZDqhDLalNqGP1QPgRWf/oKdPex93qYCw53P1D2Btzs7XJp5SyNpSbD/SGtKpsaw+NRZl4jI7HsJyYqiMFFtSczKRIs3vtIMlTBEmMJ+jmpc0AgxaDiZl16xpIYAypYUZLaW+fEYHyICegmNjTYuqPPWourS8QqPhIrMdNrfJIYBYHW5y7Q++Fdlj95gd4PH5FdPkO5fYAMZv68n5Rv9SQE8OczdGuECaCTwM/ad2bqe3SSAsVjhUxhPCNRolCuGOwooKWNfrifeO6osDoxmDr0qgoBCSBG8CoYXTSmL7DABAuCtcACNSYlJ98bo82E1X/4BXxVkqQOUELq4ONPgxpaL5ynkhDDREMAH1vwIVCp4rxQiSdUAUkNp8zz5HcPGL33kKo7Iqm7EwVIrAMMmgqnP3mZ7Vc/jF2KUb5gYvmO40/ie4KBMChouIReWVK4wNmqwTDE2Xvj0RAVZTgYIhrAdTC2bvc3FpWAqquDLHXaHRb9Rp4vP/b8/sU2eSWoVhhNKAXSskQ1sD4OJOrJKhhYT3c4QNfWsM2U//xaj+buKDYAPEGxFEP/8SHqPcZbwiBgjKXZahPWG/Qe9+h0UrwvMTSmzQAwMYn7aNBXQJTGWhuz3mF0c7v+XJBYizWGUHfY+ZoMpGlKVQ6xGKyxJNaQpAm+KAnWkqQp1ajAWShd3dVnbR19Ee+/ZS6VXyYjaYSw5jCDClPNqUUTcqhxvQyGwuXgwZ3L4C+V7JSjPFa0X5cPZd7n9OM/T45nMPidnFiwNFQaUDWEQIxmEEFTh+RVvMZavQrGMFxSVkYKUieViTLsGDo9Dw2PVoqU5mT5EJDM0f6Nn8V3+6gDco//gzdQG0vHKZ7kI2f/ur+WCyzwNxYLgrXAAjUmZmBFScXx4Te+y+GDI25UR5xeWWJwOKaVGQZ5SUMdQSBUkIiQ+5xMMqQh9KuKJDigpNFsYPMKrTzP/r2Xkd1DjHOxLOcMa599lsRZQunRyrP9+oeIJxqNDbG7rTbYaz0uBgIEZe3KWVLbon+ww6oazm2c4ujqTS4+d4mq9OzdfcRnfv4TvP3dt+kUhmbisJUwsV6pmWgb86qDghhOqfLf3h7xbmIZq9JpNugdHLJ+WFB0oOGhWRnSMuZBfXMjcPYocHEc+KlHPUzqMEbr8llNsjSg4hneekzwIXqZBkrVyBAfSFebjM2AsvQUXqnGIUYGBMEmjuA9JkmwGxnV/QFeA0sNR+Nii+71aEqPniWpZz9Gb5AlesCMsSTWIkaxKThvMVXASlRgLOCs4Ece5yzaL2IzgYmEzjUTfFliyug/ElW8sahUcOjAKpVanMbmh0nm6HTtMku4uY/xgcoQVb6sQbE1Jk3TE9W1n6SCTQ3pqoTVJs3PP4sRqDQm2pvUsNx/Kl6rsfiVhLBXp65LBZKgvmQpc9CPeWUaAoSKDCFswtj3keMB/s5gmnUVfWPR7D+4fp+ylyMmRGJV+Tio21qqhmNI99/FV3OBBf5GYkGwFlhgDvOuocRluKc6PDXO+NnT63w7bPHUU2u0lzKuvn6Pl3/tBd784+ssn11j40yTd1+5zXOfucTRzj7l0LJypUm+WzJ+MARTxvylqiIxhhLPxqcvEQ677N08gKqKJUNjEbHzjmImoZoigqkq5CtPIw/7NLsjDrtdNtY2GPZ6hKVlcguuglBWLK+vcvy4R3qqw+1unzOfeprn+kp6ymL3S/JbOUZDNNTriZuA8cLHybhyPKQYVLTPtdg6it12bpQyLIcsdZp0iyEphn/EKulujpWCkCZx8DS+nr9I7S+SuKHXn2uaC2VtLGv1CpQYp6Cq+CpM/WEa6hBSHwi9HA3xeOP+kMNvbSE0mC+DxVPMfrbW4ssyJqhriF2A4wojgrOWSutRSSZmcjlj8MyIjhVoJI4ytVjnsImJw57FQDPFDktkMyO/fUQo5InB3bEhovHsGYZ7O3gXGH73IWIMMsxBK7y3iJnLAzvx/omxvDbuC9hPXOYb336V4UGXgPLs517knVsf0lle4rA7pMRjFTQYgvfxmiWudYqjMoHMOUSigpokKeubGUvv7PPsp59FXY6vfJw1CIhXJCjHr11DsZhRHr2KopgQOzYZB+yNAfzCv8UXcIEF/j3ComC+wAI1Qm1EjqUhASP4dko+zrlxNGDQP2Zn65B7N3aoQsWNH9zGB8/gaMje9X0wytG9Y/JjZXTQpXd7wNFun5HkaGaiV0cheCU5t0J1OOD42nZUOpIE4zKsNRg7Rw7mOIOIYJOU6tuPKK932X68x+krF3hw+w7HZc7O3h7FwTGD3W2aK0vcu3WPsl8QjkoeeNjxhtE7W/S/s83oTi+Sqye7zQRUJqUoIVtqIc8soQYa1pAIOBNInSNNMpLEoCYgeRkTwbMUa2NzpTV2WlKLXh+lIpCtL9Vp5bGhwNTGbE0dHgiVh6B4X0WiFQIQYxJ8UdZqmKIhxM5Nb6gHwDDzHEVM0vMNcQ6kE8GKhWBwLs7TS5OUJHHUWQnRe2VdTEJHcBpLgcWggIFHjwqqxyNEE/KdPvnNA4q9AdXVQ2whJ/jqxJxvVQiHPbSZYVstdKmFAUaDQFhyqAYqrX6s8296HI1UT+O/gAbyezt0PnOR0apj88Di7g/4yJ7gD0asuQZXVtoUx0d8/srTfPrKCkf7Q7744rPsbm1z+hNnSa3n/KeeovlMk3vdx/T3+vjdLv0f3ME7xbQyaKfQaaBLDVhukWLJfEx4VwHqsNOAxg7YBRZYYIqFgrXAAnOYZQZZSvUMbjxmpCPsR87TedxCEsG2m6RjpbO2xvHhPs0sY+l0i91+n+T8KoP3H9FaXaa9ucTOwV2STgPpFbHzSiFpZ8io4PjRITZNSYjjYILMlQPnevxPJG1LPWpYoRzmvPejdxkNR2iek+8cIJnlaFxwvL1FkSqPPryFEYs1JZt/cY1HIpxtLJEWhjolc9qpGD+5TP06CCQlNMsKYw1Z4lAJGGfwIlirWBe9SGkRk8GtNfhKan+S1EOfzVQZtCr4/pgkSSl9DhI7ND3QP+jG2AGUAq2jHXy8PuvwJRg16Dga2CcZWUE9YLFT1Wf2eaJZm+jlIvqonBGCj2XASVamdRYb3VQxIUNi8KkxoEaRENM4BB9H+ziDv9jEns6wG8uEoxGDD7bJfD2k28zuqg1QGY/f7ZE9t8Gou4/52FnKh/tU3WM8AVsF1DgqI9OA0fk0/FlMg0xDR9eabY6+fZVVY7hqb7BycYV/s3OLY2/YfdjjtljG5PzrN97CBgdG+d1vvsJKo8Ho69fY92OG28estJqcfdDD+h5VGsne8c4BKQZRwSUWJJZpE5vGe+NcLBMacLWx/f9rTuICC/xtw4JgLbDACUTjjKSO7OImpy6m9P/8NiF4bMPSEMfSepPeo2OWOgJmjJMUGzztxNDoDmk0ExqJY9lYWgjSL3BYxAiVM4RMOd49IEubuKC4Uwm+UugFgujUGI5OoglOXF3MeTqzwrlHx/RKJZdWVGfOnaL54BHrnRXKvGSYNDh3+gyj/pCVNOHTH/0pdt+/xsZHn6L73gMS26glkpPlqIjJXEKLYNEq1GODfJzBWM/iS+rfiUzM34I1sw03kivwGiAI6hVrhOCUUHqkLrWVweOLChGlyks0BAZFQXrlFOHuEVXb4stYGkyfPU3+wSNsYhGESgPGe9RGVeXHm99i/+E0EFQnQ5lBYkx6zN3yntQlGIEsdaTeYyTBWEEzZXhcTbOpjEDImsi5BHfhHI+//RajfpfNrI0x7kSJsExg9R/9Aro7wmSWzsdfIEXwz1whkQBVoCxzQlqx9X//kKTQExEgTz4AimC80k5T1CR4hNIIRYBf+JVfZPBwn70729hGRuZA0xTyMf3BiHSpydb9Q9zzG1xachSZhb+4zZIxrH7hEtnOAPZlcqJ6TmWMpUhdSthsYapawdJAOBjF0jZ1hMNCxVpggSkWBGuBBaaoVaMANoPj+7vcu/WIxMDevT3G/ZIqqRi+X2G85d57h1ReODwasXPQpUuFHI45GuSs5kqVF9g0RSofZ+S5OIMuH+Wxs8t71Bp8v0CDIsFEbxIzJWvaiTbx4Gg0jjMuuLJ5BnAUD/YYlSPUZFyRddJexuqnXuDRq+8SxiCtZeR4xM6b72IMdA97gMHXBnDq9v4TgZGTc4qSEAcyOxMDRpMkiV1rRUWCIcSDxJKajfES6CyRvHlxg7NffhENSqgqbJKiUtE7PEKMxTmHt5GKhQC2nleoCNhA+Ixi0wTjI+NUIzQ+9jQmeMR4VgZnKfMcvXlI2MunY4qmqzqtHNYdk5kSvMFO8qJcrbF5iZJVUMRBstKg3CsYj0c0lttMHFkigDG4fkV5Y4ejNx+xstok2WyjYwhVJByTcxrnkFDSfbhLY6kFvZyBA4+Sa4VaJU0yet1DGk+vMrq6Q2Iczs7G50xKhJPn1IRACAVGodKK4sN9dluB7a9+i7EJ9I0SvEfFUqrigkedRbYDL6yc5533brG+0mHpdMrTLiEUUaLLC0Xr7sLcwNLHzlLe2Kd9aYNkc4XsNz9B8c23settzv+9z3L9v/9t7F4J1i7UqwUWeAILgrXAAjUm6pAAtpGhNvp2aFo+84VP8oPX32Ztc5X2SpuDt+7y/Ocu8d6PbnNq8zRLrSYfXLvBRy9d5PqDB5xtrdBYMWjvmO6D47iBuwSfpDDMcYnBugQSGy3QzmDPJlROkftlDPKcKFknLjKqC1V3TKrQM4E0MXhJYbuHJoYgFaOdPWzicKOKkAestViN6pJ7NMCIPVEahJmhe3Y3ZhzPCCTO1WNdhNSlgJKg+Ho0jTEGsRaMrQkWaPCsfelF3vlf/4gyKGWujHzO5YsXeHR4hOmkFEdjCiOMrdC61Gb/nYe0kyZiDK5SvBNaax36ez2qqiD3BZ31VcrxgBeap2gmFt92sJLQrkfFTOb5RYISKauimGDILq6R73Xxx3GsT+P0MtZZRvceI2lGyHPKPKCagwaCsxxvj0hkPoFdMZ0MObOCXW0xyMckSYJUHvKAWlMHcSoqQnU8wN3Zpzq+RXkqo9o+ouiP6fuSEJS0nVFd2MA1O/TynGaitEyKkUn2V1yJGCUiaBkYtxJy8XS+9HFWltpc++qfkk98Y0H4zed/hlf37nIhWcItt/jjq2/y0vmnoJ+zlLXprKzQziA4aJjA4ZsPaPkEVtfrsU9C/u4W1lrKD7cp724zevsmIUkwRnj/G1fJjwY0bBoHnFv71/htXGCBv/lYEKwFFqgxFW80tu0HlBA8fuh5+09f47Acke8dYdTiEV579TrDsmBncIckgV7hKd+/ildleHyEPoiZWKmtvTVloOqNoAF54XFYyjKn0WnSkQzvc8zZjPE9H8emTEjWXAhomGRi1X+2gyFYSwOi8hACKkpDEgZWEOtwdQefUaK5vM5wgpm3Z9LpV8dLncDE82NFMFkSTfrWorWBydXjWibRlc4lMe1eFYvFHvawiaPYTOmcX6b6/gOajQycQdeFZGhImk3CpqVyBe0sYfWnNjj7wmV2v/o+9qUzJKebyAf7eAqyzQ3Of2SDY90j/eY+mbPkVaC32yN1rWiqn1PidFpnFYINdG9sYU2C00jAhg8OSZMEEyxUFWIiUdA8zuWzapC6JEp9n4LGaILQMeiyIN98SNkPqFGSJJYIJ1cgxqA6RoclzllGvqRcSWmLI4yHsXnBOXpVQAl4hTIEvCpuskazWK04UFyUVgVWEg7+5Ec00gyAS81l9v2Iw2rEv7j+Ckbhhgj2AWRZk5u7+6iJafQ7O7vkeZPb40MEuGLarIirCWls+jBiCQG8UaxYnGuiVrCnlhg92icWi2fP5QILLDDDgmAtsMAcJNR+HReNvRUGTeHyP/gig2+8SnulwfK5VXZfv83Fn73C7qv36aytg8Du412unDnNg2GPlcJx6RNX+MGbP6LIC6z301KcYhBxyDmH9B05jnIzJXkwYPigS5qmzDLLJz4sPTGYd2og17iBixFEhWAMAXA2qlbOuROEydReKZmENOmMXKEnNazpPYknrBsaBW8npvs5M7k1BA3gFdUYdzB9f1ECBsae0d4Ya6Ea54gq5lFJUMiBZgG2s8au7tG7tsfww31SDP7dW3G243KT8ThndDyk98GHVE45rx3yLGFJox8riBI0YGqf1TRPSieWcSExGWIMIXhUBFeXY4Mq0kgIocDmMi3zGQVjas+RRvN7qDzjv7iKD0qhHhOEhrMYOwkgnRFYY0BsCuLRAK2uUpQBAZrWIamNXZT1LHAzR/Q1aAyFndndo8KqwoicXp5TKHhXl5g3lnnJPUXeO+KlM5d45dENVlsdzm2u8SdvvcOvvPQSf3rjBp+5cJlmM+Ptu7f5+PPPc+36rdg9Sf0s1deetBsEA9Ya0tMrND9+meHDQ0qjuNZpyvcfIJPmjAUWWOAEFgRrgQVqTMzlAUUN04G3jUr58FuvU3QH0C05vnuAKtz8i+uoh655jFHL48EAc3TAdn/EUcfw8I03KHKl1aiH786dSwXccSz7OMAMRmRpQj6uppvbTxqTciJ4Eqb5WJPOQjSW6qw19Zw8M51nNz0uE//1pFttPtjgxzdL1dlMO63vU5gQvrn3WWNjoKed+70oeCVJIR9VhMExGHDW1sONFTWKwXN4e5/qrqeVpmTUxDDGlpM2G4wx2E4bfX6D8as3SMrAo3DA6eYay9KYdlnO32epE9XjbMmAiky9Z9VcV2Dqowpn84ApYuegSk3MjIUgdYqDre9HLKEFY0gqUAlUBBommRLayf3xIkjlsSEQDEgZ14ggeOoOxrp7tbbZEeqy65OY6GLBBzbPnmf3natxTM5xSdnwrI6UPz98F4vyztEWg8qT7u9gHlkqD3/04VVGIfCXW3dI1WEMDPPBXMhufDjimB2DH5doVZEbhzmXUr58gUNXsnRhHdO05Nfvkng3xwoXWGCBCRYEa4EFasw3masS5615JZiAVEInbbK0voyud+jd3ObpTz3Dzdfeo7OyTCNtEFCWX9hg8P42T6Udxi+s8fi1GxSjPG7QJtQdazU5emoV3/H0HuQkg4r8vEUfUKsmM/Lz/yYOnBipYgQTZm8wRM+ViNSjZeZt0vOUCkQlxhHo/CtkShYicYm5WZNjTd47GcIsaIw18PU0PImBm1Yclz/9ImE4hKBcv3GbLEvxNpr/K60YFBVXfusrhOEQLUv2v/4G6VxJVMXgmg3KwQC/PyJYw+baOs39nOXcQTb3iZQ5s34kfFoo1ZlVkp/7BKaZUoaC7uvvsvbMBbQsGA3GNNsN0gClV4pGStbLKd64jj+XIXtjTF53mNb3s0wtBgtpAqaiLCrKqsK45MSSCeCqwNiAbTbID3oEUR6fE1o7sBwM3udYbVJNUia09m/NrfMkPmNCgXdvPuSHSxXeCFU9fPtjF57n1uEeT3dW+fxzz/E/v/ptPrtyjmeuPMc3r7/Df/H5L/Mvvv9vePH0GTbPneWNd69x/sw6j27v1GOTYmkwiOAweAVrHYhhdO0hvf/x91E1dDXEyAs1eKmwdhGpuMACT2JBsBZYYA4qgniBEMguLuPfzUmayzT+wc9w9f/8Gs8cC2WvR5WP2HrvBoUPHB1ED08xHOGv7zEqKwaM8NuxU68jjoH6GRkibk6hlxO8IRz1qNZSVgtLXgGWE+rFRFGazqL7K5StKakwgLGIYUas5jZuak8WYe4c3tN+qUP/ag7qQQKCrcuICucSeFjGclEdEuqn7KuOO5i7lgk9EOoRQG/fIvgYHpqW0Dnf5OKXnub2926hYygtDI4G/MJ/9Z9y7c/+gqOvvRGVHIklspCPKUJF1VDSpxz5VY9fMuiZdaoS2Mun0RYzFhkwDUu2bBnvFZiq4N3/6+tsD47ZqBqsJA69vstxXpI1Muxai63b92GlxTuPd/lPfvPXSEolbDQYPTqko82p+mcQzv7Dn2bjc8+w9a9eZ+VXPsbgwRF3/+kfkRgTla5p/IVQBMvVL5zmE28eUoxz8qalaiWkG23MgSIaSYwSTpCzCXmd3lsFsfH+mphIGwdOY8EE/tnV72CdsDXapfd+HxLHO4N9Hnw4Zpjn/PPvfYuxV957tEO6+5iGSzHN5iz7K4T4bNTqoTFgtM7BOrVM8V9/heqduzTGJfL7byDWRfLtFW9iCXWBBRaIWBCsBRaYQGoSI9EwvndrByXOw7vxe98iH1ec/+glHt7fQm1JduY0jdFDmmlGY30FBhXZ+ik6W3tghHYI7CMsWceOr2KoUA0jggkFgyNPtdmk8VSD4YfHOG8gVhT/SvykAcBQm9MVxAJep12CMt3oZ8fVUGcXTd7TcIweeAwBNR7daBJ2C1I1oIFxb0wqCTYogRDVjkkpjImycuIUoErAQhW7JsfDnOA9YgOJgff+9BpN1yBbSrl0YQO9+YBv/Tf/E73d7aikCeAD7pkNwmEXrQIMBTsSsIbB3ojDqsvlpEkqWVy3+jqCapxFOCoYjjzqBfGG0lhaP/cpju8fs7k3YLTWJhlDSYV3lmEo2Hz6GX52q8COK3rLKYM/v0/iDO1mBZg4ysjC0e+/zu7vfZ/k7zzLvX/yOyQh4DT6qYKjvr/xPiUu5fnXH4NXnEBmElpbSuqVIB6QmOA/XbWTROVkwrtCCLV3zPLxxio/1VzmbRmy3835yoWP8dvvfZ+XP/0xDm+9x0caKzxz6TJ/+O4b/NZnfo6vvvldPvfSR5Es493rH1Dm0fw1USOnMy9nti8sgh/luFc+REc5xWBAZpga+LwqUpUnSPsCC/xtx4JgLbDABDUPCbVfp4OlkaUEgRWTYm3K1u42/dGABMOg241jXtZbDB4f4ptC4QeEIid0WrjTy3Bri2Hq8BJLcEY8QQ0SFL+SMOqOCZ0lqrf3adsWKqHOujIzMUZPXOKMCE5KjRBVJoVghdXL5zi6/qCea1i/TwNCNMCbEDdys+oIh0UsRxZgxwXpUptev4s7LtEA3lSxZFk1cF7hbAM7KOl2+5gkrb1DM5/WVHHRmLpOWyh2u6xuLlN2SnxRMRaPN7BkHUGUfDgm74+x3SEhSah2eggGDJhGQrF1RGpM7JAsYPjaQ5omocpLKEs6bhlsmJUz6w6+gNJZW0VQrHWUnTbp6JDDNz/kwvMvELpjyqzD0f42RTGgYVcZqsB+zh095sKg5NH9R6ykDYpS6SclnSSL99pHJc9mCZufPsXxDxyhl5OIrRWueB9ElRDi/Mm2plRFjjMZJlcoqykRLLSKA75ji2L0gNVrHuafUdG6mUFiin6AG1WfR4dHjE2CNY7vPvqAIlE+uH+T4/GIt8dDro+77BUFv/Pu9zkYD3jl6jVc4uiYhPD4kE7TYUbxOdI4u4ha1orraoCiwv7x26iv4qBu42bqKoFgHO3N9b+ub+MCC/yNx4JgLbDAHOIAW0AsK09fQF+4zP0/eoX01DKVVaoq0Gy3GD8+YqmzweH2EWFvgF1rU93bg4ttysYxR/sD+v2cC2sb3NY+SSV1t1UkN4qgQ0vmm9hbPWg10SpGIUSv+pMm8p+MSfio1q9dfvY8/RsP8SFEo7JMyofxtUY1lqJUaT/fZPyDHEMcjwJC1Wmg3R5Jo8O4HGCf3UTef4ztVhiEZg6jfkH7qU2Kgx7GKxoEuXKG8f0tknKWJ2Aw4JWqVMKwohjmFP0R43JE1V4ms4Zx7XXT7pDgFZsJlXqWLqxThTKGj2qJLLXgdpflF88xPtei/LNrpKnBGMsweFpady0GnQqFqkoVPPeP9njneIvnl89zZ7RLNRpS3Ux4//EWHO7igqeslOHBmHLJ8eDB+6yeXmE4DjwYDCgaKSGUdPtjVpOCtXaHTCwGxY2V7X/6Os0qgHEY4+IswjrJXSWmrg9aGaOzS5hxFocjq5IpFCjiHJl1tPI+eeUjsayd+aFeM2VSeo2l4BA8lVV66tlwHf6HX/8NfnD7Bl9/7VWePbPJw+4+V1Y3uHZ8xMc2zrC8ssro7k1++vyzfG90jc21NZY6KXtbR9x8tE81rhsZJJrrJ0+eMWbC4IkJ9gaxSby/BFwzwSUJ1iud1TX6B8ec+rf/Gi6wwL8XWBCsBRaoEYcCM91etJXCaoMi92S9IUnuaVxeoYHh0c4xacdgBZIsIc0cfePBljRF4CPrEAJ3bh+R20BmLUH8dASKFSHkFXk74+KvfYrDNz5k7eUXOfrDv0SGkxiEaTvarLQ3Ua6eMJoHX7HykacZ3N6iqgJ2QhRh2pkG0LhwilN/5znIo+9q6T9KCQ4QT2kCmiS09EWqBJri8I0M/x9AGaBS6KnDq2BbTbQo6wgBha1dwrX7iHWIkVpF8khhyHd7uNTQSBLaaw5oY62jWwSMWjq/+BKlVoQ3H1H2RiRJgnYEf1BhESpr0e0B1nt6H9ynugrjMufL/9mvwnGfnT96k6Z2oqleiCTLRhVNHTSePcvTdh29fsDF009TDSoazSXa1WPW7BKFE8LgiOSZyxTLDXbfepdTF89TjIekImx+5lmK0YDBW/cY+gozGrDaWoolSBQ3SWtX5uYvTqpnSiVK/tvfw51eo/XSJVxiYilOHE3vCb6kspbxg236r3xQd2nWax10Os5n9jzU8RyJxVaGB4Mh/93Xfoeyqmi0mjwY9/FieH33Di4IWweHdPMS7z3XHt5jVBY83n/M4b4hyzJCWULwWNWYwi/1vMP5qInJhAEx8WdVBIvrNFkyKcPBkKNHO5yq/L+T7+YCC/xNxIJgLbDACcQ5c0macXo1IX10xPrf/zJLYugXQ8Z5SagCV774KTCBy1/axJhIPlYuPIWGQPa5p2iKoVJlcCbHE3BFoH16lZExBBHECrYKLC1nVFe3aGdNutfvUVWeJMxiFFTABIklGhTr46Zdhw6gQfFGOP2Rixzf3cJXUWlQM++Foi5/Cp3lJf7x9hZXhwWl8aCOSgXU8NHVJW4/3gatOLva4cFwSJkXiDV1bIUSxEVFSWPJjqCkFn7ervDlfo/NVot22ojXUNdbU2cRX1IUBT2tCN6z1m7y1C+9wKNvXmPvwSPUCquNhATL8dERV566yGHxkDxUuNGAYliQKLTXW4RCMbnhO//7HxLU84nORp1zFQlJEMVq7Hk0Xjl872aMj1ha5Xy34uH+Pvr8Ki3nKH0BlUc6Laq7WwzyAUtnNwmNlO7xEQbh/nfeIskyWkRy4VXxVYV30TElxmA1RjUYqfPAarVJFPxgTP/iOs17+xzff4wqVIAESxHGFFLiQ8CPYtkRE/1xs67BOEdRJ80JCoSA1wrrBcTzuDfEGIvRgs56B1XDJ595mu/86BY2hTNn1rh5uEtzJeXs2iaDUY9nXniWu9duUQVDAwNisF5xDUc5LMAqk7g0iOpu7KKM9DHLUvzhkOPQixlaSZy3ucACC0QsCNYCC0xQG3sNsP/GdexSSgshz3OGIZayOokjlOW0JFeI4hCsdYgYvIDaGC6ZOkvbODQoJZ7qjTtoYuuSj5KUSvX2NiM1qASsIQZ0pmkMRNAYHikvnyXfPiKECrdmkKvDuNFWYJuWU5c22L/5EILBwlQlmygQWpMrQ0xZP/I5n7twhjuDIRe2ctpJi6+3crKGpZm1sGXFRiPlsYd/3HmW/6V3jcQlVBX83VGL73VGbAVPMBYb4LlTa8hBn8oYjssxRfCsZq2Yp2QECCRJgrOGpiqVlKSSwM0dxAE39xmrstdIObXUwXjYuXmf/PERqkqqMc4BDLZpOb/UwuwVpNkpVKDdSqlUMePBtItQlTrN3eCCQ8dj3GqDInXw+JBi75jmxv/T3r31yHWd6R3/v2utXac+ssWjLIqUfJQmsg3bI0wwk5lBBoMMEkwSIHOZmwC5yWVu8hWSD5CPkMsAGSB2knESZAZOjInisWTLOp8oihTZJPvc1VW1915r5WLtqq6mlYkD1FX8/AgeRBLq2rtL2k+/613vuszkcJ+2jfQaz6yJ7NmMrcMj4odT4vXrkBNGoIdbNHu7PG/r7+TzQFx+7LZtdq+ljyd/dkibE9Xty4y3e7QP9jjbzvi3ZqRJYm1zxLSuF0u6zpVl3JTL+Yw5t1QukLrdfiHB4MYV7N0DrHJsBs9JE8neGLdTXM7sT1pSU+O210m9QDXqw3qf9njM2XTGYTvh7skxA5e51jich/6VNdyowh/OlyPpKlrn38mZQX9AbBt8CPjuMaLDnkUuUsAS6dj8YZKBWUtTeSaHJ8wmE3KEJkUGW2ucHBwtlt96233Gj6b4ypEqR0PC1RnnAj442qYpR9M4mOZEcGXat8fjzKh6FRUGGwP6v7tD/YMHZWYWpVIV+46NS1vkD/dJ+w3t1Q1ce1aGeW70WL+xzf4Hu5AdZonk7LyPbH5d3UMRuoOic+Da+ojPTo74Xr/i0Uafy1c3GJ9OGE1rfOX48uVN3jm5y8dv/oKXXn2OW5eGvPnRHar3P8a+skEejkqDu0vcebzPbRfIRMhGGyOnsynrvSHOe9oMbQ05lwXYlCr8luejD58QnIf1ATaZ0fOGjc+4/OpXmX20S5xM2b59jWzQfLpHzuB3JzRVJrWJlhofPPF4xsA5LJz3pCUSZGi3B5C26bWR06Nj0iwSfSRMTohAxPAR1l9+nt54wjP3HtKs9bn+B9/D6pb80zd54bdfYbSzyef/6eflfi7vmlxKFPmpzZqL0Rndeyo4R71/Qj5qSOao9lrqaSxzw6w0uzPfaJpyd6h0+bl66QbNBw+oUiiHRNc16998gWt3H1DhaHLLZvBkB3vTxDPrl/jkzh7fevUlPnzrLvc+esAWfR7s7gFGf7TGk4+fcHXzEpcuDfna9WfYeHjGzjPrTD/YL2GfixPp57/uDwbkWN7L5tyFnsFfpW9Q5NeFApbInC12nZeH9PEY18zYuDpi+qTBZ4d3jqoKkMBcZrQx4nSvZvDiZU73n9A7gey78BQ8dLvrzMB5X8JW961ygeRanDncpOXsB/fpLfXyWDJ660OaRye4v3mL/IN3CFUf8x53acBoe8TR+7vgXNc7Uy4jL36YO6+35AzeZf7tX30EVvOvMarpIVz/Cu9OJrxyc4c2N3xSe7ZuPs9rL5Rm7mbUY/zyV/nJ9ZusEfhGBjPH8PCQ9w/2y3E9CbLruo8yxBTLPeiqP4tg0p3P+MJgi/uzE775j/8ODx88ZO8H/4tgFbMPH7L98k2OX3uf8cmYYb/PIENMjjpH7r68hTlH783P8MmzaQHHYNEI7l3pH3LZyPtn1I8Pma0P6GNUL14nvvkRsa4JWxuESaJpa558cofppGaSI+mw5ePv/zeq4YiqCtz92YdsVKOlOWZL9/hCb1zGnDu/5XYxZOWUGX7zOfjLjxl+9xnG/+NTBs9uM6Mmz8p4jpzPg35Ombptyu7QXzzA5UQbyl+ws4bnkuef/fEfklKLo+z2bNumhG2MZAnfGn/7ha/hXVXCP4bzgdRGXDDa2QyLiXoyZXayz+zdR4RuaOj8Gp3rqleUPqwqBJp2hnl/8WSBxbA1EQEFLJEltnggZqBnHvp9pocz+lWflBzZHD3vSa7MSJgdTLDKcAenDM48DQmzXB5SufRzmbE4YNl3R9UEcwSgzhnzpel9WFX465s094+JW0MGVa+c0bcxJJ86YtUj+oppiNz8w5c5eO096tRQ+R6L5al5xeELxhGVCfKGr2fcqDJ7YVCWn5qG6S/uspHOeHPa7eqzXZwP7PQrNszxYY7MmpqUKefvNTXJNfxz73l7MASL3T4zf36YdLd7cVHV6XYvRouYzxykMXWa8Vd/9heMD4644itcdqyvr5HevYcbeIbDdRwJM0+1WVGftOzcuIz3junP7xFjmdQestFLUIUSDlwGciJ/4zqZM5rDIypXcfL2HfqjIb3NAePjU2LdkDEuPXOV6XRG8+QJW7dv01jG4TndPSbf2CLPMv4snu8WyOdhcTlkXJxXNb/u8ufePM3+GX57RKqN4If0RhU9l4mHNcl7Ykx4fBmFcG2NnX/yu0z3DolPThnd3GF8dxf74R1cm5n++XtMjyekWKpI0WrSDSPdi6xtrHE0OyFNE8551kKPWSrzroI3LGWSOWgTLlipwDYR826xWcDTHcHE+cYMM7eY1PVF1ygi5xSwRJYsqhNWdnJ5qxhVFYlUKjTe4c0RnCOlljxLOF9RVRW1a8rsJ0ovVe52Xzln3YHMZXSBc+UhlV15YM3PETQcve0h44djNv7pbzGIkZGFbiaRY/S3bnI8PmT2+j0e/ofXoWlo24hzCfPG/LTDpx92iwnwQM6RQTSuOTA/5Mi1DDdHXCbwR03Ff5+c0qvhBVvjZ+tjGjOuGBzMauo68huDDfaqlt2eo6q2+FEV6LezxTmOuQsdiwFddr58tHgdyXBbm9y6fJMrkzNsHHgwPWM0HDLKZbTD8HdeYfuTXXo7W6TphKPjKd/6B9/hzg/fp3rjSdkhuHO9RLp503+Oi8pdqUQazd0nnH6+SzSHDSqe/Ue/x+M//RHttMa3jpjLIdmPdh+SYqTvjPHdz6h9YLC1RWUwy5ENV2E5Yi7AvMdqMQNquSOrnGnonLF8YLcBOId/b68cGL3/GO+MdHdCkxJNauj1BzRtBgdXXrlNb3OdR//zI2ytB5Vx+PCAPG7wTYtPZbm3uuTJpwlrIVtFrI1mUKqlG2trnE6OqRz4YFS1kXseVwWMSHaGP5u/vtIHON/9aN3O1WTgXXnPk8vnNi+n5qfeY0+VTkV+rSlgiSx5ugJh3c4p1x3sG7yndr4Eo/k4ggwhBLx5sstldIMPtDlhvuw8M1f6oryV5UNvHpxdqAYY5RBkgPrjXbbfScSm5ez4mPzCDtzbZ/rKBg0NJ/cPCSEQnCfk1PVg/Z+rCKUqV64l5shRjExCGST6m3s1//XkjH/jMwTPi7eu8l/29/gbeB5MJ4wzpdemMg6bMYO1Db5sfQb9Hs9Op+ymluwD3eyBxT1MOc3T6tOvhhqYHRxRZWjHU67mHrHtBm8mY/znbzMIFYcfP8Y8uOj4xb/7KbS2qLCcH6pMF2CNni8BKHZnBPViJp1OqZ0xGwzY+8+v0aTEjT/4Nh//6Y8x70mpJXVDP1vLMElsvfR1wvY6Bw93mb3/Obm/hZkndQNb5+tn8w0E87XleR/SIm7NgyYsdgKSwRyEDMl7vAGpR55lRle3uPK9r3D483vsvv4p9eaA9pWrhMsD3PtHDN96ggVPTJGNnuPsDGoDF8r7pjmt6cdAlRz1dEZVefLAcJcq2geR0IfhMz3S44baWgY7A+LpFAseb4Z3Bs6w7HAuL+ZgxabFd+/NMicrXxwjIiK/RAFLZMmFM/2Wfs8Acu4eQg5znpzPl+OC82UHIBlniTKGqSzDeCvVq/khwa6bt9UNWijN392f0fOl4jOeMRisM5tOWA+e5rN9wBi3kRajJZWlR4OUEjlAFwf/WuUjGm0IHDaREIxhm9ge9WlyYhThX3zny/yrP9sHHI8GPSoysYls9Aec5MClqs/Z9JgHdc3ZaMThbIZ1owTm92v5hZQKVmlwn9+wyjlGVTnepk0tTUwlkC7tvvPB0yfgnCelRMwJV5Vlq3n9yGHgy87M/uUhbtTDJ3AulKno/cDw9pdYv7aJP4Ow1Wf84zexkxrLCcyTDF76zrdw/YqcM7t37jGuy1mMw51trjx3lfzmZ6SeK4NgM4tKji31nJktBfSuiMfysUaLah4lcEe6MQ8lvG+/+jxr62vc+48/I0fAOWKMpLcfM1lz9GujtkTAkXIk3N4i35nhxxU+GTFGnv3NL3F2OKMKffzYyLnMW6NfEW56tm9t0uy1pJ2KejalN+phg0CcRTIRl6H1jtl4RrZMNkflw1L/YPeee6r/7LxK+Sv/pyby/z0FLJFfRVcxycyX/AySI5O7ZcBSAcBK35XvHo6eskw438nnuwZ3KD0+83MCs2XomuhLSHOlkmBGMggRFotRMbP8JFsOVfPVuQsvfVFGMWL3+ts2sdbvU8eW603ka5NIdIm9keNffv/H5Oxohw432OQwQN00hKqiaSOHHi73+pAyW4MBT6ZjIm2ZT+8ufux54CiDKcvrsATJJaoQSpDC41Kimi9BkSGD954UI8FXRJcIMWLmMZfLoE26SpY5qo0hg8trjN/dJzpHtCnkzOhLW8zu73H06T2uP3+Lvbc+IGDc+YvXwXnaGMkx8uEbb9EbDGjrKdPTKc/83nexEDjdPSQNh/huaTg/dYPPe7C6a1uErPOeuPPP1PLnzBY7B2P23Ph7L3L6+kPuPbhfzjrcDvQy7PzDbzNrJoyubtOkhtmHu8z+/bv0ArSfHBPPynE8zpd7efLeHr7fYxxqvBltiuRpiz+cEsk8eeNsEfTzwGj2zmjN6LuAC0ayTJvLWZnmHb77wsHmje556fWnXOazLe0eVDFL5JwClsiSL2pSnrOuZFQmvttiYjmAd1b6VOx8ycrFLnBRdrSVpcFAdBEiuK9twk/PwCKWu3PregGXPNME49TQMC1LXD7inWd2Fkipq5zkbqL3YufZ4pV2daoLL7471C7RkmhTZlrPIM245adcO5twlDLHp55JZUx84NP+gIOmZn+acSmRZ7H0prXw6vNXeTKt+fjxIROryqwql3EplzP1nm78ttIj5rrGaev6z3CGy4nKW+lNWvpuGME8wTl8NlK3CcE7V4Jpt5MxG1y6dZ3Dx4/wVakG+u7cxeHz11irjzl7/zNyhOd+6xuc3t1n65Wvkx4fUG2scXT/c6rNNXprQz57+wPiyZSUalztGFzbxirX7aTjl2Y9Pb0s+3TQWATGrjI6XxIu09rLr9e+epmjtz+n2Z0RgsNlo//cDvXpKc2Hu/gEx6/fJzy/RXywj8VE9o6z8ZSUEsGF0pTuAmmSqI9nJKDddLSPTjHnaYMRuw0N5n3pBxt4cgPNLJKd65rYDe8N8/OqrMN5t3R9LPrrcpmJWqbOP/1+ExEFLJFl8yXCX+oa6nqJPOWreMdSdaLbXeW7ZbB543rbPbCCecpxJxAt46PRWqI3CIydL0uDQCIR+0PscsVZM+Wj6REc7cHRhCdf8dSXK9auVgxPpyVgzVfTvqDhuLy2pevo+n9OJjW//coNmpj5ujm8v85rzSk5V6QMzhKNQYuxlTN/N/eI2UgudctemYzjzDJrgz7funmVTOLF8QkVJTAtlo7mOzJzLkM/u39O3TqTGeS+p2kaqhRwdt7Xk7qdnN67xdDN+Vym5YGXmIOc8P0AqQsCbl5pydQHJzx/8xa7H93n7MkuW1++xtm9++S+Ixw05NjgN9aYNccM14fM9k/xLuBzZvDMgJ32FhweU1vVBevuCBkr74enZVjMIFv+U5v3wXeV0MUSpxlrN3cY/+gx5hyhbD6l+eSATCQ/uE+kIWejeadMgQ+9Hi7ALJXA67rQX8K8o9cLpJxIa55mEHAZ+t++xtkb98mDPlWdyucmdvs+QwlX3vxiJIP3DgcXDh2fL9/OlzkB2sX5mud/LiKFApbIknm4uvicON8FN98ZOK9iRVeqEeUrfWO+EOacWywNLiofruww8y9eYrSzwcFPP8Ny2a1YlmQ8Jz9+j0u/83We6Tn87Ui6vYMBt3PEZU86yXxiRt01V+d5U0znYtg6v5Ly7DNmH+3y6r1dznKEGInO0cZcJsA7h6sC9WyG+YDPBqmcLdemlpxbUjAGlzeZPj4mJEebYwkV0xl41z1sDawsn164j/l8l+Z8X2Oq69K/5eZ9TOU++24Xp/OlipJSBkuLERDzgFWO5JnPAXNlJlh36S5DGA1o3vqU3/+TP6Z2LZnMlb//R6RRj7zWY7y/R3AVfn2D5uiI3/iT38eHTMLBkzGn790vffXeYea6vrfzZd6n2fLFzpcJyTSuwXLAJysHbueuCkoqA2WbtpuIbosjaRwOqjIPrXpuROj3yOWQQoiJhogRMOcXDfblQ5f3Y4qBXgiEBO3Hx3hf0fQ8Pvtyr7cGNPkUPy1ByrsSsBYha3Gd3ec0Z3JlUDnMel2wrcin07JcePEGiPzaU8ASmbOlJZ6U5l3L2LBPsxYYPJmBrzDnCaFM1PaUwknCYd4RutZ1180LclYezM6Vf1c16uEHA2Y/uY9znkyLZQ8Y2SVsljj44c9p6oambYmpVHxiF2Sq4Pnyled4dHzAaT0Bd3Fq+9Nzmb7gEulvrFOfTmj394ijimhGPprgnr/K8d1H+IGj2lhjdjLDUsJiKMf2AC63xP09Qizzo8wMN6pI7byqVz5Gyolg5X8vaR5a55WdeTDsdgyaBeYh9unrqLqhrczDrVtq8jIrwWIe5Fw3yrTrOctA8kY+q3n0/b+kpmWSZ2zNBjTe8OuBeu+QameLth8Idcts0uLahPlE9vNRHSU2Opv3zv0qKeL877heBaNAOp2V4OMC3nu8LzsfY86EZ7eI90/wFhbri/Mfgzl87UjNhPH9gy7WZape6Yn7ok0ZGPjDumygCI5eDSn0CHXGXPdlwH5DZT0a1174QgDm8+CWljqtm4t1ZYTLgfrwEOv3cFf7xHpKnipbiTzN8l/XdCLya+TkjQ84/sk73QzJvKiCnNy6RLPVo5pk3NoQYneor0GVoMmx9Fj1PC478pt3CDETUwvMz+OjFDWurpEenpAX1Z753r883/nf7ZjLZZmn6+E5nzJUvl0bbXHSTGnalsqHbnnyl3uAlpvhc9cU3jrD37rC5NPPiXULV7aI9/eIvgSU4Bz+8gYczzBfXg8VpGwQEz0q6vG0LHUNHM10VvqAsnUVHtf1m503hs+rImVdM9G7cYnm4eF5DWj56Zwv/FTuznyG1tPhsbtpwxuXODsak0/rpd64THVjm9m9A2KGZIk6NmzkETURekYzmRFCRXKl5yi2Ebp5WilA7vqdbOljeTOC93hzXYA+fznOSsCeV+POX2eintWL33PzJWXLhK9ep36wTz5usDB/V3Sfw+5gSZehIUIbSVZ2g4Yq0LZtqcCZO79h3S9iWc9bqqN138y6YbLlPsWUums5D1fY8nuz+zx078k2tsSYaEgEc/SqiuA8Gdj67jfY/O43EBEFLBEREZGVc//3vyIiIiIi/y8UsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERWTAFLREREZMUUsERERERW7H8DGNDQl3UYknoAAAAASUVORK5CYII=";

var img$1 = "data:image/svg+xml,%3csvg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='114.95522' height='93.54198' viewBox='0%2c0%2c114.95522%2c93.54198'%3e%3cg transform='translate(-182.52239%2c-133.22901)'%3e%3cg data-paper-data='%7b%26quot%3bisPaintingLayer%26quot%3b:true%7d' fill-rule='nonzero' stroke-linecap='butt' stroke-linejoin='miter' stroke-miterlimit='10' stroke-dasharray='' stroke-dashoffset='0' style='mix-blend-mode: normal'%3e%3cpath d='M183.52239%2c225.77099v-91.54198h112.95522v91.54198z' fill='%23ff6671' stroke='black' stroke-width='2'/%3e%3ctext transform='translate(197.81279%2c192.16837) scale(1.05468%2c1.05468)' font-size='40' xml:space='preserve' fill='white' fill-rule='nonzero' stroke='none' stroke-width='1' stroke-linecap='butt' stroke-linejoin='miter' stroke-miterlimit='10' stroke-dasharray='' stroke-dashoffset='0' font-family='Sans Serif' font-weight='normal' text-anchor='start' style='mix-blend-mode: normal'%3e%3ctspan x='0' dy='0'%3e%e3%81%b4%e3%81%93%3c/tspan%3e%3c/text%3e%3c/g%3e%3c/g%3e%3c/svg%3e";

var en$1 = {
	"pcratchPico.entry.name": "Pcratch Pico Extension",
	"pcratchPico.entry.description": "Control Micro-Python devices"
};
var ja$1 = {
	"pcratchPico.entry.name": "ぷくらっち ぴこ 拡張機能",
	"pcratchPico.entry.description": "Micro-Pythonデバイスを制御する"
};
var translations$1 = {
	en: en$1,
	ja: ja$1,
	"ja-Hira": {
	"pcratchPico.entry.name": "ぷくらっち ぴこ かくちょうきのう",
	"pcratchPico.entry.description": "マイクロパイソンデバイスをせいぎょする"
}
};

/**
 * This is an extension for Xcratch.
 */


/**
 * Formatter to translate the messages in this extension.
 * This will be replaced which is used in the React component.
 * @param {object} messageData - data for format-message
 * @returns {string} - translated message for the current locale
 */
var formatMessage$1 = function formatMessage(messageData) {
  return messageData.defaultMessage;
};
var version = 'v0.9.1';
var entry = {
  get name() {
    return "".concat(formatMessage$1({
      id: 'pcratchPico.entry.name',
      defaultMessage: 'Pcratch Pico controll Micro-Python device',
      description: 'Pcratch Pico'
    }), " (").concat(version, ")");
  },
  extensionId: 'pcratchPico',
  extensionURL: 'https://xcratch.github.io/xcx-example/dist/pcratchPico.mjs',
  collaborator: 'xcratch',
  iconURL: img$2,
  insetIconURL: img$1,
  get description() {
    return formatMessage$1({
      defaultMessage: 'an extension for Xcratch',
      description: 'Description for this extension',
      id: 'pcratchPico.entry.description'
    });
  },
  featured: true,
  disabled: false,
  bluetoothRequired: false,
  internetConnectionRequired: false,
  launchPeripheralConnectionFlow: true,
  useAutoScan: false,
  connectionIconURL: img$1,
  connectionSmallIconURL: img$1,
  get connectingMessage() {
    return formatMessage$1({
      defaultMessage: 'Connecting',
      description: 'Message to help people connect to their micro:bit.',
      id: 'gui.extension.microbit.connectingMessage'
    });
  },
  helpLink: 'https://xcratch.github.io/xcx-example/',
  setFormatMessage: function setFormatMessage(formatter) {
    formatMessage$1 = formatter;
  },
  translationMap: translations$1
};

function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}

function _typeof$1(o) {
  "@babel/helpers - typeof";

  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof$1(o);
}

function toPrimitive(t, r) {
  if ("object" != _typeof$1(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r );
    if ("object" != _typeof$1(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (String )(t);
}

function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof$1(i) ? i : i + "";
}

function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

/**
 * Types of block
 * @enum {string}
 */
var BlockType = {
  /**
   * Boolean reporter with hexagonal shape
   */
  BOOLEAN: 'Boolean',
  /**
   * A button (not an actual block) for some special action, like making a variable
   */
  BUTTON: 'button',
  /**
   * Command block
   */
  COMMAND: 'command',
  /**
   * Specialized command block which may or may not run a child branch
   * The thread continues with the next block whether or not a child branch ran.
   */
  CONDITIONAL: 'conditional',
  /**
   * Specialized hat block with no implementation function
   * This stack only runs if the corresponding event is emitted by other code.
   */
  EVENT: 'event',
  /**
   * Hat block which conditionally starts a block stack
   */
  HAT: 'hat',
  /**
   * Specialized command block which may or may not run a child branch
   * If a child branch runs, the thread evaluates the loop block again.
   */
  LOOP: 'loop',
  /**
   * General reporter with numeric or string value
   */
  REPORTER: 'reporter'
};
var blockType = BlockType;
var BlockType$1 = /*@__PURE__*/getDefaultExportFromCjs(blockType);

/**
 * Block argument types
 * @enum {string}
 */
var ArgumentType = {
  /**
   * Numeric value with angle picker
   */
  ANGLE: 'angle',
  /**
   * Boolean value with hexagonal placeholder
   */
  BOOLEAN: 'Boolean',
  /**
   * Numeric value with color picker
   */
  COLOR: 'color',
  /**
   * Numeric value with text field
   */
  NUMBER: 'number',
  /**
   * String value with text field
   */
  STRING: 'string',
  /**
   * String value with matrix field
   */
  MATRIX: 'matrix',
  /**
   * MIDI note number with note picker (piano) field
   */
  NOTE: 'note',
  /**
   * Inline image on block (as part of the label)
   */
  IMAGE: 'image'
};
var argumentType = ArgumentType;
var ArgumentType$1 = /*@__PURE__*/getDefaultExportFromCjs(argumentType);

var Color$1 = /*#__PURE__*/function () {
  function Color() {
    _classCallCheck(this, Color);
  }
  return _createClass(Color, null, [{
    key: "RGB_BLACK",
    get:
    /**
     * @typedef {object} RGBObject - An object representing a color in RGB format.
     * @property {number} r - the red component, in the range [0, 255].
     * @property {number} g - the green component, in the range [0, 255].
     * @property {number} b - the blue component, in the range [0, 255].
     */

    /**
     * @typedef {object} HSVObject - An object representing a color in HSV format.
     * @property {number} h - hue, in the range [0-359).
     * @property {number} s - saturation, in the range [0,1].
     * @property {number} v - value, in the range [0,1].
     */

    /** @type {RGBObject} */
    function get() {
      return {
        r: 0,
        g: 0,
        b: 0
      };
    }

    /** @type {RGBObject} */
  }, {
    key: "RGB_WHITE",
    get: function get() {
      return {
        r: 255,
        g: 255,
        b: 255
      };
    }

    /**
     * Convert a Scratch decimal color to a hex string, #RRGGBB.
     * @param {number} decimal RGB color as a decimal.
     * @return {string} RGB color as #RRGGBB hex string.
     */
  }, {
    key: "decimalToHex",
    value: function decimalToHex(decimal) {
      if (decimal < 0) {
        decimal += 0xFFFFFF + 1;
      }
      var hex = Number(decimal).toString(16);
      hex = "#".concat('000000'.substr(0, 6 - hex.length)).concat(hex);
      return hex;
    }

    /**
     * Convert a Scratch decimal color to an RGB color object.
     * @param {number} decimal RGB color as decimal.
     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */
  }, {
    key: "decimalToRgb",
    value: function decimalToRgb(decimal) {
      var a = decimal >> 24 & 0xFF;
      var r = decimal >> 16 & 0xFF;
      var g = decimal >> 8 & 0xFF;
      var b = decimal & 0xFF;
      return {
        r: r,
        g: g,
        b: b,
        a: a > 0 ? a : 255
      };
    }

    /**
     * Convert a hex color (e.g., F00, #03F, #0033FF) to an RGB color object.
     * CC-BY-SA Tim Down:
     * https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
     * @param {!string} hex Hex representation of the color.
     * @return {RGBObject} null on failure, or rgb: {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */
  }, {
    key: "hexToRgb",
    value: function hexToRgb(hex) {
      var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      hex = hex.replace(shorthandRegex, function (m, r, g, b) {
        return r + r + g + g + b + b;
      });
      var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    }

    /**
     * Convert an RGB color object to a hex color.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @return {!string} Hex representation of the color.
     */
  }, {
    key: "rgbToHex",
    value: function rgbToHex(rgb) {
      return Color.decimalToHex(Color.rgbToDecimal(rgb));
    }

    /**
     * Convert an RGB color object to a Scratch decimal color.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @return {!number} Number representing the color.
     */
  }, {
    key: "rgbToDecimal",
    value: function rgbToDecimal(rgb) {
      return (rgb.r << 16) + (rgb.g << 8) + rgb.b;
    }

    /**
    * Convert a hex color (e.g., F00, #03F, #0033FF) to a decimal color number.
    * @param {!string} hex Hex representation of the color.
    * @return {!number} Number representing the color.
    */
  }, {
    key: "hexToDecimal",
    value: function hexToDecimal(hex) {
      return Color.rgbToDecimal(Color.hexToRgb(hex));
    }

    /**
     * Convert an HSV color to RGB format.
     * @param {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */
  }, {
    key: "hsvToRgb",
    value: function hsvToRgb(hsv) {
      var h = hsv.h % 360;
      if (h < 0) h += 360;
      var s = Math.max(0, Math.min(hsv.s, 1));
      var v = Math.max(0, Math.min(hsv.v, 1));
      var i = Math.floor(h / 60);
      var f = h / 60 - i;
      var p = v * (1 - s);
      var q = v * (1 - s * f);
      var t = v * (1 - s * (1 - f));
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 0:
          r = v;
          g = t;
          b = p;
          break;
        case 1:
          r = q;
          g = v;
          b = p;
          break;
        case 2:
          r = p;
          g = v;
          b = t;
          break;
        case 3:
          r = p;
          g = q;
          b = v;
          break;
        case 4:
          r = t;
          g = p;
          b = v;
          break;
        case 5:
          r = v;
          g = p;
          b = q;
          break;
      }
      return {
        r: Math.floor(r * 255),
        g: Math.floor(g * 255),
        b: Math.floor(b * 255)
      };
    }

    /**
     * Convert an RGB color to HSV format.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @return {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
     */
  }, {
    key: "rgbToHsv",
    value: function rgbToHsv(rgb) {
      var r = rgb.r / 255;
      var g = rgb.g / 255;
      var b = rgb.b / 255;
      var x = Math.min(Math.min(r, g), b);
      var v = Math.max(Math.max(r, g), b);

      // For grays, hue will be arbitrarily reported as zero. Otherwise, calculate
      var h = 0;
      var s = 0;
      if (x !== v) {
        var f = r === x ? g - b : g === x ? b - r : r - g;
        var i = r === x ? 3 : g === x ? 5 : 1;
        h = (i - f / (v - x)) * 60 % 360;
        s = (v - x) / v;
      }
      return {
        h: h,
        s: s,
        v: v
      };
    }

    /**
     * Linear interpolation between rgb0 and rgb1.
     * @param {RGBObject} rgb0 - the color corresponding to fraction1 <= 0.
     * @param {RGBObject} rgb1 - the color corresponding to fraction1 >= 1.
     * @param {number} fraction1 - the interpolation parameter. If this is 0.5, for example, mix the two colors equally.
     * @return {RGBObject} the interpolated color.
     */
  }, {
    key: "mixRgb",
    value: function mixRgb(rgb0, rgb1, fraction1) {
      if (fraction1 <= 0) return rgb0;
      if (fraction1 >= 1) return rgb1;
      var fraction0 = 1 - fraction1;
      return {
        r: fraction0 * rgb0.r + fraction1 * rgb1.r,
        g: fraction0 * rgb0.g + fraction1 * rgb1.g,
        b: fraction0 * rgb0.b + fraction1 * rgb1.b
      };
    }
  }]);
}();
var color$3 = Color$1;

var Color = color$3;

/**
 * @fileoverview
 * Utilities for casting and comparing Scratch data-types.
 * Scratch behaves slightly differently from JavaScript in many respects,
 * and these differences should be encapsulated below.
 * For example, in Scratch, add(1, join("hello", world")) -> 1.
 * This is because "hello world" is cast to 0.
 * In JavaScript, 1 + Number("hello" + "world") would give you NaN.
 * Use when coercing a value before computation.
 */
var Cast = /*#__PURE__*/function () {
  function Cast() {
    _classCallCheck(this, Cast);
  }
  return _createClass(Cast, null, [{
    key: "toNumber",
    value:
    /**
     * Scratch cast to number.
     * Treats NaN as 0.
     * In Scratch 2.0, this is captured by `interp.numArg.`
     * @param {*} value Value to cast to number.
     * @return {number} The Scratch-casted number value.
     */
    function toNumber(value) {
      // If value is already a number we don't need to coerce it with
      // Number().
      if (typeof value === 'number') {
        // Scratch treats NaN as 0, when needed as a number.
        // E.g., 0 + NaN -> 0.
        if (Number.isNaN(value)) {
          return 0;
        }
        return value;
      }
      if (typeof value === 'string') {
        // Replace full-width numbers with half-width ones.
        value = value.replace(/[０-９＋．ｅ]/g, function (s) {
          return String.fromCharCode(s.charCodeAt(0) - 0xFEE0);
        });
        value = value.replace(/[-－﹣−‐⁃‑‒–—﹘―⎯⏤ーｰ─━]/g, '-');
      }
      var n = Number(value);
      if (Number.isNaN(n)) {
        // Scratch treats NaN as 0, when needed as a number.
        // E.g., 0 + NaN -> 0.
        return 0;
      }
      return n;
    }

    /**
     * Scratch cast to boolean.
     * In Scratch 2.0, this is captured by `interp.boolArg.`
     * Treats some string values differently from JavaScript.
     * @param {*} value Value to cast to boolean.
     * @return {boolean} The Scratch-casted boolean value.
     */
  }, {
    key: "toBoolean",
    value: function toBoolean(value) {
      // Already a boolean?
      if (typeof value === 'boolean') {
        return value;
      }
      if (typeof value === 'string') {
        // These specific strings are treated as false in Scratch.
        if (value === '' || value === '0' || value.toLowerCase() === 'false') {
          return false;
        }
        // All other strings treated as true.
        return true;
      }
      // Coerce other values and numbers.
      return Boolean(value);
    }

    /**
     * Scratch cast to string.
     * @param {*} value Value to cast to string.
     * @return {string} The Scratch-casted string value.
     */
  }, {
    key: "toString",
    value: function toString(value) {
      return String(value).replace(/\\n/g, '\n').replace(/\\t/g, '\t');
    }

    /**
     * Cast any Scratch argument to an RGB color array to be used for the renderer.
     * @param {*} value Value to convert to RGB color array.
     * @return {Array.<number>} [r,g,b], values between 0-255.
     */
  }, {
    key: "toRgbColorList",
    value: function toRgbColorList(value) {
      var color = Cast.toRgbColorObject(value);
      return [color.r, color.g, color.b];
    }

    /**
     * Cast any Scratch argument to an RGB color object to be used for the renderer.
     * @param {*} value Value to convert to RGB color object.
     * @return {RGBOject} [r,g,b], values between 0-255.
     */
  }, {
    key: "toRgbColorObject",
    value: function toRgbColorObject(value) {
      var color;
      if (typeof value === 'string' && value.substring(0, 1) === '#') {
        color = Color.hexToRgb(value);

        // If the color wasn't *actually* a hex color, cast to black
        if (!color) color = {
          r: 0,
          g: 0,
          b: 0,
          a: 255
        };
      } else {
        color = Color.decimalToRgb(Cast.toNumber(value));
      }
      return color;
    }

    /**
     * Determine if a Scratch argument is a white space string (or null / empty).
     * @param {*} val value to check.
     * @return {boolean} True if the argument is all white spaces or null / empty.
     */
  }, {
    key: "isWhiteSpace",
    value: function isWhiteSpace(val) {
      return val === null || typeof val === 'string' && val.trim().length === 0;
    }

    /**
     * Compare two values, using Scratch cast, case-insensitive string compare, etc.
     * In Scratch 2.0, this is captured by `interp.compare.`
     * @param {*} v1 First value to compare.
     * @param {*} v2 Second value to compare.
     * @returns {number} Negative number if v1 < v2; 0 if equal; positive otherwise.
     */
  }, {
    key: "compare",
    value: function compare(v1, v2) {
      var n1 = Number(v1);
      var n2 = Number(v2);
      if (n1 === 0 && Cast.isWhiteSpace(v1)) {
        n1 = NaN;
      } else if (n2 === 0 && Cast.isWhiteSpace(v2)) {
        n2 = NaN;
      }
      if (isNaN(n1) || isNaN(n2)) {
        // At least one argument can't be converted to a number.
        // Scratch compares strings as case insensitive.
        var s1 = Cast.toString(v1).toLowerCase();
        var s2 = Cast.toString(v2).toLowerCase();
        if (s1 < s2) {
          return -1;
        } else if (s1 > s2) {
          return 1;
        }
        return 0;
      }
      // Handle the special case of Infinity
      if (n1 === Infinity && n2 === Infinity || n1 === -Infinity && n2 === -Infinity) {
        return 0;
      }
      // Compare as numbers.
      return n1 - n2;
    }

    /**
     * Determine if a Scratch argument number represents a round integer.
     * @param {*} val Value to check.
     * @return {boolean} True if number looks like an integer.
     */
  }, {
    key: "isInt",
    value: function isInt(val) {
      // Values that are already numbers.
      if (typeof val === 'number') {
        if (isNaN(val)) {
          // NaN is considered an integer.
          return true;
        }
        // True if it's "round" (e.g., 2.0 and 2).
        return val === parseInt(val, 10);
      } else if (typeof val === 'boolean') {
        // `True` and `false` always represent integer after Scratch cast.
        return true;
      } else if (typeof val === 'string') {
        // If it contains a decimal point, don't consider it an int.
        return val.indexOf('.') < 0;
      }
      return false;
    }
  }, {
    key: "LIST_INVALID",
    get: function get() {
      return 'INVALID';
    }
  }, {
    key: "LIST_ALL",
    get: function get() {
      return 'ALL';
    }

    /**
     * Compute a 1-based index into a list, based on a Scratch argument.
     * Two special cases may be returned:
     * LIST_ALL: if the block is referring to all of the items in the list.
     * LIST_INVALID: if the index was invalid in any way.
     * @param {*} index Scratch arg, including 1-based numbers or special cases.
     * @param {number} length Length of the list.
     * @param {boolean} acceptAll Whether it should accept "all" or not.
     * @return {(number|string)} 1-based index for list, LIST_ALL, or LIST_INVALID.
     */
  }, {
    key: "toListIndex",
    value: function toListIndex(index, length, acceptAll) {
      if (typeof index !== 'number') {
        if (index === 'all') {
          return acceptAll ? Cast.LIST_ALL : Cast.LIST_INVALID;
        }
        if (index === 'last') {
          if (length > 0) {
            return length;
          }
          return Cast.LIST_INVALID;
        } else if (index === 'random' || index === 'any') {
          if (length > 0) {
            return 1 + Math.floor(Math.random() * length);
          }
          return Cast.LIST_INVALID;
        }
      }
      index = Math.floor(Cast.toNumber(index));
      if (index < 1 || index > length) {
        return Cast.LIST_INVALID;
      }
      return index;
    }
  }]);
}();
var cast = Cast;
var Cast$1 = /*@__PURE__*/getDefaultExportFromCjs(cast);

var web = {exports: {}};

var minilog$2 = {exports: {}};

function M() {
  this._events = {};
}
M.prototype = {
  on: function on(ev, cb) {
    this._events || (this._events = {});
    var e = this._events;
    (e[ev] || (e[ev] = [])).push(cb);
    return this;
  },
  removeListener: function removeListener(ev, cb) {
    var e = this._events[ev] || [],
      i;
    for (i = e.length - 1; i >= 0 && e[i]; i--) {
      if (e[i] === cb || e[i].cb === cb) {
        e.splice(i, 1);
      }
    }
  },
  removeAllListeners: function removeAllListeners(ev) {
    if (!ev) {
      this._events = {};
    } else {
      this._events[ev] && (this._events[ev] = []);
    }
  },
  listeners: function listeners(ev) {
    return this._events ? this._events[ev] || [] : [];
  },
  emit: function emit(ev) {
    this._events || (this._events = {});
    var args = Array.prototype.slice.call(arguments, 1),
      i,
      e = this._events[ev] || [];
    for (i = e.length - 1; i >= 0 && e[i]; i--) {
      e[i].apply(this, args);
    }
    return this;
  },
  when: function when(ev, cb) {
    return this.once(ev, cb, true);
  },
  once: function once(ev, cb, when) {
    if (!cb) return this;
    function c() {
      if (!when) this.removeListener(ev, c);
      if (cb.apply(this, arguments) && when) this.removeListener(ev, c);
    }
    c.cb = cb;
    this.on(ev, c);
    return this;
  }
};
M.mixin = function (dest) {
  var o = M.prototype,
    k;
  for (k in o) {
    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);
  }
};
var microee$1 = M;

var microee = microee$1;

// Implements a subset of Node's stream.Transform - in a cross-platform manner.
function Transform$4() {}
microee.mixin(Transform$4);

// The write() signature is different from Node's
// --> makes it much easier to work with objects in logs.
// One of the lessons from v1 was that it's better to target
// a good browser rather than the lowest common denominator
// internally.
// If you want to use external streams, pipe() to ./stringify.js first.
Transform$4.prototype.write = function (name, level, args) {
  this.emit('item', name, level, args);
};
Transform$4.prototype.end = function () {
  this.emit('end');
  this.removeAllListeners();
};
Transform$4.prototype.pipe = function (dest) {
  var s = this;
  // prevent double piping
  s.emit('unpipe', dest);
  // tell the dest that it's being piped to
  dest.emit('pipe', s);
  function onItem() {
    dest.write.apply(dest, Array.prototype.slice.call(arguments));
  }
  function onEnd() {
    !dest._isStdio && dest.end();
  }
  s.on('item', onItem);
  s.on('end', onEnd);
  s.when('unpipe', function (from) {
    var match = from === dest || typeof from == 'undefined';
    if (match) {
      s.removeListener('item', onItem);
      s.removeListener('end', onEnd);
      dest.emit('unpipe');
    }
    return match;
  });
  return dest;
};
Transform$4.prototype.unpipe = function (from) {
  this.emit('unpipe', from);
  return this;
};
Transform$4.prototype.format = function (dest) {
  throw new Error(['Warning: .format() is deprecated in Minilog v2! Use .pipe() instead. For example:', 'var Minilog = require(\'minilog\');', 'Minilog', '  .pipe(Minilog.backends.console.formatClean)', '  .pipe(Minilog.backends.console);'].join('\n'));
};
Transform$4.mixin = function (dest) {
  var o = Transform$4.prototype,
    k;
  for (k in o) {
    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);
  }
};
var transform = Transform$4;

// default filter
var Transform$3 = transform;
var levelMap = {
  debug: 1,
  info: 2,
  warn: 3,
  error: 4
};
function Filter() {
  this.enabled = true;
  this.defaultResult = true;
  this.clear();
}
Transform$3.mixin(Filter);

// allow all matching, with level >= given level
Filter.prototype.allow = function (name, level) {
  this._white.push({
    n: name,
    l: levelMap[level]
  });
  return this;
};

// deny all matching, with level <= given level
Filter.prototype.deny = function (name, level) {
  this._black.push({
    n: name,
    l: levelMap[level]
  });
  return this;
};
Filter.prototype.clear = function () {
  this._white = [];
  this._black = [];
  return this;
};
function test(rule, name) {
  // use .test for RegExps
  return rule.n.test ? rule.n.test(name) : rule.n == name;
}
Filter.prototype.test = function (name, level) {
  var i,
    len = Math.max(this._white.length, this._black.length);
  for (i = 0; i < len; i++) {
    if (this._white[i] && test(this._white[i], name) && levelMap[level] >= this._white[i].l) {
      return true;
    }
    if (this._black[i] && test(this._black[i], name) && levelMap[level] <= this._black[i].l) {
      return false;
    }
  }
  return this.defaultResult;
};
Filter.prototype.write = function (name, level, args) {
  if (!this.enabled || this.test(name, level)) {
    return this.emit('item', name, level, args);
  }
};
var filter = Filter;

(function (module, exports) {
  var Transform = transform,
    Filter = filter;
  var log = new Transform(),
    slice = Array.prototype.slice;
  exports = module.exports = function create(name) {
    var o = function o() {
      log.write(name, undefined, slice.call(arguments));
      return o;
    };
    o.debug = function () {
      log.write(name, 'debug', slice.call(arguments));
      return o;
    };
    o.info = function () {
      log.write(name, 'info', slice.call(arguments));
      return o;
    };
    o.warn = function () {
      log.write(name, 'warn', slice.call(arguments));
      return o;
    };
    o.error = function () {
      log.write(name, 'error', slice.call(arguments));
      return o;
    };
    o.log = o.debug; // for interface compliance with Node and browser consoles
    o.suggest = exports.suggest;
    o.format = log.format;
    return o;
  };

  // filled in separately
  exports.defaultBackend = exports.defaultFormatter = null;
  exports.pipe = function (dest) {
    return log.pipe(dest);
  };
  exports.end = exports.unpipe = exports.disable = function (from) {
    return log.unpipe(from);
  };
  exports.Transform = Transform;
  exports.Filter = Filter;
  // this is the default filter that's applied when .enable() is called normally
  // you can bypass it completely and set up your own pipes
  exports.suggest = new Filter();
  exports.enable = function () {
    if (exports.defaultFormatter) {
      return log.pipe(exports.suggest) // filter
      .pipe(exports.defaultFormatter) // formatter
      .pipe(exports.defaultBackend); // backend
    }
    return log.pipe(exports.suggest) // filter
    .pipe(exports.defaultBackend); // formatter
  };
})(minilog$2, minilog$2.exports);
var minilogExports = minilog$2.exports;

var hex = {
  black: '#000',
  red: '#c23621',
  green: '#25bc26',
  yellow: '#bbbb00',
  blue: '#492ee1',
  magenta: '#d338d3',
  cyan: '#33bbc8',
  gray: '#808080',
  purple: '#708'
};
function color$2(fg, isInverse) {
  if (isInverse) {
    return 'color: #fff; background: ' + hex[fg] + ';';
  } else {
    return 'color: ' + hex[fg] + ';';
  }
}
var util = color$2;

var Transform$2 = transform,
  color$1 = util;
var colors$1 = {
    debug: ['cyan'],
    info: ['purple'],
    warn: ['yellow', true],
    error: ['red', true]
  },
  logger$2 = new Transform$2();
logger$2.write = function (name, level, args) {
  var fn = console.log;
  if (console[level] && console[level].apply) {
    fn = console[level];
    fn.apply(console, ['%c' + name + ' %c' + level, color$1('gray'), color$1.apply(color$1, colors$1[level])].concat(args));
  }
};

// NOP, because piping the formatted logs can only cause trouble.
logger$2.pipe = function () {};
var color_1 = logger$2;

var Transform$1 = transform,
  color = util,
  colors = {
    debug: ['gray'],
    info: ['purple'],
    warn: ['yellow', true],
    error: ['red', true]
  },
  logger$1 = new Transform$1();
logger$1.write = function (name, level, args) {
  var fn = console.log;
  if (level != 'debug' && console[level]) {
    fn = console[level];
  }
  var i = 0;
  if (level != 'info') {
    for (; i < args.length; i++) {
      if (typeof args[i] != 'string') break;
    }
    fn.apply(console, ['%c' + name + ' ' + args.slice(0, i).join(' '), color.apply(color, colors[level])].concat(args.slice(i)));
  } else {
    fn.apply(console, ['%c' + name, color.apply(color, colors[level])].concat(args));
  }
};

// NOP, because piping the formatted logs can only cause trouble.
logger$1.pipe = function () {};
var minilog$1 = logger$1;

var Transform = transform;
var newlines = /\n+$/,
  logger = new Transform();
logger.write = function (name, level, args) {
  var i = args.length - 1;
  if (typeof console === 'undefined' || !console.log) {
    return;
  }
  if (console.log.apply) {
    return console.log.apply(console, [name, level].concat(args));
  } else if (JSON && JSON.stringify) {
    // console.log.apply is undefined in IE8 and IE9
    // for IE8/9: make console.log at least a bit less awful
    if (args[i] && typeof args[i] == 'string') {
      args[i] = args[i].replace(newlines, '');
    }
    try {
      for (i = 0; i < args.length; i++) {
        args[i] = JSON.stringify(args[i]);
      }
    } catch (e) {}
    console.log(args.join(' '));
  }
};
logger.formatters = ['color', 'minilog'];
logger.color = color_1;
logger.minilog = minilog$1;
var console_1 = logger;

var array;
var hasRequiredArray;
function requireArray() {
  if (hasRequiredArray) return array;
  hasRequiredArray = 1;
  var Transform = transform,
    cache = [];
  var logger = new Transform();
  logger.write = function (name, level, args) {
    cache.push([name, level, args]);
  };

  // utility functions
  logger.get = function () {
    return cache;
  };
  logger.empty = function () {
    cache = [];
  };
  array = logger;
  return array;
}

var localstorage;
var hasRequiredLocalstorage;
function requireLocalstorage() {
  if (hasRequiredLocalstorage) return localstorage;
  hasRequiredLocalstorage = 1;
  var Transform = transform,
    cache = false;
  var logger = new Transform();
  logger.write = function (name, level, args) {
    if (typeof window == 'undefined' || typeof JSON == 'undefined' || !JSON.stringify || !JSON.parse) return;
    try {
      if (!cache) {
        cache = window.localStorage.minilog ? JSON.parse(window.localStorage.minilog) : [];
      }
      cache.push([new Date().toString(), name, level, args]);
      window.localStorage.minilog = JSON.stringify(cache);
    } catch (e) {}
  };
  localstorage = logger;
  return localstorage;
}

var jquery_simple;
var hasRequiredJquery_simple;
function requireJquery_simple() {
  if (hasRequiredJquery_simple) return jquery_simple;
  hasRequiredJquery_simple = 1;
  var Transform = transform;
  var cid = new Date().valueOf().toString(36);
  function AjaxLogger(options) {
    this.url = options.url || '';
    this.cache = [];
    this.timer = null;
    this.interval = options.interval || 30 * 1000;
    this.enabled = true;
    this.jQuery = window.jQuery;
    this.extras = {};
  }
  Transform.mixin(AjaxLogger);
  AjaxLogger.prototype.write = function (name, level, args) {
    if (!this.timer) {
      this.init();
    }
    this.cache.push([name, level].concat(args));
  };
  AjaxLogger.prototype.init = function () {
    if (!this.enabled || !this.jQuery) return;
    var self = this;
    this.timer = setTimeout(function () {
      var i,
        logs = [],
        ajaxData,
        url = self.url;
      if (self.cache.length == 0) return self.init();
      // Test each log line and only log the ones that are valid (e.g. don't have circular references).
      // Slight performance hit but benefit is we log all valid lines.
      for (i = 0; i < self.cache.length; i++) {
        try {
          JSON.stringify(self.cache[i]);
          logs.push(self.cache[i]);
        } catch (e) {}
      }
      if (self.jQuery.isEmptyObject(self.extras)) {
        ajaxData = JSON.stringify({
          logs: logs
        });
        url = self.url + '?client_id=' + cid;
      } else {
        ajaxData = JSON.stringify(self.jQuery.extend({
          logs: logs
        }, self.extras));
      }
      self.jQuery.ajax(url, {
        type: 'POST',
        cache: false,
        processData: false,
        data: ajaxData,
        contentType: 'application/json',
        timeout: 10000
      }).success(function (data, status, jqxhr) {
        if (data.interval) {
          self.interval = Math.max(1000, data.interval);
        }
      }).error(function () {
        self.interval = 30000;
      }).always(function () {
        self.init();
      });
      self.cache = [];
    }, this.interval);
  };
  AjaxLogger.prototype.end = function () {};

  // wait until jQuery is defined. Useful if you don't control the load order.
  AjaxLogger.jQueryWait = function (onDone) {
    if (typeof window !== 'undefined' && (window.jQuery || window.$)) {
      return onDone(window.jQuery || window.$);
    } else if (typeof window !== 'undefined') {
      setTimeout(function () {
        AjaxLogger.jQueryWait(onDone);
      }, 200);
    }
  };
  jquery_simple = AjaxLogger;
  return jquery_simple;
}

(function (module, exports) {
  var Minilog = minilogExports;
  var oldEnable = Minilog.enable,
    oldDisable = Minilog.disable,
    isChrome = typeof navigator != 'undefined' && /chrome/i.test(navigator.userAgent),
    console = console_1;

  // Use a more capable logging backend if on Chrome
  Minilog.defaultBackend = isChrome ? console.minilog : console;

  // apply enable inputs from localStorage and from the URL
  if (typeof window != 'undefined') {
    try {
      Minilog.enable(JSON.parse(window.localStorage['minilogSettings']));
    } catch (e) {}
    if (window.location && window.location.search) {
      var match = RegExp('[?&]minilog=([^&]*)').exec(window.location.search);
      match && Minilog.enable(decodeURIComponent(match[1]));
    }
  }

  // Make enable also add to localStorage
  Minilog.enable = function () {
    oldEnable.call(Minilog, true);
    try {
      window.localStorage['minilogSettings'] = JSON.stringify(true);
    } catch (e) {}
    return this;
  };
  Minilog.disable = function () {
    oldDisable.call(Minilog);
    try {
      delete window.localStorage.minilogSettings;
    } catch (e) {}
    return this;
  };
  exports = module.exports = Minilog;
  exports.backends = {
    array: requireArray(),
    browser: Minilog.defaultBackend,
    localStorage: requireLocalstorage(),
    jQuery: requireJquery_simple()
  };
})(web, web.exports);
var webExports = web.exports;

var minilog = webExports;
minilog.enable();
var log = minilog('vm');
var log$1 = /*@__PURE__*/getDefaultExportFromCjs(log);

var en = {
	"pcratchPico.connectPico": "Connect to the Micro-Python device [PORT]"
};
var ja = {
	"pcratchPico.name": "ぷくらっちPico拡張機能",
	"pcratchPico.connectPico": "MicroPythonデバイスと接続 [PORT]",
	"pcratchPico.execCommand": "[TEXT] を実行",
	"pcratchPico.sendCtrlCode": "CTRL- [TEXT] を送信",
	"pcratchPico.dumpValue": "デバイスの返却値! [SCRIPT]",
	"pcratchPico.getAdc00": "ADC0",
	"pcratchPico.getAdc01": "ADC1",
	"pcratchPico.getAdc02": "ADC2",
	"pcratchPico.getAdc03": "ADC3",
	"pcratchPico.getAdc04": "ADC4",
	"pcratchPico.lightLevel": "あかるさ"
};
var translations = {
	en: en,
	ja: ja,
	"ja-Hira": {
	"pcratchPico.connectPico": "MicroPythonデバイスとせつぞく [PORT]"
}
};

var img = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAFUmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSfvu78nIGlkPSdXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQnPz4KPHg6eG1wbWV0YSB4bWxuczp4PSdhZG9iZTpuczptZXRhLyc+CjxyZGY6UkRGIHhtbG5zOnJkZj0naHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyc+CgogPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9JycKICB4bWxuczpBdHRyaWI9J2h0dHA6Ly9ucy5hdHRyaWJ1dGlvbi5jb20vYWRzLzEuMC8nPgogIDxBdHRyaWI6QWRzPgogICA8cmRmOlNlcT4KICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0nUmVzb3VyY2UnPgogICAgIDxBdHRyaWI6Q3JlYXRlZD4yMDI0LTExLTAyPC9BdHRyaWI6Q3JlYXRlZD4KICAgICA8QXR0cmliOkV4dElkPjE8L0F0dHJpYjpFeHRJZD4KICAgICA8QXR0cmliOkZiSWQ+NTI1MjY1OTE0MTc5NTgwPC9BdHRyaWI6RmJJZD4KICAgICA8QXR0cmliOlRvdWNoVHlwZT4yPC9BdHRyaWI6VG91Y2hUeXBlPgogICAgPC9yZGY6bGk+CiAgIDwvcmRmOlNlcT4KICA8L0F0dHJpYjpBZHM+CiA8L3JkZjpEZXNjcmlwdGlvbj4KCiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0nJwogIHhtbG5zOkNvbnRhaW5zQWlHZW5lcmF0ZWRDb250ZW50PSdodHRwczovL2NhbnZhLmNvbS9leHBvcnQnPgogIDxDb250YWluc0FpR2VuZXJhdGVkQ29udGVudDpDb250YWluc0FpR2VuZXJhdGVkQ29udGVudD5ZZXM8L0NvbnRhaW5zQWlHZW5lcmF0ZWRDb250ZW50OkNvbnRhaW5zQWlHZW5lcmF0ZWRDb250ZW50PgogPC9yZGY6RGVzY3JpcHRpb24+CgogPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9JycKICB4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";

function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}

var regeneratorRuntime$1 = {exports: {}};

var _typeof = {exports: {}};

(function (module) {
  function _typeof(o) {
    "@babel/helpers - typeof";

    return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(o);
  }
  module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(_typeof);
var _typeofExports = _typeof.exports;

(function (module) {
  var _typeof = _typeofExports["default"];
  function _regeneratorRuntime() {

    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
    module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
      return e;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    var t,
      e = {},
      r = Object.prototype,
      n = r.hasOwnProperty,
      o = Object.defineProperty || function (t, e, r) {
        t[e] = r.value;
      },
      i = "function" == typeof Symbol ? Symbol : {},
      a = i.iterator || "@@iterator",
      c = i.asyncIterator || "@@asyncIterator",
      u = i.toStringTag || "@@toStringTag";
    function define(t, e, r) {
      return Object.defineProperty(t, e, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), t[e];
    }
    try {
      define({}, "");
    } catch (t) {
      define = function define(t, e, r) {
        return t[e] = r;
      };
    }
    function wrap(t, e, r, n) {
      var i = e && e.prototype instanceof Generator ? e : Generator,
        a = Object.create(i.prototype),
        c = new Context(n || []);
      return o(a, "_invoke", {
        value: makeInvokeMethod(t, r, c)
      }), a;
    }
    function tryCatch(t, e, r) {
      try {
        return {
          type: "normal",
          arg: t.call(e, r)
        };
      } catch (t) {
        return {
          type: "throw",
          arg: t
        };
      }
    }
    e.wrap = wrap;
    var h = "suspendedStart",
      l = "suspendedYield",
      f = "executing",
      s = "completed",
      y = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var p = {};
    define(p, a, function () {
      return this;
    });
    var d = Object.getPrototypeOf,
      v = d && d(d(values([])));
    v && v !== r && n.call(v, a) && (p = v);
    var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
    function defineIteratorMethods(t) {
      ["next", "throw", "return"].forEach(function (e) {
        define(t, e, function (t) {
          return this._invoke(e, t);
        });
      });
    }
    function AsyncIterator(t, e) {
      function invoke(r, o, i, a) {
        var c = tryCatch(t[r], t, o);
        if ("throw" !== c.type) {
          var u = c.arg,
            h = u.value;
          return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
            invoke("next", t, i, a);
          }, function (t) {
            invoke("throw", t, i, a);
          }) : e.resolve(h).then(function (t) {
            u.value = t, i(u);
          }, function (t) {
            return invoke("throw", t, i, a);
          });
        }
        a(c.arg);
      }
      var r;
      o(this, "_invoke", {
        value: function value(t, n) {
          function callInvokeWithMethodAndArg() {
            return new e(function (e, r) {
              invoke(t, n, e, r);
            });
          }
          return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(e, r, n) {
      var o = h;
      return function (i, a) {
        if (o === f) throw Error("Generator is already running");
        if (o === s) {
          if ("throw" === i) throw a;
          return {
            value: t,
            done: !0
          };
        }
        for (n.method = i, n.arg = a;;) {
          var c = n.delegate;
          if (c) {
            var u = maybeInvokeDelegate(c, n);
            if (u) {
              if (u === y) continue;
              return u;
            }
          }
          if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
            if (o === h) throw o = s, n.arg;
            n.dispatchException(n.arg);
          } else "return" === n.method && n.abrupt("return", n.arg);
          o = f;
          var p = tryCatch(e, r, n);
          if ("normal" === p.type) {
            if (o = n.done ? s : l, p.arg === y) continue;
            return {
              value: p.arg,
              done: n.done
            };
          }
          "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
        }
      };
    }
    function maybeInvokeDelegate(e, r) {
      var n = r.method,
        o = e.iterator[n];
      if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
      var i = tryCatch(o, e.iterator, r.arg);
      if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
      var a = i.arg;
      return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
    }
    function pushTryEntry(t) {
      var e = {
        tryLoc: t[0]
      };
      1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
    }
    function resetTryEntry(t) {
      var e = t.completion || {};
      e.type = "normal", delete e.arg, t.completion = e;
    }
    function Context(t) {
      this.tryEntries = [{
        tryLoc: "root"
      }], t.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(e) {
      if (e || "" === e) {
        var r = e[a];
        if (r) return r.call(e);
        if ("function" == typeof e.next) return e;
        if (!isNaN(e.length)) {
          var o = -1,
            i = function next() {
              for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
              return next.value = t, next.done = !0, next;
            };
          return i.next = i;
        }
      }
      throw new TypeError(_typeof(e) + " is not iterable");
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: !0
    }), o(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
      var e = "function" == typeof t && t.constructor;
      return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
    }, e.mark = function (t) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
    }, e.awrap = function (t) {
      return {
        __await: t
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
      return this;
    }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
      void 0 === i && (i = Promise);
      var a = new AsyncIterator(wrap(t, r, n, o), i);
      return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
        return t.done ? t.value : a.next();
      });
    }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
      return this;
    }), define(g, "toString", function () {
      return "[object Generator]";
    }), e.keys = function (t) {
      var e = Object(t),
        r = [];
      for (var n in e) r.push(n);
      return r.reverse(), function next() {
        for (; r.length;) {
          var t = r.pop();
          if (t in e) return next.value = t, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, e.values = values, Context.prototype = {
      constructor: Context,
      reset: function reset(e) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
      },
      stop: function stop() {
        this.done = !0;
        var t = this.tryEntries[0].completion;
        if ("throw" === t.type) throw t.arg;
        return this.rval;
      },
      dispatchException: function dispatchException(e) {
        if (this.done) throw e;
        var r = this;
        function handle(n, o) {
          return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
        }
        for (var o = this.tryEntries.length - 1; o >= 0; --o) {
          var i = this.tryEntries[o],
            a = i.completion;
          if ("root" === i.tryLoc) return handle("end");
          if (i.tryLoc <= this.prev) {
            var c = n.call(i, "catchLoc"),
              u = n.call(i, "finallyLoc");
            if (c && u) {
              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
            } else if (c) {
              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            } else {
              if (!u) throw Error("try statement without catch or finally");
              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
            }
          }
        }
      },
      abrupt: function abrupt(t, e) {
        for (var r = this.tryEntries.length - 1; r >= 0; --r) {
          var o = this.tryEntries[r];
          if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
            var i = o;
            break;
          }
        }
        i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
        var a = i ? i.completion : {};
        return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
      },
      complete: function complete(t, e) {
        if ("throw" === t.type) throw t.arg;
        return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
      },
      finish: function finish(t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var r = this.tryEntries[e];
          if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
        }
      },
      "catch": function _catch(t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var r = this.tryEntries[e];
          if (r.tryLoc === t) {
            var n = r.completion;
            if ("throw" === n.type) {
              var o = n.arg;
              resetTryEntry(r);
            }
            return o;
          }
        }
        throw Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(e, r, n) {
        return this.delegate = {
          iterator: values(e),
          resultName: r,
          nextLoc: n
        }, "next" === this.method && (this.arg = t), y;
      }
    }, e;
  }
  module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(regeneratorRuntime$1);
var regeneratorRuntimeExports = regeneratorRuntime$1.exports;

// TODO(Babel 8): Remove this file.

var runtime = regeneratorRuntimeExports();
var regenerator = runtime;

// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if ((typeof globalThis === "undefined" ? "undefined" : _typeof$1(globalThis)) === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}
var _regeneratorRuntime = /*@__PURE__*/getDefaultExportFromCjs(regenerator);

/**
 * PicoSerialクラスは、シリアルポートの選択と接続を管理します。
 */
var SerialProcessor = /*#__PURE__*/function () {
  /**
   * 
   * @param {*} _v_ デバイスから返却作成された値を格納するオブジェクト
   */
  function SerialProcessor(_v_) {
    _classCallCheck(this, SerialProcessor);
    this.buffer = '';
    this._v_ = _v_; // デバイスから返却作成された値を格納するオブジェクトを保存
  }
  return _createClass(SerialProcessor, [{
    key: "processData",
    value: function () {
      var _processData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(reader) {
        var _yield$reader$read, value, done, textDecoder, decodedValue, newlineIndex, line;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 3;
              return reader.read();
            case 3:
              _yield$reader$read = _context.sent;
              value = _yield$reader$read.value;
              done = _yield$reader$read.done;
              if (!done) {
                _context.next = 9;
                break;
              }
              console.log('Disconnected.');
              return _context.abrupt("break", 12);
            case 9:
              if (value) {
                textDecoder = new TextDecoder();
                decodedValue = textDecoder.decode(value);
                this.buffer += decodedValue;
                newlineIndex = void 0;
                while ((newlineIndex = this.buffer.indexOf('\n')) !== -1) {
                  line = this.buffer.substring(0, newlineIndex).trim();
                  this.buffer = this.buffer.substring(newlineIndex + 1);
                  this.processLine(line);
                }
              }
              _context.next = 0;
              break;
            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function processData(_x) {
        return _processData.apply(this, arguments);
      }
      return processData;
    }()
  }, {
    key: "processLine",
    value: function processLine(line) {
      if (line.startsWith('_v_=')) {
        var jsonString = line.substring(4);
        try {
          var jsonData = JSON.parse(jsonString);
          if (_typeof$1(this._v_) === 'object' && this._v_ !== null) {
            Object.assign(this._v_, jsonData);
          } else {
            this._v_ = jsonData;
          }
          console.log('Parsed JSON this._v_:', this._v_);
        } catch (e) {
          console.error('Failed to parse JSON:', e);
        }
      } else {
        console.log('Received line:', line);
      }
    }
  }]);
}();
var PicoSerial = /*#__PURE__*/function () {
  function PicoSerial(runtime) {
    var _this = this;
    _classCallCheck(this, PicoSerial);
    // ランタイムを保存
    this._runtime = runtime;
    // 書き込み Stream
    this.picowriter = null;
    // ポート選択ドロップダウン
    this.portSelector = undefined;
    // 接続ボタン
    this.connectButton = undefined;
    this.portCounter = 1; // addNewPort で名前の末尾に付ける番号

    // 現在使用しているポート
    this.picoport = undefined;
    // 現在使用しているリーダー
    this.picoreader = undefined;
    // 接続ステータス
    this.status = 0; // 0:未接続 1:接続中 2:接続済み

    /*
        <select id="ports">
        <option value="prompt">Click 'Connect' to add a port...</option>
        </select>
    */
    // 1. select要素を作成
    var selectElement = document.createElement('select');
    selectElement.id = 'ports';
    // 2. option要素を作成して追加
    var options = [{
      value: 'prompt',
      text: "Click 'Connect' to add a port..."
    }];
    options.forEach(function (optionData) {
      var optionElement = document.createElement('option');
      optionElement.value = optionData.value;
      optionElement.text = optionData.text;
      selectElement.appendChild(optionElement);
    });
    // 3. select要素をDOMに追加
    document.body.appendChild(selectElement);
    this.portSelector = document.getElementById('ports');

    // シリアルポートの接続イベントを監視
    navigator.serial.addEventListener('connect', function (event) {
      console.log('Serial port connected!!:', event);
      // 必要な処理をここに追加
      _this.status = 2;
      _this._runtime.emit(_this._runtime.constructor.PERIPHERAL_CONNECTED);
    });

    // シリアルポートの切断イベントを監視
    navigator.serial.addEventListener('disconnect', function (event) {
      console.log('Serial port disconnected:', event);
      // 必要な処理をここに追加
      // 例えば、UIを更新したり、リソースを解放したりする
      _this.status = 0;
    });
  }

  /**
   * 
   * @returns {boolean} 接続中かどうか
   */
  return _createClass(PicoSerial, [{
    key: "isConnected",
    value: function isConnected() {
      return this.status === 2;
    }
    /**
     * 指定されたSerialPortを検索して返します。
     *
     * @param {SerialPort} port 検索するポート
     * @return {PortOption}
     */
  }, {
    key: "findPortOption",
    value: function findPortOption(port) {
      if (!this.portSelector) return null;
      for (var i = 0; i < this.portSelector.options.length; ++i) {
        var option = this.portSelector.options[i];
        if (option.value === 'prompt') {
          continue;
        }
        var portOption = option;
        if (portOption.port === port) {
          return portOption;
        }
      }
      return null;
    }

    /**
    * 指定されたポートを選択ドロップダウンに追加します。
    *
    * @param {SerialPort} port 追加するポート
    * @return {PortOption}
    */
  }, {
    key: "addNewPort",
    value: function addNewPort(port) {
      var _this$portSelector;
      var portOption = document.createElement('option');
      portOption.textContent = "Port ".concat(this.portCounter++);
      portOption.port = port;
      (_this$portSelector = this.portSelector) === null || _this$portSelector === void 0 || _this$portSelector.appendChild(portOption);
      return portOption;
    }

    /**
    * 指定されたポートを選択ドロップダウンに追加するか、既に存在する場合は既存のオプションを返します。
    *
    * @param {SerialPort} port 追加するポート
    * @return {PortOption}
    */
  }, {
    key: "maybeAddNewPort",
    value: function maybeAddNewPort(port) {
      var portOption = this.findPortOption(port);
      if (portOption) {
        return portOption;
      }
      return this.addNewPort(port);
    }

    /**
    * 現在選択されているポートを |picoport| に設定します。
    * 選択されていない場合は、ユーザーにポートの選択を促します。
    */
  }, {
    key: "getSelectedPort",
    value: (function () {
      var _getSelectedPort = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var _this$portSelector2;
        var serial, portOption, _this$portSelector3, selectedOption;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              console.log('portSelector:', this.portSelector);
              if (!(((_this$portSelector2 = this.portSelector) === null || _this$portSelector2 === void 0 ? void 0 : _this$portSelector2.value) == 'prompt')) {
                _context2.next = 16;
                break;
              }
              _context2.prev = 2;
              serial = navigator.serial;
              _context2.next = 6;
              return serial.requestPort({});
            case 6:
              this.picoport = _context2.sent;
              _context2.next = 12;
              break;
            case 9:
              _context2.prev = 9;
              _context2.t0 = _context2["catch"](2);
              return _context2.abrupt("return");
            case 12:
              portOption = this.maybeAddNewPort(this.picoport);
              portOption.selected = true;
              _context2.next = 18;
              break;
            case 16:
              selectedOption = (_this$portSelector3 = this.portSelector) === null || _this$portSelector3 === void 0 ? void 0 : _this$portSelector3.selectedOptions[0];
              this.picoport = selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.port;
            case 18:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[2, 9]]);
      }));
      function getSelectedPort() {
        return _getSelectedPort.apply(this, arguments);
      }
      return getSelectedPort;
    }()
    /**
    * 接続をクローズします
    */
    )
  }, {
    key: "disconnect",
    value: (function () {
      var _disconnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var localPort;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              // Move |port| into a local variable so that connectToPort() doesn't try to
              // close it on exit.
              localPort = this.picoport;
              this.picoport = undefined;
              if (!this.picoreader) {
                _context3.next = 5;
                break;
              }
              _context3.next = 5;
              return this.picoreader.cancel();
            case 5:
              if (!localPort) {
                _context3.next = 14;
                break;
              }
              _context3.prev = 6;
              _context3.next = 9;
              return localPort.close();
            case 9:
              _context3.next = 14;
              break;
            case 11:
              _context3.prev = 11;
              _context3.t0 = _context3["catch"](6);
              console.error(_context3.t0);
            case 14:
              this.status = 0;
              //this.markDisconnected();
            case 15:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[6, 11]]);
      }));
      function disconnect() {
        return _disconnect.apply(this, arguments);
      }
      return disconnect;
    }()
    /**
     * ポートをオープンします
     * @param {string} _v_ - デバイスから返却された値を格納するオブジェクト
     */
    )
  }, {
    key: "openpicoport",
    value: (function () {
      var _openpicoport = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_v_) {
        var _this2 = this;
        var ports, reader, serialProcessor;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return navigator.serial.getPorts();
            case 2:
              ports = _context4.sent;
              ports.forEach(function (port) {
                return _this2.addNewPort(port);
              });
              _context4.next = 6;
              return this.getSelectedPort();
            case 6:
              console.log('selectedPort:', this.picoport);
              if (this.picoport) {
                _context4.next = 9;
                break;
              }
              return _context4.abrupt("return");
            case 9:
              //this.markConnected();
              console.log('Connected!');
              _context4.prev = 10;
              _context4.next = 13;
              return this.picoport.open({
                baudRate: 115200
              });
            case 13:
              reader = this.picoport.readable.getReader();
              console.log('Connected!?!');

              // 必要な処理をここに追加
              this.status = 2;
              this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTED);

              // 1行毎に解析して、this._v_ に受信した変数を格納する
              serialProcessor = new SerialProcessor(_v_);
              serialProcessor.processData(reader).catch(console.error);

              //term.writeln('<CONNECTED>');
              _context4.next = 24;
              break;
            case 21:
              _context4.prev = 21;
              _context4.t0 = _context4["catch"](10);
              console.error(_context4.t0);
              //this.markDisconnected();
            case 24:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[10, 21]]);
      }));
      function openpicoport(_x2) {
        return _openpicoport.apply(this, arguments);
      }
      return openpicoport;
    }()
    /**
     * WritableStreamDefaultWriter を取得します。
     * @return {WritableStreamDefaultWriter | null}
     */
    )
  }, {
    key: "getWritablePort",
    value: (function () {
      var _getWritablePort = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              if (this.picoport && this.picoport.writable) {
                this.picowriter = this.picoport.writable.getWriter();
              } else {
                this.picowriter = null;
              }
              return _context5.abrupt("return", this.picowriter);
            case 2:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function getWritablePort() {
        return _getWritablePort.apply(this, arguments);
      }
      return getWritablePort;
    }()
    /**
     * Releases the lock held by the `picowriter` if it exists.
     * This method checks if the `picowriter` is defined and, if so,
     * calls its `releaseLock` method to release any held resources.
     */
    )
  }, {
    key: "releaseLock",
    value: function releaseLock() {
      if (this.picowriter) {
        this.picowriter.releaseLock();
      }
    }
    /**
     * Writes the provided data to the Pico writer.
     *
     * @param {Uint8Array} data - The data to be written, represented as a Uint8Array.
     * @return A promise that resolves when the write operation is complete.
     */
  }, {
    key: "picowrite",
    value: (function () {
      var _picowrite = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(s) {
        var _this$picowriter;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              this.getWritablePort();
              log$1.log("picowrite: ".concat(s, " : ").concat(this.picowriter));
              _context6.next = 4;
              return (_this$picowriter = this.picowriter) === null || _this$picowriter === void 0 ? void 0 : _this$picowriter.write(new TextEncoder().encode(s));
            case 4:
              this.releaseLock();
            case 5:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function picowrite(_x3) {
        return _picowrite.apply(this, arguments);
      }
      return picowrite;
    }())
  }, {
    key: "writeData",
    value: function () {
      var _writeData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(data) {
        var _this$picowriter2;
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              this.getWritablePort();
              _context7.next = 3;
              return (_this$picowriter2 = this.picowriter) === null || _this$picowriter2 === void 0 ? void 0 : _this$picowriter2.write(data);
            case 3:
              this.releaseLock();
            case 4:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function writeData(_x4) {
        return _writeData.apply(this, arguments);
      }
      return writeData;
    }()
  }]);
}();

/**
 * Manage communication with a MicroBit peripheral over a Scrath Link client socket.
 */
var Machine = /*#__PURE__*/function () {
  /**
   * Construct a MicroBit communication object.
   * @param {Runtime} runtime - the Scratch 3.0 runtime
   * @param {string} extensionId - the id of the extension
   */
  function Machine(runtime, extensionId) {
    var _this = this;
    _classCallCheck(this, Machine);
    /**
     * The Scratch 3.0 runtime used to trigger the green flag button.
     * @type {Runtime}
     * @private
     */
    this.runtime = runtime;

    // デバイスから返却された値を格納するオブジェクト
    this._v_ = {
      "dummy": 123
    };
    this._prev_ = {
      "prev": 456
    };

    // シリアル接続
    this.picoserial = null;
    try {
      this.picoserial = new PicoSerial(this.runtime);
    } catch (error) {
      console.log(error);
    }

    /**
     * The BluetoothLowEnergy connection socket for reading/writing peripheral data.
     * 以下の関数を用意しなければならない：
     * scan()
     * connect(peripheralId)
     * disconnect()
     * isConnected()
     * @type {BLE}
     * @private
     */
    this._ble = null;
    this.runtime.registerPeripheralExtension(extensionId, this);

    /**
     * The id of the extension this peripheral belongs to.
     */
    this._extensionId = extensionId;
    this.digitalLevel = {};
    this.lightLevel = 0;
    this.temperature = 0;
    this.soundLevel = 0;
    this.pitch = 0;
    this.roll = 0;
    this.acceleration = {
      x: 0,
      y: 0,
      z: 0
    };
    this.compassHeading = 0;
    this.magneticForce = {
      x: 0,
      y: 0,
      z: 0
    };
    this.buttonState = {};

    /**
     * The most recently received button events for each buttons.
     * @type {Object} - Store of buttons which has events.
     * @private
     */
    this.buttonEvents = {};
    //Object.keys(MbitMoreButtonStateIndex).forEach(name => {
    //    this.buttonEvents[name] = {};
    //});

    /**
     * The most recently received gesture events.
     * @type {Object <number, number>} - Store of gesture ID and timestamp.
     * @private
     */
    this.gestureEvents = {};

    /**
     * The most recently received events for each pin.
     * @type {Object} - Store of pins which has events.
     * @private
     */
    this._pinEvents = {};

    /**
     * The most recently received data from micro:bit.
     * @type {Object} - Store of received data
     * @private
     */
    this.receivedData = {};
    this.analogIn = [0, 1, 2];
    this.analogValue = [];
    //this.analogIn.forEach(pinIndex => {
    //    this.analogValue[pinIndex] = 0;
    //});

    this.gpio = [0, 1, 2, 8, 12, 13, 14, 15, 16];
    this.gpio.forEach(function (pinIndex) {
      _this.digitalLevel[pinIndex] = 0;
    });

    /**
     * Interval ID for data reading timeout.
     * @type {number}
     * @private
     */
    this._timeoutID = null;

    /**
     * A flag that is true while we are busy sending data to the BLE socket.
     * @type {boolean}
     * @private
     */
    this.bleBusy = true;

    /**
     * ID for a timeout which is used to clear the busy flag if it has been
     * true for a long time.
     */
    this.bleBusyTimeoutID = null;
    this.onDisconnect = this.onDisconnect.bind(this);
    this._onConnect = this._onConnect.bind(this);
    this.onNotify = this.onNotify.bind(this);
    this.stopTone = this.stopTone.bind(this);
    if (this.runtime) {
      this.runtime.on('PROJECT_STOP_ALL', this.stopTone);
    }
    this.analogInUpdateInterval = 100; // milli-seconds
    this.analogInLastUpdated = [Date.now(), Date.now(), Date.now()];

    /**
     * A time interval to wait (in milliseconds) while a block that sends a BLE message is running.
     * @type {number}
     */
    this.sendCommandInterval = 30;
    this.initConfig();

    // keyboard state monitor
    this.keyState = {};
    document.body.addEventListener('keydown', function (e) {
      _this.keyState[e.code] = {
        key: e.key,
        code: e.code,
        alt: e.altKey,
        ctrl: e.ctrlKey,
        meta: e.metaKey,
        shift: e.shiftKey
      };
    });
    document.body.addEventListener('keyup', function (e) {
      delete _this.keyState[e.code];
    });
  }

  /**
   * イベント処理
   */
  // 最後のイベントのIDを返却する
  return _createClass(Machine, [{
    key: "getLastEventId",
    value: function getLastEventId(name, event) {
      var key = "".concat(name, "_").concat(event);
      return this._v_[key];
    }
    // 前のイベントのIDを返却する
  }, {
    key: "getPrevEventId",
    value: function getPrevEventId(name, event) {
      var key = "".concat(name, "_").concat(event);
      return this._prev_[key];
    }
    // 前のイベントのIDを最後のイベントのIDで上書きする
  }, {
    key: "updatePrevEventId",
    value: function updatePrevEventId(name, event) {
      var key = "".concat(name, "_").concat(event);
      console.log("updatePrevEventId: ".concat(key, ": ").concat(this._prev_[key], " --> ").concat(this._v_[key]));
      this._prev_[key] = this._v_[key];
    }
    /**
     * Pico Serial
     */
  }, {
    key: "openpicoport",
    value: function openpicoport() {
      if (this.picoserial) {
        console.log("openpicoport!!");
        this.picoserial.openpicoport(this._v_);
      }
    }
  }, {
    key: "picowrite",
    value: function picowrite(s) {
      if (this.picoserial) {
        this.picoserial.picowrite(s);
      }
    }

    /**
     * Initialize configuration of the micro:bit.
     */
  }, {
    key: "initConfig",
    value: function initConfig() {
      this.config = {};
      this.config.mic = false;
      this.config.pinMode = {};
    }

    /**
     * Start updating process for micro:bit state and motion.
     */
  }, {
    key: "startUpdater",
    value: function startUpdater() {
      var _this2 = this;
      if (this.updater) {
        clearTimeout(this.updater);
      }
      if (this.bleAccessWaiting) {
        this.updater = setTimeout(function () {
          return _this2.startUpdater();
        }, 0);
        return;
      }
      this.updateState().then(function () {
        return _this2.updateMotion();
      }).finally(function () {
        _this2.updater = setTimeout(function () {
          return _this2.startUpdater();
        }, _this2.microbitUpdateInterval);
      });
    }

    /**
     * Stop updating process for micro:bit state and motion.
     */
  }, {
    key: "stopUpdater",
    value: function stopUpdater() {
      clearTimeout(this.updater);
    }

    /**
     * @param {string} text - the text to display.
     * @param {number} delay - The time to delay between characters, in milliseconds.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
     */
  }, {
    key: "displayText",
    value: function displayText(text, delay, util) {
      return Promise.resolve(0);
    }

    /**
     * Send display pixcels command to micro:bit.
     * @param {Array.<Array.<number>>} matrix - pattern to display.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
     */
  }, {
    key: "displayPixels",
    value: function displayPixels(matrix, util) {
      return Promise.resolve(0);
    }

    /**
     * Set pull mode to the pin.
     * @param {number} pinIndex - index of the pin
     * @param {MbitMorePullModeID} pullMode - pull mode to set
     * @param {BlockUtility} util - utility object provided from the runtime
     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
     */
  }, {
    key: "setPullMode",
    value: function setPullMode(pinIndex, pullMode, util) {
      return Promise.resolve(0);
    }

    /**
     * Set pin to digital output mode on the level.
     * @param {number} pinIndex - Index of pin.
     * @param {boolean} level - Value in digital (true = High)
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
     */
  }, {
    key: "setPinOutput",
    value: function setPinOutput(pinIndex, level, util) {
      return Promise.resolve(0);
    }

    /**
     * Set the pin to PWM mode on the level.
     * @param {number} pinIndex - index of the pin
     * @param {number} level - value of analog output [0..1024].
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
     */
  }, {
    key: "setPinPWM",
    value: function setPinPWM(pinIndex, level, util) {
      return Promise.resolve(0);
    }

    /**
     * Set the pin to Servo mode on the angle in the range and center.
     * @param {number} pinIndex - index of the pin.
     * @param {number} angle - the level to set on the output pin, in the range 0 - 180.
     * @param {number} range - the span of possible values. '0' means default(2000).
     * @param {number} center - the center point from which to calculate the lower and upper bounds.
     *                          '0' means default(1500).
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
     */
  }, {
    key: "setPinServo",
    value: function setPinServo(pinIndex, angle, range, center, util) {
      return Promise.resolve(0);
    }

    /**
     * Read light level from the light sensor.
     * @param {object} util - utility object provided by the runtime.
     * @return {number} - value of the light level [0..255].
     */
  }, {
    key: "readLightLevel",
    value: function readLightLevel() {
      if (!this.isConnected()) {
        return 0;
      }
      return this.lightLevel;
    }

    /**
     * Update data of the analog input.
     * @param {number} pinIndex - index of the pin to get value.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves value of analog input or undefined if this process was yield.
     */
  }, {
    key: "readAnalogIn",
    value: function readAnalogIn(pinIndex, util) {
      return Promise.resolve(0);
    }

    /**
     * Update data of digital level, light level, temperature, sound level.
     * @return {Promise} - a Promise that resolves updated data holder.
     */
  }, {
    key: "updateState",
    value: function updateState() {
      var _this4 = this;
      if (!this.isConnected()) return Promise.resolve(this);
      if (this.bleBusy) {
        return Promise.resolve(this);
      }
      this.bleBusy = true;
      this.bleBusyTimeoutID = window.setTimeout(function () {
        _this4.bleBusy = false;
      }, 1000);
      return new Promise(function (resolve) {
        _this4._ble.read(MM_SERVICE.ID, MM_SERVICE.STATE_CH, false).then(function (result) {
          window.clearTimeout(_this4.bleBusyTimeoutID);
          _this4.bleBusy = false;
          if (!result) return resolve(_this4);
          var data = base64ToUint8Array(result.message);
          var dataView = new DataView(data.buffer, 0);
          // Digital Input
          var gpioData = dataView.getUint32(0, true);
          for (var i = 0; i < _this4.gpio.length; i++) {
            _this4.digitalLevel[_this4.gpio[i]] = gpioData >> _this4.gpio[i] & 1;
          }
          Object.keys(MbitMoreButtonStateIndex).forEach(function (name) {
            _this4.buttonState[name] = gpioData >> 24 + MbitMoreButtonStateIndex[name] & 1;
          });
          _this4.lightLevel = dataView.getUint8(4);
          _this4.temperature = dataView.getUint8(5) - 128;
          _this4.soundLevel = dataView.getUint8(6);
          _this4.resetConnectionTimeout();
          resolve(_this4);
        });
      });
    }

    /**
     * Read temperature (integer in celsius) from the micro:bit cpu.
     * @return {number} - degrees of temperature [centigrade].
     */
  }, {
    key: "readTemperature",
    value: function readTemperature() {
      if (!this.isConnected()) {
        return 0;
      }
      return this.temperature;
    }

    /**
     * Configure microphone.
     * @param {boolean} use - true to use microphone.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} - a Promise that resolves state of the microphone or undefined if the process was yield.
     */
  }, {
    key: "configMic",
    value: function configMic(use, util) {
      var _this5 = this;
      use = use === true;
      if (!this.isConnected()) {
        return Promise.resolve(false);
      }
      if (this.config.mic === use) {
        return Promise.resolve(this.config.mic);
      }
      var sendPromise = this.sendCommandSet([{
        id: BLECommand.CMD_CONFIG << 5 | MbitMoreConfig.MIC,
        message: new Uint8Array([use ? 1 : 0]) // use microphone
      }], util);
      if (sendPromise) {
        return sendPromise.then(function () {
          _this5.config.mic = use;
          return _this5.config.mic;
        });
      }
      return;
    }

    /**
     * Play tone on the speaker.
     * @param {number} frequency - wave frequency to play [Hz]
     * @param {number} volume laudness of tone [%]
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} - a Promise that resolves to send command or undefined if this process was yield.
     */
  }, {
    key: "playTone",
    value: function playTone(frequency, volume, util) {
      if (!this.isConnected()) {
        return Promise.resolve();
      }
      var frequencyData = new DataView(new ArrayBuffer(4));
      frequencyData.setUint32(0, Math.round(1000000 / frequency), true);
      volume = Math.round(volume * 0xff / 100);
      return this.sendCommandSet([{
        id: BLECommand.CMD_AUDIO << 5 | MbitMoreAudioCommand.PLAY_TONE,
        message: new Uint8Array([frequencyData.getUint8(0), frequencyData.getUint8(1), frequencyData.getUint8(2), frequencyData.getUint8(3), volume])
      }], util);
    }

    /**
     * Stop playing tone on the speaker.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} - a Promise that resolves to send command or undefined if this process was yield.
     */
  }, {
    key: "stopTone",
    value: function stopTone(util) {
      console.log("machine.stopTone()");
      return Promise.resolve();
    }

    /**
     * Read sound level.
     * @return {number} - level of loudness (0 .. 255).
     */
  }, {
    key: "readSoundLevel",
    value: function readSoundLevel() {
      if (!this.isConnected()) {
        return 0;
      }
      return this.soundLevel;
    }

    /**
     * Update data of acceleration, magnetic force.
     * @return {Promise} - a Promise that resolves updated data holder.
     */
  }, {
    key: "updateMotion",
    value: function updateMotion() {
      return Promise.resolve();
    }

    /**
     * Read pitch [degrees] of the micro:bit heading direction.
     * @return {number} - degree of pitch.
     */
  }, {
    key: "readPitch",
    value: function readPitch() {
      if (!this.isConnected()) {
        return 0;
      }
      return this.pitch;
    }

    /**
     * Read roll [degrees] of the micro:bit heading direction.
     * @return {number} - degree of roll.
     */
  }, {
    key: "readRoll",
    value: function readRoll() {
      if (!this.isConnected()) {
        return 0;
      }
      return this.roll;
    }

    /**
     * Read the value of gravitational acceleration [milli-g] for the axis.
     * @param {AxisSymbol} axis - direction of acceleration.
     * @return {number} - value of acceleration.
     */
  }, {
    key: "readAcceleration",
    value: function readAcceleration(axis) {
      if (!this.isConnected()) {
        return 0;
      }
      if (axis === AxisSymbol.Absolute) {
        return Math.round(Math.sqrt(Math.pow(this.acceleration.x, 2) + Math.pow(this.acceleration.y, 2) + Math.pow(this.acceleration.z, 2)));
      }
      return this.acceleration[axis];
    }

    /**
     * Read the angle (degrees) of heading direction from the north.
     * @return {number} - degree of compass heading.
     */
  }, {
    key: "readCompassHeading",
    value: function readCompassHeading() {
      if (!this.isConnected()) {
        return 0;
      }
      return this.compassHeading;
    }

    /**
     * Read value of magnetic force [micro teslas] for the axis.
     * @param {AxisSymbol} axis - direction of magnetic force.
     * @return {number} - value of magnetic force.
     */
  }, {
    key: "readMagneticForce",
    value: function readMagneticForce(axis) {
      if (!this.isConnected()) {
        return 0;
      }
      if (axis === AxisSymbol.Absolute) {
        return Math.round(Math.sqrt(Math.pow(this.magneticForce.x, 2) + Math.pow(this.magneticForce.y, 2) + Math.pow(this.magneticForce.z, 2)));
      }
      return this.magneticForce[axis];
    }

    /**
     * Whether the key is pressed at this moment.
     * @param {string} key - key in keyboard event
     * @returns {boolean} - return true when the key is pressed
     */
  }, {
    key: "isKeyPressing",
    value: function isKeyPressing(key) {
      return Object.values(this.keyState).find(function (state) {
        return state.key === key;
      });
    }

    /**
     * Called by the runtime when user wants to scan for a peripheral.
     */
  }, {
    key: "scan",
    value: function scan() {
      console.log("machine.scan() new!!!!");
      this.openpicoport();
      return;
    }
    /**
     * Start to scan USB serial devices to find micro:bit v2.
     */
  }, {
    key: "scanSerial",
    value: function scanSerial() {
      return;
    }
    /**
     * Called by the runtime when user wants to connect to a certain peripheral.
     * @param {number} id - the id of the peripheral to connect to.
     */
  }, {
    key: "connect",
    value: function connect(id) {
      console.log("machine.connect()", id);
      //if (this._ble) {
      //    this._ble.connectPeripheral(id);
      //}
    }

    /**
     * Disconnect from the micro:bit.
     */
  }, {
    key: "disconnect",
    value: function disconnect() {
      console.log("machine.disconnect()");
      if (this.picoserial) {
        return this.picoserial.disconnect();
      }
      this.onDisconnect();
    }

    /**
     * Reset all the state and timeout/interval ids.
     */
  }, {
    key: "onDisconnect",
    value: function onDisconnect() {
      console.log("machine.onDisconnect()");
      return;
    }

    /**
     * Return true if connected to the micro:bit.
     * @return {boolean} - whether the micro:bit is connected.
     */
  }, {
    key: "isConnected",
    value: function isConnected() {
      console.log("machine.isConnected()");
      if (this.picoserial) {
        console.log(this.picoserial.isConnected());
        return this.picoserial.isConnected();
      }
      return false;
    }

    /**
     * Send a command to micro:bit.
     * @param {object} command command to send.
     * @param {number} command.id ID of the command.
     * @param {Uint8Array} command.message Contents of the command.
     * @return {Promise} a Promise that resolves when the data was sent and after send command interval.
     */
  }, {
    key: "sendCommand",
    value: function sendCommand(command) {
      return Promise.resolve();
    }

    /**
     * Send multiple commands sequentially.
     * @param {Array.<{id: number, message: Uint8Array}>} commands array of command.
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when the all commands was sent.
     */
  }, {
    key: "sendCommandSet",
    value: function sendCommandSet(commands, util) {
      return Promise.resolve();
    }

    /**
     * Starts reading data from peripheral after BLE has connected to it.
     */
  }, {
    key: "_onConnect",
    value: function _onConnect() {
      return Promise.resolve();
    }

    /**
     * Process the data from the incoming BLE characteristic.
     * @param {string} msg - the incoming BLE data.
     * @private
     */
  }, {
    key: "onNotify",
    value: function onNotify(msg) {
      console.log("machine.onNotify()", msg);
      return;
    }

    /**
     * Cancel disconnect timeout and start counting again.
     */
  }, {
    key: "resetConnectionTimeout",
    value: function resetConnectionTimeout() {
      return;
    }

    /**
     * Return whether the pin value is high.
     * @param {number} pin - the pin to check.
     * @return {boolean} - whether the pin is high or not.
     */
  }, {
    key: "isPinHigh",
    value: function isPinHigh(pin) {
      return 0;
    }

    /**
     * Read digital input from the pin.
     * @param {number} pin - the pin to read.
     * @return {number} - digital input value of the pin [0|1].
     */
  }, {
    key: "readDigitalLevel",
    value: function readDigitalLevel(pin) {
      if (!this.isConnected()) {
        return 0;
      }
      return this.digitalLevel[pin];
    }

    /**
     * Return whether the button is pressed.
     * @param {string} buttonName - name of the button
     * @return {boolean} - true when it is pressed
     */
  }, {
    key: "isButtonPressed",
    value: function isButtonPressed(buttonName) {
      if (!this.isConnected()) {
        return false;
      }
      return this.buttonState[buttonName] === 1;
    }

    /**
     * Return whether the pin is touch-mode.
     * @param {number} pinIndex - indesx of the pin
     * @return {boolean} - true when it is touch-mode
     */
  }, {
    key: "isPinTouchMode",
    value: function isPinTouchMode(pinIndex) {
      return this.config.pinMode[pinIndex] === MbitMorePinMode.TOUCH;
    }

    /**
     * Configurate touch mode of the pin.
     * @param {number} pinIndex - index of the pin as a button.
     * @param {object} util - utility object provided by the runtime.
     * @return {?Promise} - a Promise that resolves when configured or undefined if the process was yield.
     */
  }, {
    key: "configTouchPin",
    value: function configTouchPin(pinIndex, util) {
      return Promise.resolve();
    }

    /**
     * Return whether the touche-pin is touched.
     * @param {string} buttonName - ID to check.
     * @return {boolean} - whether the id is high or not.
     */
  }, {
    key: "isTouched",
    value: function isTouched(buttonName) {
      if (!this.isConnected()) {
        return false;
      }
      return this.buttonState[buttonName] === 1;
    }

    /**
     * Return the last timestamp of the button event or undefined if the event is not received.
     * @param {MbitMoreButtonName} buttonName - name of the button to get the event.
     * @param {MbitMoreButtonEventName} eventName - name of event to get.
     * @return {?number} Timestamp of the last event or null.
     */
  }, {
    key: "getButtonEventTimestamp",
    value: function getButtonEventTimestamp(buttonName, eventName) {
      if (this.buttonEvents[buttonName] && this.buttonEvents[buttonName][eventName]) {
        return this.buttonEvents[buttonName][eventName];
      }
      return null;
    }

    /**
     * Return the last timestamp of the gesture event or undefined if the event is not received.
     * @param {MbitMoreGestureName} gestureName - name of the event.
     * @return {?number} Timestamp of the last event or null.
     */
  }, {
    key: "getGestureEventTimestamp",
    value: function getGestureEventTimestamp(gestureName) {
      if (this.gestureEvents[gestureName]) {
        return this.gestureEvents[gestureName];
      }
      return null;
    }

    /**
     * Return the last value of the pin event or undefined if the event was not received.
     * @param {number} pinIndex - index of the pin to get the event.
     * @param {MbitMorePinEvent} event - event to get.
     * @return {?number} Timestamp of the last event or null.
     */
  }, {
    key: "getPinEventValue",
    value: function getPinEventValue(pinIndex, event) {
      if (this._pinEvents[pinIndex] && this._pinEvents[pinIndex][event]) {
        return this._pinEvents[pinIndex][event].value;
      }
      return null;
    }

    /**
     * Return the last timestamp of the pin event or undefined if the event was not received.
     * @param {number} pinIndex - index of the pin to get the event.
     * @param {MbitMorePinEvent} event - event to get.
     * @return {?number} Timestamp of the last event or null.
     */
  }, {
    key: "getPinEventTimestamp",
    value: function getPinEventTimestamp(pinIndex, event) {
      if (this._pinEvents[pinIndex] && this._pinEvents[pinIndex][event]) {
        return this._pinEvents[pinIndex][event].timestamp;
      }
      return null;
    }

    /**
     * Set event type to be get from the pin.
     * @param {number} pinIndex - Index of the pin to set.
     * @param {MbitMorePinEventType} eventType - Event type to set.
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when command sending done or undefined if this process was yield.
     */
  }, {
    key: "listenPinEventType",
    value: function listenPinEventType(pinIndex, eventType, util) {
      return Promise.resolve();
    }

    /**
     * Send data to micro:bit.
     * @param {string} label - label of the data [ascii]
     * @param {string} content - content of the data [ascii | number]
     * @param {BlockUtility} util - utility object provided by the runtime.
     * @return {?Promise} a Promise that resolves when sending done or undefined if this process was yield.
     */
  }, {
    key: "sendData",
    value: function sendData(label, content, util) {
      return Promise.resolve();
    }

    /**
     * Return the last data with the label or undefined if no data received with the label.
     * @param {string} label - label to get.
     * @return {?(number | string)} data of the label or null.
     */
  }, {
    key: "getDataLabeled",
    value: function getDataLabeled(label) {
      if (this.receivedData[label]) {
        return this.receivedData[label].content;
      }
      return null;
    }

    /**
     * Return the last timestamp of the data or undefined if the data is not received.
     * @param {string} label - label of the data.
     * @return {?number} Timestamp of the last data or null.
     */
  }, {
    key: "getDataTimestamp",
    value: function getDataTimestamp(label) {
      if (this.receivedData[label]) {
        return this.receivedData[label].timestamp;
      }
      return null;
    }
  }]);
}();

/**
 * Formatter which is used for translation.
 * This will be replaced which is used in the runtime.
 * @param {object} messageData - format-message object
 * @returns {string} - message for the locale
 */
var formatMessage = function formatMessage(messageData) {
  return messageData.default;
};

/**
 * Setup format-message for this extension.
 */
var setupTranslations = function setupTranslations() {
  var localeSetup = formatMessage.setup();
  if (localeSetup && localeSetup.translations[localeSetup.locale]) {
    Object.assign(localeSetup.translations[localeSetup.locale], translations[localeSetup.locale]);
  }
};
var EXTENSION_ID = 'pcratchPico';

/**
 * URL to get this extension as a module.
 * When it was loaded as a module, 'extensionURL' will be replaced a URL which is retrieved from.
 * @type {string}
 */
var extensionURL = 'https://yokobond.github.io/xcx-xcratchExample/dist/pcratchPico.mjs';

/**
 * Scratch 3.0 blocks for example of Xcratch.
 */
var ExtensionBlocks = /*#__PURE__*/function () {
  /**
   * Construct a set of blocks for pcratchPico.
   * @param {Runtime} runtime - the Scratch 3.0 runtime.
   */
  function ExtensionBlocks(runtime) {
    _classCallCheck(this, ExtensionBlocks);
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime;
    if (runtime.formatMessage) {
      // Replace 'formatMessage' to a formatter which is used in the runtime.
      formatMessage = runtime.formatMessage;
    }

    // Create a new MicroBit peripheral instance
    // machine.picowrite(string)
    // machine.openpicoport(_v_)
    this.machine = new Machine(this.runtime, ExtensionBlocks.EXTENSION_ID);

    // シリアル接続
    //try {
    //    this.picoserial = new PicoSerial();
    //} catch (error) {
    //    console.log(error);
    //}

    //this.connectPeripheral(); // ペリフェラルに接続
  }

  /**
   * @returns {object} metadata for this extension and its blocks.
   */
  return _createClass(ExtensionBlocks, [{
    key: "getInfo",
    value: function getInfo() {
      setupTranslations();
      return {
        id: ExtensionBlocks.EXTENSION_ID,
        name: ExtensionBlocks.EXTENSION_NAME,
        extensionURL: ExtensionBlocks.extensionURL,
        blockIconURI: img,
        showStatusButton: true,
        blocks: [{
          // Picoに接続する
          opcode: "connectPico",
          text: formatMessage({
            id: "pcratchPico.connectPico",
            default: "MicroPythonデバイスと接続 [PORT]",
            description: "MicroPythonデバイスとシリアル通信で接続します"
          }),
          blockType: BlockType$1.COMMAND,
          arguments: {
            PORT: {
              type: ArgumentType$1.STRING,
              defaultValue: "0"
            }
          }
        }, {
          // コマンドを送信して実行させる
          opcode: "execCommand",
          text: formatMessage({
            id: "pcratchPico.execCommand",
            default: "[TEXT] を実行"
          }),
          blockType: BlockType$1.COMMAND,
          arguments: {
            TEXT: {
              type: ArgumentType$1.STRING,
              defaultValue: "dumpADC()"
            }
          }
        }, {
          // CTRL-x を送信する
          opcode: "sendCtrlCode",
          text: formatMessage({
            id: "pcratchPico.sendCtrlCode",
            default: "CTRL- [TEXT] を送信"
          }),
          blockType: BlockType$1.COMMAND,
          arguments: {
            TEXT: {
              type: ArgumentType$1.STRING,
              defaultValue: "D"
            }
          }
        }, {
          // デバイスの返却値を表示する
          opcode: 'dumpValue',
          blockType: BlockType$1.REPORTER,
          blockAllThreads: false,
          text: formatMessage({
            id: 'pcratchPico.dumpValue',
            default: 'デバイスの返却値! [SCRIPT]',
            description: 'デバイスの変数を表示する!'
          }),
          arguments: {
            SCRIPT: {
              type: ArgumentType$1.STRING,
              defaultValue: 'adc00'
            }
          }
        }, {
          // ADC0 の値を表示する
          opcode: 'getAdc00',
          text: formatMessage({
            id: 'pcratchPico.getAdc00',
            default: 'ADC0',
            description: 'ADC0の値'
          }),
          blockType: BlockType$1.REPORTER
        }, {
          opcode: 'getAdc01',
          text: formatMessage({
            id: 'pcratchPico.getAdc01',
            default: 'ADC1',
            description: 'ADC1の値'
          }),
          blockType: BlockType$1.REPORTER
        }, {
          opcode: 'getAdc02',
          text: formatMessage({
            id: 'pcratchPico.getAdc02',
            default: 'ADC2',
            description: 'ADC2の値'
          }),
          blockType: BlockType$1.REPORTER
        }, {
          opcode: 'getAdc03',
          text: formatMessage({
            id: 'pcratchPico.getAdc03',
            default: 'ADC3',
            description: 'ADC3の値'
          }),
          blockType: BlockType$1.REPORTER
        }, {
          opcode: 'getAdc04',
          text: formatMessage({
            id: 'pcratchPico.getAdc04',
            default: 'ADC4',
            description: 'ADC4の値'
          }),
          blockType: BlockType$1.REPORTER
        }, {
          opcode: 'getLightLevel',
          text: formatMessage({
            id: 'pcratchPico.lightLevel',
            default: 'light intensity',
            description: 'how much the amount of light falling on the LEDs on micro:bit'
          }),
          blockType: BlockType$1.REPORTER
        }, {
          opcode: 'whenButtonEvent',
          text: formatMessage({
            id: 'mbitMore.whenButtonEvent',
            default: 'when button [NAME] is [EVENT]',
            description: 'when the selected button on the micro:bit get the selected event'
          }),
          blockType: BlockType$1.HAT,
          arguments: {
            NAME: {
              type: ArgumentType$1.STRING,
              defaultValue: 'A'
            },
            EVENT: {
              type: ArgumentType$1.STRING,
              defaultValue: 'DOWN'
            }
          }
        }],
        menus: {}
      };
    }
    /**
     * Test whether the event raised at the button.
     * @param {object} args - the block's arguments.
     * @param {string} args.NAME - name of the button.
     * @param {string} args.EVENT - name of event to catch.
     * @return {boolean} - true if the event raised.
     */
  }, {
    key: "whenButtonEvent",
    value: function whenButtonEvent(args) {
      var _this = this;
      var name = args.NAME;
      var event = args.EVENT;
      var lid = this.machine.getLastEventId(name, event);
      if (!lid) return false; // no event
      var pid = this.machine.getPrevEventId(name, event);
      if (lid === pid) return false; // no new event
      if (!this.updateLastButtonEventTimer) {
        this.updateLastButtonEventTimer = setTimeout(function () {
          _this.machine.updatePrevEventId(name, event);
          _this.updateLastButtonEventTimer = null;
        }, this.runtime.currentStepTime);
      }
      return true;
    }
    /**
     * Get amount of light (0 - 255) on the LEDs.
     * @param {object} args - the block's arguments.
     * @return {number} - light level.
     */
  }, {
    key: "getLightLevel",
    value: function getLightLevel() {
      // const level = this.microbit.readLightLevel();
      // return Math.round(level * 1000 / 255) / 10;
      return 21;
    }
    /**
     * ADC 0-4 の値を取得する
     * @param {object} args - the block's arguments.
     * @return {number} 0 - 65535
     */
  }, {
    key: "getAdc00",
    value: function getAdc00() {
      return this.machine._v_ && this.machine._v_["adc00"] !== undefined ? this.machine._v_["adc00"] : 0;
    }
  }, {
    key: "getAdc01",
    value: function getAdc01() {
      return this.machine._v_ && this.machine._v_["adc01"] !== undefined ? this.machine._v_["adc01"] : 0;
    }
  }, {
    key: "getAdc02",
    value: function getAdc02() {
      return this.machine._v_ && this.machine._v_["adc02"] !== undefined ? this.machine._v_["adc02"] : 0;
    }
  }, {
    key: "getAdc03",
    value: function getAdc03() {
      return this.machine._v_ && this.machine._v_["adc03"] !== undefined ? this.machine._v_["adc03"] : 0;
    }
  }, {
    key: "getAdc04",
    value: function getAdc04() {
      return this.machine._v_ && this.machine._v_["adc04"] !== undefined ? this.machine._v_["adc04"] : 0;
    }
  }, {
    key: "doIt",
    value: function doIt(args) {
      var statement = Cast$1.toString(args.SCRIPT);
      var func = new Function("return (".concat(statement, ")"));
      log$1.log("doIt: ".concat(statement));
      return func.call(this);
    }

    /**
     * 
     * @param {*} args 
     * @returns 
     */
  }, {
    key: "dumpValue",
    value: function dumpValue(args) {
      var statement = Cast$1.toString(args.SCRIPT);
      log$1.log("dumpValue: ".concat(statement));
      try {
        console.log('this.machine._v_:', this.machine._v_);
        var value = this.machine._v_[statement];
        return value;
      } catch (error) {
        console.log(error);
      }
      return undefined;
    }

    /**
     * Picoに接続する
     * connectPico
     */
  }, {
    key: "connectPico",
    value: function connectPico(args) {
      var port = Cast$1.toString(args.PORT);
      log$1.log("connectPico: ".concat(port));
      try {
        this.machine.openpicoport();
      } catch (error) {
        console.log(error);
      }
    }

    /**
     * コマンド実行
     * Send Message.
     * @param {TEXT} args - the message to be sent.
     */
  }, {
    key: "execCommand",
    value: function execCommand(args) {
      try {
        var text = Cast$1.toString(args.TEXT);
        this.machine.picowrite(text + '\r\n');
      } catch (error) {
        console.log(error);
      }
    }
    /**
     * text の1文字目を大文字にして、A から Z なら、CTRL+A から CTRL+Z に変換して送信
     */
  }, {
    key: "sendCtrlCode",
    value: function sendCtrlCode(args) {
      var text = Cast$1.toString(args.TEXT);
      // text の1文字目を大文字にして、A から Z なら、CTRL+A から CTRL+Z に変換
      var textUpper = text.toUpperCase();
      var code = textUpper.charCodeAt(0);
      var ctrlCode = code - 64;
      log$1.log("CTRL-: ".concat(text, " : ").concat(code, " : ").concat(ctrlCode));
      this.machine.picowrite(String.fromCharCode(ctrlCode));
    }
  }], [{
    key: "formatMessage",
    set:
    /**
     * A translation object which is used in this class.
     * @param {FormatObject} formatter - translation object
     */
    function set(formatter) {
      formatMessage = formatter;
      if (formatMessage) setupTranslations();
    }

    /**
     * @return {string} - the name of this extension.
     */
  }, {
    key: "EXTENSION_NAME",
    get: function get() {
      return formatMessage({
        id: 'pcratchPico.name',
        default: 'pcratchPico',
        description: 'pcratch Micro-Python Extension'
      });
    }

    /**
     * @return {string} - the ID of this extension.
     */
  }, {
    key: "EXTENSION_ID",
    get: function get() {
      return EXTENSION_ID;
    }

    /**
     * URL to get this extension.
     * @type {string}
     */
  }, {
    key: "extensionURL",
    get: function get() {
      return extensionURL;
    }

    /**
     * Set URL to get this extension.
     * The extensionURL will be changed to the URL of the loading server.
     * @param {string} url - URL
     */,
    set: function set(url) {
      extensionURL = url;
    }
  }]);
}();

export { ExtensionBlocks as blockClass, entry };
//# sourceMappingURL=RasPicoMoreExt.mjs.map
